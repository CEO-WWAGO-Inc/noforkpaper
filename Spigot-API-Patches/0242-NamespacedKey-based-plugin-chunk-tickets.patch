From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Trigary <trigary0@gmail.com>
Date: Sat, 22 Aug 2020 14:41:43 +0200
Subject: [PATCH] NamespacedKey based plugin chunk tickets


diff --git a/src/main/java/io/papermc/paper/TickingLevel.java b/src/main/java/io/papermc/paper/TickingLevel.java
new file mode 100644
index 0000000000000000000000000000000000000000..e0ffc541981caae5ca031ff7e5b2247e2af030c5
--- /dev/null
+++ b/src/main/java/io/papermc/paper/TickingLevel.java
@@ -0,0 +1,57 @@
+package io.papermc.paper;
+
+import org.apache.commons.lang.Validate;
+import org.bukkit.Chunk;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Represents what kind of ticking is done on the {@link Chunk}.
+ * The important values have dedicated cached instances, eg. {@link #ENTITY}.
+ * Read their own documentation for more information.
+ */
+public enum TickingLevel {
+
+    /**
+     * Both blocks and entities get ticked in this level.
+     */
+    ENTITY,
+
+    /**
+     * Blocks get ticked in this level, but entities do not.
+     */
+    BLOCK,
+
+    /**
+     * Nothing gets ticked in this level, but the {@link Chunk} stays loaded.
+     */
+    NONE;
+
+    /**
+     * Gets whether this ticking level does at least as much as the specified one.
+     * Examples:
+     * <ul>
+     *     <li>{@code BLOCK.includes(ENTITY) == false}</li>
+     *     <li>{@code BLOCK.includes(BLOCK) == true}</li>
+     *     <li>{@code BLOCK.includes(NONE) == true}</li>
+     * </ul>
+     *
+     * @param other the ticking level to test
+     * @return {@code true} if the current instance does at least everything
+     * the other one does, {@code false} otherwise
+     */
+    @Contract(pure = true)
+    public boolean includes(@NotNull TickingLevel other) {
+        Validate.notNull(other, "Ticking level cannot be null");
+        switch (this) {
+            case ENTITY:
+                return true;
+            case BLOCK:
+                return other != ENTITY;
+            case NONE:
+                return other == NONE;
+            default:
+                throw new AssertionError("Unhandled case: " + this);
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/Chunk.java b/src/main/java/org/bukkit/Chunk.java
index b4ef6297f78d1f0c216e718024a21e6aa07cd1c6..eea7813b78b3c53f7729793730fedd9269646f2c 100644
--- a/src/main/java/org/bukkit/Chunk.java
+++ b/src/main/java/org/bukkit/Chunk.java
@@ -240,6 +240,78 @@ public interface Chunk extends PersistentDataHolder {
     @NotNull
     Collection<Plugin> getPluginChunkTickets();
 
+    // Paper start
+    /**
+     * Adds a {@link NamespacedKey} based plugin chunk ticket
+     * with {@link io.papermc.paper.TickingLevel#ENTITY}.
+     * If a ticket with a different level is already present, it will be removed.
+     *
+     * @param key the identifier of the ticket
+     * @return the {@link io.papermc.paper.TickingLevel} that was overwritten
+     * or {@code null} if no ticket was present with the specified key
+     * @see World#addKeyedPluginChunkTicket(int, int, NamespacedKey)
+     */
+    @org.jetbrains.annotations.Nullable
+    default io.papermc.paper.TickingLevel addKeyedPluginChunkTicket(@NotNull NamespacedKey key) {
+        return getWorld().addKeyedPluginChunkTicket(getX(), getZ(), key);
+    }
+
+    /**
+     * Adds a {@link NamespacedKey} based plugin chunk ticket
+     * with the specified {@link io.papermc.paper.TickingLevel}.
+     * If a ticket with a different level is already present, it will be removed.
+     *
+     * @param key the identifier of the ticket
+     * @param level the level of the ticket
+     * @return the {@link io.papermc.paper.TickingLevel} that was overwritten
+     * or {@code null} if no ticket was present with the specified key
+     * @see World#addKeyedPluginChunkTicket(int, int, NamespacedKey, io.papermc.paper.TickingLevel)
+     */
+    @org.jetbrains.annotations.Nullable
+    default io.papermc.paper.TickingLevel addKeyedPluginChunkTicket(@NotNull NamespacedKey key, @NotNull io.papermc.paper.TickingLevel level) {
+        return getWorld().addKeyedPluginChunkTicket(getX(), getZ(), key, level);
+    }
+
+    /**
+     * Removes the {@link NamespacedKey} based plugin chunk ticket
+     * which has the specified key, if there is one.
+     *
+     * @param key the identifier of the tickets
+     * @return the {@link io.papermc.paper.TickingLevel} that was removed
+     * or {@code null} if no ticket was present with the specified key
+     * @see World#removeKeyedPluginChunkTicket(int, int, NamespacedKey)
+     */
+    @org.jetbrains.annotations.Nullable
+    default io.papermc.paper.TickingLevel removeKeyedPluginChunkTicket(@NotNull NamespacedKey key) {
+        return getWorld().removeKeyedPluginChunkTicket(getX(), getZ(), key);
+    }
+
+    /**
+     * Gets the {@link NamespacedKey} based plugin chunk ticket level
+     * with the specified key, if there is one.
+     *
+     * @param key the identifier of the tickets
+     * @return the level which is present with the specified key or {@code null} if there is none
+     * @see #getKeyedPluginChunkTicketLevel(NamespacedKey)
+     */
+    @org.jetbrains.annotations.Nullable
+    default io.papermc.paper.TickingLevel getKeyedPluginChunkTicketLevel(@NotNull NamespacedKey key) {
+        return getWorld().getKeyedPluginChunkTicketLevel(getX(), getZ(), key);
+    }
+
+    /**
+     * Gets the keys of the {@link NamespacedKey} based plugin chunk tickets
+     * which are present in this chunk.
+     *
+     * @return the keys which are present
+     * @see World#getKeyedPluginChunkTicketKeys(int, int)
+     */
+    @NotNull
+    default Collection<NamespacedKey> getKeyedPluginChunkTicketKeys() {
+        return getWorld().getKeyedPluginChunkTicketKeys(getX(), getZ());
+    }
+    // Paper end
+
     /**
      * Gets the amount of time in ticks that this chunk has been inhabited.
      *
diff --git a/src/main/java/org/bukkit/World.java b/src/main/java/org/bukkit/World.java
index e6d2abf284c103a8bcddd8b4f9cb34d86a4f2fa6..a81a089743f0407ff7a6952d4afa8b039880ac95 100644
--- a/src/main/java/org/bukkit/World.java
+++ b/src/main/java/org/bukkit/World.java
@@ -1115,6 +1115,147 @@ public interface World extends PluginMessageRecipient, Metadatable {
     @NotNull
     public Map<Plugin, Collection<Chunk>> getPluginChunkTickets();
 
+    // Paper start
+    /**
+     * Adds a {@link NamespacedKey} based plugin chunk ticket
+     * to the specified chunk with {@link io.papermc.paper.TickingLevel#ENTITY}.
+     * If a ticket with a different level is already present, it will be removed.
+     *
+     * @param x X-coordinate of the chunk
+     * @param z Z-coordinate of the chunk
+     * @param key the identifier of the ticket
+     * @return the {@link io.papermc.paper.TickingLevel} that was overwritten
+     * or {@code null} if no ticket was present with the specified key
+     * @see #addKeyedPluginChunkTicket(int, int, NamespacedKey, io.papermc.paper.TickingLevel)
+     */
+    @Nullable
+    io.papermc.paper.TickingLevel addKeyedPluginChunkTicket(int x, int z, @NotNull NamespacedKey key);
+
+    /**
+     * Adds a {@link NamespacedKey} based plugin chunk ticket
+     * to the specified chunk with the specified {@link io.papermc.paper.TickingLevel}.
+     * If a ticket with a different level is already present, it will be removed.
+     *
+     * @param x X-coordinate of the chunk
+     * @param z Z-coordinate of the chunk
+     * @param key the identifier of the ticket
+     * @param level the level of the ticket
+     * @return the {@link io.papermc.paper.TickingLevel} that was overwritten
+     * or {@code null} if no ticket was present with the specified key
+     */
+    @Nullable
+    io.papermc.paper.TickingLevel addKeyedPluginChunkTicket(int x, int z, @NotNull NamespacedKey key, @NotNull io.papermc.paper.TickingLevel level);
+
+    /**
+     * Removes the {@link NamespacedKey} based plugin chunk ticket
+     * from the specified chunk which has the specified key, if there is one.
+     *
+     * @param x X-coordinate of the chunk
+     * @param z Z-coordinate of the chunk
+     * @param key the identifier of the tickets
+     * @return the {@link io.papermc.paper.TickingLevel} that was removed
+     * or {@code null} if no ticket was present with the specified key
+     */
+    @Nullable
+    io.papermc.paper.TickingLevel removeKeyedPluginChunkTicket(int x, int z, @NotNull NamespacedKey key);
+
+    /**
+     * Gets the {@link NamespacedKey} based plugin chunk ticket level
+     * in the specified chunk with the specified key, if there is one.
+     *
+     * @param x X-coordinate of the chunk
+     * @param z Z-coordinate of the chunk
+     * @param key the identifier of the tickets
+     * @return the level which is present with the specified key or {@code null} if there is none
+     */
+    @Nullable
+    io.papermc.paper.TickingLevel getKeyedPluginChunkTicketLevel(int x, int z, @NotNull NamespacedKey key);
+
+    /**
+     * Gets the keys of the {@link NamespacedKey} based plugin chunk tickets
+     * which are present in the specified chunk.
+     *
+     * @param x X-coordinate of the chunk
+     * @param z Z-coordinate of the chunk
+     * @return the keys which are present
+     */
+    @NotNull
+    Collection<NamespacedKey> getKeyedPluginChunkTicketKeys(int x, int z);
+
+    /**
+     * Removes all {@link NamespacedKey} based plugin chunk tickets
+     * from each chunk which has the specified plugin
+     * according to {@link NamespacedKey#getNamespace()}.
+     *
+     * @param plugin the plugin whose tickets to remove
+     */
+    void removeKeyedPluginChunkTickets(@NotNull Plugin plugin);
+
+    /**
+     * Removes all {@link NamespacedKey} based plugin chunk tickets
+     * from each chunk which has the specified key.
+     *
+     * @param key the identifier of the tickets which should be removed
+     */
+    void removeKeyedPluginChunkTickets(@NotNull NamespacedKey key);
+
+    /**
+     * Gets all chunk keys which have a {@link NamespacedKey}
+     * based plugin chunk ticket with the specified key.
+     * Keep in mind that these chunks might not be loaded yet:
+     * having a chunk ticket only guarantees that chunk loading has begun,
+     * not that the loading has already been completed.
+     * If only loaded chunks are needed,
+     * please refer to {@link #getKeyedPluginChunkTicketLoadedChunks(NamespacedKey)}.
+     * More information regarding chunk keys can be found
+     * in the documentation of {@link #getChunkAt(long)}.
+     *
+     * @return the chunk keys which have tickets with the specified key
+     */
+    @NotNull
+    Collection<Long> getKeyedPluginChunkTicketChunks(@NotNull NamespacedKey key);
+
+    /**
+     * Gets all loaded chunks which have a {@link NamespacedKey}
+     * based plugin chunk ticket with the specified key.
+     * Keep in mind that only chunks are included.
+     * If that's not desired, or if you would like to know more,
+     * please refer to {@link #getKeyedPluginChunkTicketChunks(NamespacedKey)}.
+     *
+     * @return the loaded chunks which have tickets with the specified key
+     */
+    @NotNull
+    Collection<Chunk> getKeyedPluginChunkTicketLoadedChunks(@NotNull NamespacedKey key);
+
+    /**
+     * Gets all {@link NamespacedKey} based plugin chunk tickets,
+     * with chunk keys mapped to the ticket keys they contain.
+     * Keep in mind that these chunks might not be loaded yet:
+     * having a chunk ticket only guarantees that chunk loading has begun,
+     * not that the loading has already been completed.
+     * If only loaded chunks are needed,
+     * please refer to {@link #getAllLoadedKeyedPluginChunkTickets()}.
+     * More information regarding chunk keys can be found
+     * in the documentation of {@link #getChunkAt(long)}.
+     *
+     * @return the chunks and their ticket keys
+     */
+    @NotNull
+    com.google.common.collect.Multimap<Long, NamespacedKey> getAllKeyedPluginChunkTickets();
+
+    /**
+     * Gets all {@link NamespacedKey} based plugin chunk tickets whose chunks are loaded,
+     * with chunks mapped to the ticket keys they contain.
+     * Keep in mind that only chunks are included.
+     * If that's not desired, or if you would like to know more,
+     * please refer to {@link #getAllKeyedPluginChunkTickets()}.
+     *
+     * @return the chunks and their ticket keys
+     */
+    @NotNull
+    com.google.common.collect.Multimap<Chunk, NamespacedKey> getAllLoadedKeyedPluginChunkTickets();
+    // Paper end
+
     /**
      * Drops an item at the specified {@link Location}
      *
