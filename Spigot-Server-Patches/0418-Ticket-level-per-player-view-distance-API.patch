From b73f2b42e37db856d08d557aef374ac6ec51e39f Mon Sep 17 00:00:00 2001
From: slicklibro <slicklibro@gmail.com>
Date: Fri, 20 Sep 2019 17:16:14 +1200
Subject: [PATCH] Ticket level per-player view distance API

This PR implements the per-player view distance API at the ticket level.
This somewhat clean solution comes from the result of many complicated ones (and research).
The view distance will determine how far the player can add tickets to chunks.
The tracking view distance will determine how far the player can see/load chunks with tickets.
All chunks with player tickets within this range will also be served by the server, allowing shared view distance from other players without impacting performance.

diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index 63a688725..4db2e954f 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -43,6 +43,16 @@ public abstract class ChunkMapDistance {
     private final LongSet l = new LongOpenHashSet();
     private final Executor m;
     private long currentTick;
+    //Paper start ticket level pp-view-dist
+    protected final it.unimi.dsi.fastutil.ints.Int2ObjectMap<Square> squares = new it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap<>();
+    protected it.unimi.dsi.fastutil.longs.Long2ByteMap update = new it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap();
+    class Square {
+        public int x, y, u, v, ticket;
+        public Square(int x1, int y1, int u1, int v1, int ticket1) {
+            x = x1; y = y1; u = u1; v = v1; ticket = ticket1;
+        }
+    }
+    //Paper end
 
     protected ChunkMapDistance(Executor executor, Executor executor1) {
         executor1.getClass();
@@ -234,6 +244,94 @@ public abstract class ChunkMapDistance {
         ((ObjectSet) this.c.computeIfAbsent(i, (j) -> {
             return new ObjectOpenHashSet();
         })).add(entityplayer);
+
+        //Paper start ticket level pp-view-dist
+        int cx = ChunkCoordIntPair.getX(i);
+        int cz = ChunkCoordIntPair.getZ(i);
+
+        int pvd = entityplayer.getViewDistance() - 2;
+
+        Square vdsqr = new Square(cx - pvd, cz - pvd, cx + pvd + 1, cz + pvd + 1, 0);
+        Square sto = this.squares.get(entityplayer.getUniqueID().hashCode());
+        this.squares.put(entityplayer.getUniqueID().hashCode(), new Square(cx - pvd, cz - pvd, cx + pvd + 1, cz + pvd + 1, 0));
+
+        if(sto == null) sto = vdsqr;
+        Square oldsqr = new Square(sto.x, sto.y, sto.u, sto.v, sto.ticket);
+
+        it.unimi.dsi.fastutil.ints.IntSortedSet row = new it.unimi.dsi.fastutil.ints.IntRBTreeSet(it.unimi.dsi.fastutil.ints.IntComparators.NATURAL_COMPARATOR);
+        it.unimi.dsi.fastutil.ints.IntSortedSet col = new it.unimi.dsi.fastutil.ints.IntRBTreeSet(it.unimi.dsi.fastutil.ints.IntComparators.NATURAL_COMPARATOR);
+        it.unimi.dsi.fastutil.objects.ObjectList<Square> toproc = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+
+        vdsqr.ticket = 1; oldsqr.ticket = -1;
+        toproc.add(oldsqr); toproc.add(vdsqr);
+
+        if(oldsqr.x < vdsqr.u && oldsqr.u > vdsqr.x && oldsqr.y < vdsqr.v && oldsqr.v > vdsqr.y && !sto.equals(vdsqr)) {
+            Square ovdsqr = new Square(Math.max(oldsqr.x, vdsqr.x), Math.max(oldsqr.y, vdsqr.y), Math.min(oldsqr.u, vdsqr.u), Math.min(oldsqr.v, vdsqr.v), 0);
+            toproc.add(ovdsqr);
+        }
+
+        ObjectIterator<it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry<Square>> sqriterator = this.squares.int2ObjectEntrySet().iterator();
+        while(sqriterator.hasNext()) {
+            it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry<Square> e = sqriterator.next();
+            int uid = e.getIntKey();
+            Square sqr = e.getValue();
+            if(uid == entityplayer.getUniqueID().hashCode()) continue;
+            if(sqr.ticket == -2) {
+                toproc.add(0, sqr);
+                this.squares.remove(uid);
+                continue;
+            }
+            if ((sqr.x < vdsqr.u && sqr.u > vdsqr.x && sqr.y < vdsqr.v && sqr.v > vdsqr.y) ||
+                (sqr.x < oldsqr.u && sqr.u > oldsqr.x && sqr.y < oldsqr.v && sqr.v > oldsqr.y )) {
+                toproc.add(sqr);
+            }
+        }
+
+        it.unimi.dsi.fastutil.objects.ObjectListIterator<Square> it = toproc.iterator();
+        //coordinate compression
+
+        while(it.hasNext()) {
+            Square sqr = it.next();
+            row.add(sqr.y); row.add(sqr.v); col.add(sqr.x); col.add(sqr.u);
+        }
+
+        int[][] grid = new int[row.size()][col.size()];
+        it = toproc.iterator();
+
+        while(it.hasNext()) {
+            Square sqr = it.next();
+            for(int s = row.headSet(sqr.y).size(); s < row.headSet(sqr.v).size(); s++) {
+                for(int t = col.headSet(sqr.x).size(); t < col.headSet(sqr.u).size(); t++) {
+                    grid[s][t] = sqr.ticket;
+                }
+            }
+        }
+
+        int[] rw = row.toIntArray(); int[] cl = col.toIntArray();
+        for(int s = 0; s < row.size() - 1; s++) {
+            for(int t = 0; t < col.size() - 1; t++){
+                if(grid[s][t] == -1 || grid[s][t] == -2) {
+                    for(int x = cl[t]; x < cl[t+1]; x++) {
+                        for(int z = rw[s]; z < rw[s+1]; z++) {
+                            long pair = ChunkCoordIntPair.asLong(x, z);
+                            update.put(pair, (byte) -1);
+                        }
+                    }
+
+                } else if(grid[s][t] == 1) {
+                    for(int x = cl[t]; x < cl[t+1]; x++) {
+                        for(int z = rw[s]; z < rw[s+1]; z++) {
+                            long pair = ChunkCoordIntPair.asLong(x, z);
+                            update.put(pair, (byte) 1);
+                        }
+                    }
+                }
+            }
+
+
+        }
+        //Paper end
+
         this.f.b(i, 0, true);
         this.g.b(i, 0, true);
     }
@@ -241,7 +339,8 @@ public abstract class ChunkMapDistance {
     public void b(SectionPosition sectionposition, EntityPlayer entityplayer) {
         long i = sectionposition.u().pair();
         ObjectSet<EntityPlayer> objectset = (ObjectSet) this.c.get(i);
-
+        Square sqr = this.squares.get(entityplayer.getUniqueID().hashCode());
+        this.squares.put(entityplayer.getUniqueID().hashCode(), new Square(sqr.x, sqr.y, sqr.u, sqr.v, -2));
         objectset.remove(entityplayer);
         if (objectset.isEmpty()) {
             this.c.remove(i);
@@ -372,20 +471,20 @@ public abstract class ChunkMapDistance {
                 byte b0 = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getByteValue();
                 long j = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getLongKey();
 
-                this.a(j, b0, this.c(b0), b0 <= i - 2);
+                this.a(j, b0, this.c(b0), b0 <= i - 2, i); //Paper ticket level pp-view-dist
             }
 
             this.e = i;
         }
 
-        private void a(long i, int j, boolean flag, boolean flag1) {
+        private void a(long i, int j, boolean flag, boolean flag1, int vd) { //Paper ticket level pp-view-dist
             if (flag != flag1) {
                 Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, ChunkMapDistance.b, new ChunkCoordIntPair(i), ChunkMapDistance.this.currentTick);
 
                 if (flag1) {
                     ChunkMapDistance.this.j.a(ChunkTaskQueueSorter.a(() -> { // Craftbukkit - decompile error
                         ChunkMapDistance.this.m.execute(() -> {
-                            if (this.c(this.c(i))) {
+                            if (this.c(i) <= vd) { //Paper ticket level pp-view-dist
                                 ChunkMapDistance.this.addTicket(i, ticket);
                                 ChunkMapDistance.this.l.add(i);
                             } else {
@@ -430,10 +529,33 @@ public abstract class ChunkMapDistance {
                             }
 
                         });
-                        this.a(i, k, this.c(j), this.c(k));
+                    }
+
+                    //Paper start ticket level pp-view-dist
+                    byte f = ChunkMapDistance.this.update.remove(i);
+                    if(f == 1) {
+                        this.a(i, k, false, true, Integer.MAX_VALUE);
+                    } else if (f == -1) {
+                        this.a(i, k, true, false, Integer.MAX_VALUE);
                     }
                 }
 
+                ObjectIterator<it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry> it = ChunkMapDistance.this.update.long2ByteEntrySet().iterator();
+
+                while(it.hasNext()) {
+                    it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry e = it.next();
+                    long i = e.getLongKey();
+                    byte f = e.getByteValue();
+                    if(f == 1) {
+                        this.a(i, this.c(i), false, true, Integer.MAX_VALUE);
+                    } else if (f == -1) {
+                        this.a(i, this.c(i), true, false, Integer.MAX_VALUE);
+                    }
+                }
+
+                ChunkMapDistance.this.update.clear();
+                //Paper end
+
                 this.g.clear();
             }
 
diff --git a/src/main/java/net/minecraft/server/EntityEnderDragon.java b/src/main/java/net/minecraft/server/EntityEnderDragon.java
index c8c74f2b3..63f19c510 100644
--- a/src/main/java/net/minecraft/server/EntityEnderDragon.java
+++ b/src/main/java/net/minecraft/server/EntityEnderDragon.java
@@ -570,9 +570,9 @@ public class EntityEnderDragon extends EntityInsentient implements IMonster {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1028, new BlockPosition(this), 0);
                 // Paper start
-                int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
+                //int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
-                    //final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = player.getTrackViewDistance(); //Paper ticket level pp-view-dist
                     // Paper end
                     double deltaX = this.locX - player.locX;
                     double deltaZ = this.locZ - player.locZ;
diff --git a/src/main/java/net/minecraft/server/EntityHuman.java b/src/main/java/net/minecraft/server/EntityHuman.java
index cd73cde8d..809edf46f 100644
--- a/src/main/java/net/minecraft/server/EntityHuman.java
+++ b/src/main/java/net/minecraft/server/EntityHuman.java
@@ -80,6 +80,29 @@ public abstract class EntityHuman extends EntityLiving {
     public String spawnWorld = "";
     public int oldLevel = -1;
 
+    //Paper start ticket level pp-view-dist
+    private int viewDistance;
+    private int trackViewDistance;
+    public int lastViewDistance;
+    public int lastTrackViewDistance;
+    public int getViewDistance() { return this.viewDistance; }
+    public int getTrackViewDistance() { return this.trackViewDistance; }
+    public void setTrackViewDistance(int i) {
+        this.lastTrackViewDistance = this.trackViewDistance;
+        this.trackViewDistance = MathHelper.clamp(i, 3, 33);
+        if(i != this.lastTrackViewDistance) {
+            if (this.tracker != null) this.tracker.updatePlayer((EntityPlayer) this);
+        }
+        //set pcm vd to highest vd to respect other processes.
+        if (this.trackViewDistance > ((WorldServer) this.world).getChunkProvider().playerChunkMap.viewDistance)
+            ((WorldServer) this.world).getChunkProvider().playerChunkMap.viewDistance = this.trackViewDistance;
+    }
+    public void setViewDistance(int i) {
+        this.lastViewDistance = this.viewDistance;
+        this.viewDistance = MathHelper.clamp(i, 3, this.trackViewDistance);
+    }
+    //Paper end
+
     @Override
     public CraftHumanEntity getBukkitEntity() {
         return (CraftHumanEntity) super.getBukkitEntity();
@@ -98,6 +121,12 @@ public abstract class EntityHuman extends EntityLiving {
 
         this.setPositionRotation((double) blockposition.getX() + 0.5D, (double) (blockposition.getY() + 1), (double) blockposition.getZ() + 0.5D, 0.0F, 0.0F);
         this.aX = 180.0F;
+        //Paper start ticket level pp-view-dist
+        this.setTrackViewDistance(this.world.spigotConfig.viewDistance);
+        this.setViewDistance(this.getTrackViewDistance());
+        this.lastTrackViewDistance = this.getTrackViewDistance();
+        this.lastViewDistance = this.getViewDistance();
+        //Paper end
     }
 
     public boolean a(World world, BlockPosition blockposition, EnumGamemode enumgamemode) {
diff --git a/src/main/java/net/minecraft/server/EntityWither.java b/src/main/java/net/minecraft/server/EntityWither.java
index 8b3052b11..3a00dedfa 100644
--- a/src/main/java/net/minecraft/server/EntityWither.java
+++ b/src/main/java/net/minecraft/server/EntityWither.java
@@ -208,9 +208,9 @@ public class EntityWither extends EntityMonster implements IRangedEntity {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1023, new BlockPosition(this), 0);
                 // Paper start
-                int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
+                //int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
-                    //final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = player.getTrackViewDistance(); //Paper ticket level pp-view-dist
                     // Paper end
                     double deltaX = this.locX - player.locX;
                     double deltaZ = this.locZ - player.locZ;
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 95ee33513..2577226dc 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -935,29 +935,34 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     protected void setViewDistance(int i) {
         int j = MathHelper.clamp(i + 1, 3, 33);
+        //Paper start ticket level pp-view-dist
+        this.chunkDistanceManager.a(j);
+        this.viewDistance = j;
+        ObjectIterator objectiterator = this.updatingChunks.values().iterator();
+
+        if(this.world.players != null && !this.world.players.isEmpty()) {
+            for (EntityPlayer player : this.world.players) {
+                //no need to perform anything more complex, as all logic is handled live at the ticket level
+                player.setTrackViewDistance(j);
+                player.setViewDistance(j);
+            }
+        }
+        //Paper end
+        while (objectiterator.hasNext()) {
+            PlayerChunk playerchunk = (PlayerChunk) objectiterator.next();
+            ChunkCoordIntPair chunkcoordintpair = playerchunk.i();
+            Packet<?>[] apacket = new Packet[2];
 
-        if (j != this.viewDistance) {
-            int k = this.viewDistance;
-
-            this.viewDistance = j;
-            this.chunkDistanceManager.a(this.viewDistance);
-            ObjectIterator objectiterator = this.updatingChunks.values().iterator();
-
-            while (objectiterator.hasNext()) {
-                PlayerChunk playerchunk = (PlayerChunk) objectiterator.next();
-                ChunkCoordIntPair chunkcoordintpair = playerchunk.i();
-                Packet<?>[] apacket = new Packet[2];
-
-                this.a(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    int l = b(chunkcoordintpair, entityplayer, true);
-                    boolean flag = l <= k;
-                    boolean flag1 = l <= this.viewDistance;
+            this.a(chunkcoordintpair, false).forEach((entityplayer) -> {
+                int l = b(chunkcoordintpair, entityplayer, true);
+                boolean flag = l <= entityplayer.lastTrackViewDistance; //Paper ticket level pp-view-dist
+                boolean flag1 = l <= entityplayer.getTrackViewDistance(); //Paper ticket level pp-view-dist
 
-                    this.sendChunk(entityplayer, chunkcoordintpair, apacket, flag, flag1);
-                });
-            }
+                this.sendChunk(entityplayer, chunkcoordintpair, apacket, flag, flag1);
+            });
         }
 
+
     }
 
     protected void sendChunk(EntityPlayer entityplayer, ChunkCoordIntPair chunkcoordintpair, Packet<?>[] apacket, boolean flag, boolean flag1) {
@@ -1201,21 +1206,21 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     boolean isOutsideOfRange(ChunkCoordIntPair chunkcoordintpair, boolean reducedRange) {
-        int chunkRange = world.spigotConfig.mobSpawnRange;
-        chunkRange = (chunkRange > world.spigotConfig.viewDistance) ? (byte) world.spigotConfig.viewDistance : chunkRange;
-        chunkRange = (chunkRange > 8) ? 8 : chunkRange;
-
-        final int finalChunkRange = chunkRange; // Paper for lambda below
         //double blockRange = (reducedRange) ? Math.pow(chunkRange << 4, 2) : 16384.0D; // Paper - use from event
         // Spigot end
         long i = chunkcoordintpair.pair();
 
         return !this.chunkDistanceManager.d(i) ? true : this.playerMap.a(i).noneMatch((entityplayer) -> {
+            //Paper start ticket level pp-view-dist
+            int playerChunkRange = world.spigotConfig.mobSpawnRange;
+            playerChunkRange = (playerChunkRange > entityplayer.getTrackViewDistance()) ? (byte) entityplayer.getTrackViewDistance() : playerChunkRange;
+            playerChunkRange = (playerChunkRange > 8) ? 8 : playerChunkRange;
+            //Paper end
             // Paper start -
             com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent event;
             double blockRange = 16384.0D;
             if (reducedRange) {
-                event = new com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent(entityplayer.getBukkitEntity(), (byte) finalChunkRange);
+                event = new com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent(entityplayer.getBukkitEntity(), (byte) playerChunkRange); //Paper ticket level pp-view-dist
                 event.callEvent();
                 blockRange = (double) ((event.getSpawnRadius() << 4) * (event.getSpawnRadius() << 4));
                 if (event.isCancelled()) return true;
@@ -1251,8 +1256,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             }
         }
 
-        for (int k = i - this.viewDistance; k <= i + this.viewDistance; ++k) {
-            for (int l = j - this.viewDistance; l <= j + this.viewDistance; ++l) {
+        //Paper start ticket level pp-view-dist
+        int playerViewDistance = entityplayer.getTrackViewDistance();
+        for (int k = i - playerViewDistance; k <= i + playerViewDistance; ++k) {
+            for (int l = j - playerViewDistance; l <= j + playerViewDistance; ++l) {
+                //Paper end
                 ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k, l);
 
                 this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], !flag, flag);
@@ -1320,17 +1328,19 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         int k1;
         int l1;
 
-        if (Math.abs(i1 - i) <= this.viewDistance * 2 && Math.abs(j1 - j) <= this.viewDistance * 2) {
-            k1 = Math.min(i, i1) - this.viewDistance;
-            l1 = Math.min(j, j1) - this.viewDistance;
-            int i2 = Math.max(i, i1) + this.viewDistance;
-            int j2 = Math.max(j, j1) + this.viewDistance;
+        //Paper start ticket level pp-view-dist
+        int playerViewDistance = entityplayer.getTrackViewDistance();
+        if (Math.abs(i1 - i) <= playerViewDistance * 2 && Math.abs(j1 - j) <= playerViewDistance * 2) {
+            k1 = Math.min(i, i1) - playerViewDistance;
+            l1 = Math.min(j, j1) - playerViewDistance;
+            int i2 = Math.max(i, i1) + playerViewDistance;
+            int j2 = Math.max(j, j1) + playerViewDistance;
 
             for (int k2 = k1; k2 <= i2; ++k2) {
                 for (int l2 = l1; l2 <= j2; ++l2) {
                     ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k2, l2);
-                    boolean flag3 = a(chunkcoordintpair, i1, j1) <= this.viewDistance;
-                    boolean flag4 = a(chunkcoordintpair, i, j) <= this.viewDistance;
+                    boolean flag3 = a(chunkcoordintpair, i1, j1) <= playerViewDistance;
+                    boolean flag4 = a(chunkcoordintpair, i, j) <= playerViewDistance;
 
                     this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], flag3, flag4);
                 }
@@ -1340,8 +1350,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             boolean flag5;
             boolean flag6;
 
-            for (k1 = i1 - this.viewDistance; k1 <= i1 + this.viewDistance; ++k1) {
-                for (l1 = j1 - this.viewDistance; l1 <= j1 + this.viewDistance; ++l1) {
+            for (k1 = i1 - playerViewDistance; k1 <= i1 + playerViewDistance; ++k1) {
+                for (l1 = j1 - playerViewDistance; l1 <= j1 + playerViewDistance; ++l1) {
                     chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
                     flag5 = true;
                     flag6 = false;
@@ -1349,8 +1359,9 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 }
             }
 
-            for (k1 = i - this.viewDistance; k1 <= i + this.viewDistance; ++k1) {
-                for (l1 = j - this.viewDistance; l1 <= j + this.viewDistance; ++l1) {
+            for (k1 = i - playerViewDistance; k1 <= i + playerViewDistance; ++k1) {
+                for (l1 = j - playerViewDistance; l1 <= j + playerViewDistance; ++l1) {
+                    //Paper end
                     chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
                     flag5 = false;
                     flag6 = true;
@@ -1366,7 +1377,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         return this.playerMap.a(chunkcoordintpair.pair()).filter((entityplayer) -> {
             int i = b(chunkcoordintpair, entityplayer, true);
 
-            return i > this.viewDistance ? false : !flag || i == this.viewDistance;
+            return i > entityplayer.getTrackViewDistance() ? false : !flag || i == entityplayer.getTrackViewDistance(); //Paper ticket level pp-view-dist
         });
     }
 
@@ -1616,7 +1627,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
             if (entityplayer != this.tracker) {
                 Vec3D vec3d = (new Vec3D(entityplayer.locX, entityplayer.locY, entityplayer.locZ)).d(this.tracker.getPositionVector()); // MC-155077, SPIGOT-5113
-                int i = Math.min(this.trackingDistance, (PlayerChunkMap.this.viewDistance - 1) * 16);
+                int i = Math.min(this.trackingDistance, (entityplayer.getTrackViewDistance() - 1) * 16); //Paper ticket level pp-view-dist
                 boolean flag = vec3d.x >= (double) (-i) && vec3d.x <= (double) i && vec3d.z >= (double) (-i) && vec3d.z <= (double) i && this.tracker.a(entityplayer);
 
                 if (flag) {
@@ -1627,7 +1638,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                         PlayerChunk playerchunk = PlayerChunkMap.this.getVisibleChunk(chunkcoordintpair.pair());
 
                         if (playerchunk != null && playerchunk.getChunk() != null) {
-                            flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= PlayerChunkMap.this.viewDistance;
+                            flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= entityplayer.getTrackViewDistance(); //Paper ticket level pp-view-dist
                         }
                     }
 
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 3cb443c4f..476da855d 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -155,7 +155,7 @@ public abstract class PlayerList {
 
         // CraftBukkit - getType()
         // Spigot - view distance
-        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), worldserver.spigotConfig.viewDistance, worldserver.getGameRules().getBoolean(GameRules.REDUCED_DEBUG_INFO)));
+        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), entityplayer.getTrackViewDistance(), worldserver.getGameRules().getBoolean(GameRules.REDUCED_DEBUG_INFO))); //Paper ticket level pp-view-dist
         entityplayer.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.sendPacket(new PacketPlayOutCustomPayload(PacketPlayOutCustomPayload.a, (new PacketDataSerializer(Unpooled.buffer())).a(this.getServer().getServerModName())));
         playerconnection.sendPacket(new PacketPlayOutServerDifficulty(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
@@ -699,7 +699,7 @@ public abstract class PlayerList {
         WorldData worlddata = worldserver.getWorldData();
 
         entityplayer1.playerConnection.sendPacket(new PacketPlayOutRespawn(worldserver.worldProvider.getDimensionManager().getType(), worldserver.getWorldData().getType(), entityplayer1.playerInteractManager.getGameMode()));
-        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(worldserver.spigotConfig.viewDistance)); // Spigot
+        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(entityplayer1.getTrackViewDistance())); // Spigot //Paper ticket level pp-view-dist
         entityplayer1.spawnIn(worldserver);
         entityplayer1.dead = false;
         entityplayer1.playerConnection.teleport(new Location(worldserver.getWorld(), entityplayer1.locX, entityplayer1.locY, entityplayer1.locZ, entityplayer1.yaw, entityplayer1.pitch));
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index e920545df..38a48121f 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1986,12 +1986,20 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public int getViewDistance() {
-        throw new NotImplementedException("Per-Player View Distance APIs need further understanding to properly implement"); // TODO
+        return getHandle().getViewDistance(); //Paper ticket level pp-view-dist
     }
 
     @Override
     public void setViewDistance(int viewDistance) {
-        throw new NotImplementedException("Per-Player View Distance APIs need further understanding to properly implement"); // TODO
+        getHandle().setViewDistance(viewDistance); //Paper ticket level pp-view-dist
+    }
+
+    public int getTrackViewDistance() {
+        return getHandle().getTrackViewDistance(); //Paper ticket level pp-view-dist
+    }
+
+    public void setTrackViewDistance(int trackViewDistance) {
+        getHandle().setTrackViewDistance(trackViewDistance); //Paper ticket level pp-view-dist
     }
     //Paper end
 
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index 92601c581..84fc6bfc4 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -122,13 +122,14 @@ public class ActivationRange
         int maxRange = Math.max( monsterActivationRange, animalActivationRange );
         maxRange = Math.max( maxRange, raiderActivationRange );
         maxRange = Math.max( maxRange, miscActivationRange );
-        maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange );
+        //maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange ); //Paper ticket level pp-view-dist
 
         for ( EntityHuman player : world.getPlayers() )
         {
 
+            int playerMaxRange = maxRange = Math.min( ( player.getTrackViewDistance() << 4 ) - 8, maxRange ); //Paper ticket level pp-view-dist
             player.activatedTick = MinecraftServer.currentTick;
-            maxBB = player.getBoundingBox().grow( maxRange, 256, maxRange );
+            maxBB = player.getBoundingBox().grow( playerMaxRange, 256, playerMaxRange ); //Paper ticket level pp-view-dist
             ActivationType.MISC.boundingBox = player.getBoundingBox().grow( miscActivationRange, 256, miscActivationRange );
             ActivationType.RAIDER.boundingBox = player.getBoundingBox().grow( raiderActivationRange, 256, raiderActivationRange );
             ActivationType.ANIMAL.boundingBox = player.getBoundingBox().grow( animalActivationRange, 256, animalActivationRange );
-- 
2.20.1.windows.1

