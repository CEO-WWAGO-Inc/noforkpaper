From 3158d498a83ae20858403c5108d6ae2f19d2647d Mon Sep 17 00:00:00 2001
From: Max Lee <mail@moep.tv>
Date: Thu, 13 Oct 2016 01:01:06 +0200
Subject: [PATCH] InventoryMoveItemEvent improvements

The handling of the InventoryMoveItemEvent in CraftBukkit is extremely
resource hungry when dealing with a lot of Hoppers. Especially the fact
that it even fires when the Vanilla behaviour would be to not move items
at all because the targetted inventory is full results in a lot of useless
event calls.

This adds three world config options whith which the behaviour can be
tweaked to your liking. By default it will call events that wouldn't
result in a move as cancelled so that plugins can still listen for it but
pure observing once can ignore it easily.

There are also options to disable the event entirely or just don't fire it
when no move will occur.

diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index 51b34d9..0e3ad6b 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -365,6 +365,15 @@ public class PaperWorldConfig {
         isHopperPushBased = getBoolean("hopper.push-based", false);
     }
 
+    public boolean callMoveItemEvent = true;
+    public boolean callMoveItemEventWithoutMove = true;
+    public boolean callMoveEventCancelled = true;
+    private void moveItemEventImprovements() {
+        callMoveItemEvent = getBoolean("move-item-event.enabled", true);
+        callMoveItemEventWithoutMove = getBoolean("move-item-event.call-without-move", true);
+        callMoveEventCancelled = getBoolean("move-item-event.call-cancelled-without-move", true);
+    }
+
     public long delayChunkUnloadsBy;
     private void delayChunkUnloadsBy() {
         delayChunkUnloadsBy = PaperConfig.getSeconds(getString("delay-chunk-unloads-by", "10s"));
diff --git a/src/main/java/net/minecraft/server/BlockDropper.java b/src/main/java/net/minecraft/server/BlockDropper.java
index c6f318d..99124f6 100644
--- a/src/main/java/net/minecraft/server/BlockDropper.java
+++ b/src/main/java/net/minecraft/server/BlockDropper.java
@@ -56,7 +56,18 @@ public class BlockDropper extends BlockDispenser {
                         }
 
                         InventoryMoveItemEvent event = new InventoryMoveItemEvent(tileentitydispenser.getOwner().getInventory(), oitemstack.clone(), destinationInventory, true);
-                        world.getServer().getPluginManager().callEvent(event);
+                        // Paper start - InventoryMoveItemEvent improvements
+                        if (world.paperConfig.callMoveItemEvent) {
+                            boolean acceptsItem = TileEntityHopper.willAcceptItem(iinventory, CraftItemStack.asNMSCopy(oitemstack), enumdirection.opposite());
+                            if (world.paperConfig.callMoveItemEventWithoutMove || acceptsItem) {
+                                if (world.paperConfig.callMoveEventCancelled && !acceptsItem) {
+                                    event.setCancelled(true);
+                                }
+                                world.getServer().getPluginManager().callEvent(event);
+                            }
+                        }
+                        //world.getServer().getPluginManager().callEvent(event);
+                        // Paper end
                         if (event.isCancelled()) {
                             return;
                         }
diff --git a/src/main/java/net/minecraft/server/TileEntityHopper.java b/src/main/java/net/minecraft/server/TileEntityHopper.java
index 1f5de89..09a5547 100644
--- a/src/main/java/net/minecraft/server/TileEntityHopper.java
+++ b/src/main/java/net/minecraft/server/TileEntityHopper.java
@@ -263,7 +263,18 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
                         }
 
                         InventoryMoveItemEvent event = new InventoryMoveItemEvent(this.getOwner().getInventory(), oitemstack.clone(), destinationInventory, true);
-                        this.getWorld().getServer().getPluginManager().callEvent(event);
+                        // Paper start - InventoryMoveItemEvent improvements
+                        if (world.paperConfig.callMoveItemEvent) {
+                            boolean acceptsItem = willAcceptItem(iinventory, CraftItemStack.asNMSCopy(oitemstack), enumdirection);
+                            if (world.paperConfig.callMoveItemEventWithoutMove || acceptsItem) {
+                                if (world.paperConfig.callMoveEventCancelled && !acceptsItem) {
+                                    event.setCancelled(true);
+                                }
+                                this.getWorld().getServer().getPluginManager().callEvent(event);
+                            }
+                        }
+                        // this.getWorld().getServer().getPluginManager().callEvent(event);
+                        // Paper end
                         if (event.isCancelled()) {
                             this.setItem(i, itemstack);
                             this.setCooldown(world.spigotConfig.hopperTransfer); // Spigot
@@ -420,8 +431,18 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
             }
 
             InventoryMoveItemEvent event = new InventoryMoveItemEvent(sourceInventory, oitemstack.clone(), ihopper.getOwner().getInventory(), false);
-
-            ihopper.getWorld().getServer().getPluginManager().callEvent(event);
+            // Paper start - InventoryMoveItemEvent improvements
+            if (ihopper.getWorld().paperConfig.callMoveItemEvent) {
+                boolean acceptsItem = willAcceptItem(iinventory, CraftItemStack.asNMSCopy(oitemstack), enumdirection);
+                if (ihopper.getWorld().paperConfig.callMoveItemEventWithoutMove || acceptsItem) {
+                    if (ihopper.getWorld().paperConfig.callMoveEventCancelled && !acceptsItem) {
+                        event.setCancelled(true);
+                    }
+                    ihopper.getWorld().getServer().getPluginManager().callEvent(event);
+                }
+            }
+            //ihopper.getWorld().getServer().getPluginManager().callEvent(event);
+            // Paper end
             if (event.isCancelled()) {
                 iinventory.setItem(i, itemstack1);
 
@@ -480,18 +501,47 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
     }
 
     public static ItemStack addItem(IInventory iinventory, ItemStack itemstack, @Nullable EnumDirection enumdirection) {
+        // Paper start - InventoryMoveItemEvent improvements
+        return checkOrAddToInventory(iinventory, itemstack, enumdirection, true);
+    }
+
+    static boolean willAcceptItem(IInventory iinventory, ItemStack itemstack, @Nullable EnumDirection enumdirection) {
+        return checkOrAddToInventory(iinventory, itemstack, enumdirection, false) == null;
+    }
+
+    /**
+     * Check whether or not an inventory can accept a new item (and add it)
+     * @param addItem Set whether or not to add the checked item to that inventory
+     * @return The overflowing itemstack; null if all where added or could be added
+     */
+    private static ItemStack checkOrAddToInventory(IInventory iinventory, ItemStack itemstack, @Nullable EnumDirection enumdirection, boolean addItem) {
+        // Paper end
         if (iinventory instanceof IWorldInventory && enumdirection != null) {
             IWorldInventory iworldinventory = (IWorldInventory) iinventory;
             int[] aint = iworldinventory.getSlotsForFace(enumdirection);
 
             for (int i = 0; i < aint.length && itemstack != null && itemstack.count > 0; ++i) {
-                itemstack = c(iinventory, itemstack, aint[i], enumdirection);
+                //itemstack = c(iinventory, itemstack, aint[i], enumdirection);
+                // Paper start - InventoryMoveItemEvent improvements
+                if (addItem) {
+                    itemstack = c(iinventory, itemstack, aint[i], enumdirection);
+                } else if (enoughRoomInSlot(iinventory, itemstack, aint[i], enumdirection)) {
+                    return null;
+                }
+                // Paper end
             }
         } else {
             int j = iinventory.getSize();
 
             for (int k = 0; k < j && itemstack != null && itemstack.count > 0; ++k) {
-                itemstack = c(iinventory, itemstack, k, enumdirection);
+                //itemstack = c(iinventory, itemstack, k, enumdirection);
+                // Paper start - InventoryMoveItemEvent improvements
+                if (addItem) {
+                    itemstack = c(iinventory, itemstack, k, enumdirection);
+                } else if (enoughRoomInSlot(iinventory, itemstack, k, enumdirection)) {
+                    return null;
+                }
+                // Paper end
             }
         }
 
@@ -511,12 +561,28 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
     }
 
     private static ItemStack c(IInventory iinventory, ItemStack itemstack, int i, EnumDirection enumdirection) {
+        // Paper start - InventoryMoveItemEvent improvements
+        return checkOrAddToSlot(iinventory, itemstack, i, enumdirection, true);
+    }
+
+    private static boolean enoughRoomInSlot(IInventory iinventory, ItemStack itemstack, int i, EnumDirection enumdirection) {
+        return checkOrAddToSlot(iinventory, itemstack, i, enumdirection, false) == null;
+    }
+
+    /**
+     * Check whether or not a slot can accept a new item (and add it)
+     * @param addItem Set whether or not to add the checked item to that slot
+     * @return The overflowing itemstack; null if all where added or could be added
+     */
+    private static ItemStack checkOrAddToSlot(IInventory iinventory, ItemStack itemstack, int i, EnumDirection enumdirection, boolean addItem) {
+        // Paper end
         ItemStack itemstack1 = iinventory.getItem(i);
 
         if (a(iinventory, itemstack, i, enumdirection)) {
             boolean flag = false;
 
             if (itemstack1 == null) {
+                if (!addItem) return null; // Paper - InventoryMoveItemEvent improvements
                 IGNORE_TILE_UPDATES = true; // Paper
                 iinventory.setItem(i, itemstack);
                 IGNORE_TILE_UPDATES = false; // Paper
@@ -525,12 +591,12 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
             } else if (a(itemstack1, itemstack)) {
                 int j = itemstack.getMaxStackSize() - itemstack1.count;
                 int k = Math.min(itemstack.count, j);
-
+                if (!addItem) return (k > 0) ? null : itemstack; // Paper - InventoryMoveItemEvent improvements
                 itemstack.count -= k;
                 itemstack1.count += k;
                 flag = k > 0;
             }
-
+            if (!addItem) return itemstack; // Paper - InventoryMoveItemEvent improvements
             if (flag) {
                 if (iinventory instanceof TileEntityHopper) {
                     TileEntityHopper tileentityhopper = (TileEntityHopper) iinventory;
-- 
1.9.4.msysgit.2

