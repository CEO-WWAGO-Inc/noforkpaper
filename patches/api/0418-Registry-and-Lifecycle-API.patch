From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Denery <dorofeevij@gmail.com>
Date: Sat, 14 Jan 2023 17:55:32 +0300
Subject: [PATCH] Registry and Lifecycle API


diff --git a/src/main/java/io/papermc/paper/lifecycle/LifecyclePoint.java b/src/main/java/io/papermc/paper/lifecycle/LifecyclePoint.java
new file mode 100644
index 0000000000000000000000000000000000000000..c26bb2a2e647607986124e2403073bc9bf143b12
--- /dev/null
+++ b/src/main/java/io/papermc/paper/lifecycle/LifecyclePoint.java
@@ -0,0 +1,39 @@
+package io.papermc.paper.lifecycle;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NonBlocking;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.function.Consumer;
+
+/**
+ * Represents a point / stage of a server initialization which an API user can schedule to.
+ *
+ * @see LifecyclePointScheduler
+ * @param <C> A provided context at given initialization point.
+ */
+public interface LifecyclePoint<C> {
+
+    /**
+     * Internal method, schedules given {@link Consumer} with a given {@link PluginMeta} to this {@link LifecyclePoint}.
+     * @param consumer A given {@link Consumer}.
+     * @param pluginMeta A given {@link PluginMeta}.
+     */
+    @NonBlocking
+    void schedule(@NotNull Consumer<C> consumer, @NotNull PluginMeta pluginMeta);
+
+    @ApiStatus.Internal
+    interface LifecyclePointFactory {
+        @NotNull
+        <C> LifecyclePoint<C> createSingleEnter(@NotNull String name);
+
+        @NotNull
+        <C> LifecyclePoint<C> createMultiEnter(@NotNull String name);
+    }
+
+    @ApiStatus.Internal
+    final class API {
+        static LifecyclePointFactory lifecyclePointFactory;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/lifecycle/LifecyclePointScheduler.java b/src/main/java/io/papermc/paper/lifecycle/LifecyclePointScheduler.java
new file mode 100644
index 0000000000000000000000000000000000000000..377e7b98214db361da8de0154e4d56100654ffba
--- /dev/null
+++ b/src/main/java/io/papermc/paper/lifecycle/LifecyclePointScheduler.java
@@ -0,0 +1,74 @@
+package io.papermc.paper.lifecycle;
+
+import io.papermc.paper.plugin.configuration.PluginMeta;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NonBlocking;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.function.Consumer;
+
+/**
+ * A class given in {@link io.papermc.paper.plugin.bootstrap.PluginProviderContext#getLifecyclePointScheduler()}.
+ * You can schedule various behaviors on {@link LifecyclePoint}s.
+ * <p>
+ * But to get it work you need to build it with a given {@link PluginMeta} using {@link #build(PluginMeta)}.
+ * <p>
+ * This class as well as {@link LifecyclePoint} is completely thread-safe,
+ * feel free to schedule actions on {@link LifecyclePoint} from different threads.
+ */
+public interface LifecyclePointScheduler {
+    /**
+     * Schedules given action with a context to a given {@link LifecyclePoint}.
+     * @param lifecyclePoint A {@link LifecyclePoint} you want to schedule an action to.
+     * @param consumer An action.
+     * @return An instance with a given action scheduled.
+     * @param <C> A type of context.
+     */
+    @NotNull
+    @NonBlocking
+    <C> LifecyclePointScheduler schedule(@NotNull LifecyclePoint<C> lifecyclePoint, @NotNull Consumer<C> consumer);
+
+    /**
+     * Schedules given community based implementation for handling contexts.
+     * @param holder A community implementation for scheduling
+     * @return An instance with given action scheduled.
+     * @param <C> A type of context.
+     */
+    @NotNull
+    @NonBlocking
+    <C> LifecyclePointScheduler schedule(@NotNull LifecyclePointHolder<C> holder);
+
+    /**
+     * Builds this {@link LifecyclePointScheduler} and makes it immutable. You can't schedule more actions after executing it.
+     * @param pluginMeta A given {@link PluginMeta}
+     */
+    @NonBlocking
+    void build(@NotNull PluginMeta pluginMeta);
+
+    /**
+     * Checks whether this {@link LifecyclePointScheduler} is built or not.
+     * @return true when built.
+     */
+    @NonBlocking
+    boolean isBuilt();
+
+    /**
+     * An interface which you can implement to make your own implementation for handling contexts of {@link LifecyclePoint}s.
+     * @param <C> A type of context.
+     */
+    @ApiStatus.OverrideOnly
+    interface LifecyclePointHolder<C> {
+        /**
+         * Gives {@link LifecyclePoint} which this holder schedules to.
+         * @return A {@link LifecyclePoint}.
+         */
+        @NotNull
+        LifecyclePoint<C> lifecyclePoint();
+
+        /**
+         * Called when the time of a given {@link LifecyclePoint} initialization has come.
+         * @param context A type of context.
+         */
+        void run(@NotNull C context);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/lifecycle/ServerLifecyclePoints.java b/src/main/java/io/papermc/paper/lifecycle/ServerLifecyclePoints.java
new file mode 100644
index 0000000000000000000000000000000000000000..e8bf6dc968a2efdeee284c451b0a0bb1523544d0
--- /dev/null
+++ b/src/main/java/io/papermc/paper/lifecycle/ServerLifecyclePoints.java
@@ -0,0 +1,51 @@
+package io.papermc.paper.lifecycle;
+
+import io.papermc.paper.registry.access.RegistryAccess;
+import io.papermc.paper.registry.access.WritableRegistryAccess;
+import io.papermc.paper.registry.key.RegistryKey;
+import io.papermc.paper.registry.key.ResourceKey;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Contains all {@link LifecyclePoint} instances which a user can scheduler their behaviour to using {@link LifecyclePointScheduler}.
+ * <p>
+ * {@link LifecyclePoint} instances there are either "single enter" or "multi enter".
+ * Multi enter ones are those {@link LifecyclePoint}s which can fire multiple times during runtime / in different places, i.e. both server initialization and reloading.
+ */
+public final class ServerLifecyclePoints {
+    private ServerLifecyclePoints() {}
+
+    /**
+     * Fires when registries which have {@link io.papermc.paper.registry.key.RegistryKey.RegistryLayerType.STATIC} layer in their {@link RegistryKey} can be modified.
+     * Note that during this stage you can't access their content, i.e. use methods such as {@link io.papermc.paper.registry.ExtendedRegistry#get(ResourceKey)}.
+     */
+    public static final LifecyclePoint<StaticRegistryInitializationContext> STATIC_REGISTRIES_INITIALIZED = LifecyclePoint.API.lifecyclePointFactory.createSingleEnter("STATIC_REGISTRIES_INITIALIZED");
+
+    /**
+     * Fires when registries which have {@link io.papermc.paper.registry.key.RegistryKey.RegistryLayerType.STATIC} layer in their {@link RegistryKey} can be safely accessed, but not modified.
+     */
+    public static final LifecyclePoint<StaticRegistryFrozenContext> STATIC_REGISTRIES_FROZEN = LifecyclePoint.API.lifecyclePointFactory.createSingleEnter("STATIC_REGISTRIES_FROZEN");
+
+    /**
+     * Fires when registries which have {@link io.papermc.paper.registry.key.RegistryKey.RegistryLayerType.WORLDGEN} layer in their {@link RegistryKey} can be modified.
+     * Note that during this stage you can't access their content, i.e. use methods such as {@link io.papermc.paper.registry.ExtendedRegistry#get(ResourceKey)}.
+     */
+    public static final LifecyclePoint<WorldgenRegistryInitializedContext> WORLDGEN_REGISTRIES_INITIALIZED = LifecyclePoint.API.lifecyclePointFactory.createSingleEnter("WORLDGEN_REGISTRIES_INITIALIZED");
+
+    /**
+     * Fires when registries which have {@link io.papermc.paper.registry.key.RegistryKey.RegistryLayerType.WORLDGEN} layer in their {@link RegistryKey} can be safely accessed, but not modified.
+     */
+    public static final LifecyclePoint<WorldgenRegistryFrozenContext> WORLDGEN_REGISTRIES_FROZEN = LifecyclePoint.API.lifecyclePointFactory.createSingleEnter("WORLDGEN_REGISTRIES_FROZEN");
+
+    public record StaticRegistryInitializationContext(@NotNull WritableRegistryAccess<RegistryKey.RegistryLayerType.STATIC> writableRegistryAccess) {
+    }
+    
+    public record StaticRegistryFrozenContext(@NotNull RegistryAccess registryAccess) {
+    }
+
+    public record WorldgenRegistryInitializedContext(@NotNull WritableRegistryAccess<RegistryKey.RegistryLayerType.WORLDGEN> writableRegistryAccess) {
+    }
+
+    public record WorldgenRegistryFrozenContext(@NotNull RegistryAccess registryAccess) {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginProviderContext.java b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginProviderContext.java
index a4467fe1ba0dc348eab681900dbcac1770963591..ef90a6da9cbb913d2e4a5d62faa50f4bd1c17c48 100644
--- a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginProviderContext.java
+++ b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginProviderContext.java
@@ -1,5 +1,6 @@
 package io.papermc.paper.plugin.bootstrap;
 
+import io.papermc.paper.lifecycle.LifecyclePointScheduler;
 import io.papermc.paper.plugin.configuration.PluginMeta;
 import org.jetbrains.annotations.ApiStatus;
 import org.jetbrains.annotations.NotNull;
@@ -50,4 +51,12 @@ public interface PluginProviderContext {
     default org.slf4j.Logger getSLF4JLogger() {
         return org.slf4j.LoggerFactory.getLogger(this.getLogger().getName());
     }
+
+    /**
+     * Provides the {@link LifecyclePointScheduler} associated with this plugin.
+     *
+     * @return LifecyclePointScheduler
+     */
+    @NotNull
+    LifecyclePointScheduler getLifecyclePointScheduler();
 }
diff --git a/src/main/java/io/papermc/paper/registry/ExtendedRegistry.java b/src/main/java/io/papermc/paper/registry/ExtendedRegistry.java
new file mode 100644
index 0000000000000000000000000000000000000000..cebe4a149e991f6bddadd326ff33bcd4bd26a9c7
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/ExtendedRegistry.java
@@ -0,0 +1,279 @@
+package io.papermc.paper.registry;
+
+import io.papermc.paper.plugin.bootstrap.PluginProviderContext;
+import io.papermc.paper.registry.key.RegistryKey;
+import io.papermc.paper.registry.key.ResourceKey;
+import io.papermc.paper.registry.key.ResourceKeyed;
+import net.kyori.adventure.key.Key;
+import org.bukkit.Keyed;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
+
+/**
+ *  A (de-)serialization / verification mechanism used in Minecraft to add new game content and identify it.
+ *  Minecraft has content which is synchronized between a server and client, like {@link org.bukkit.block.Biome}.
+ *  There is also a content which exists only server-side and which doesn't need synchronization.
+ *  <p>
+ *  This interface provides a more detailed abstraction than {@link org.bukkit.Registry} for this internal mechanism.
+ *  It doesn't require the generic to be {@link Keyed}.
+ *
+ * @param <T> A type this {@link ExtendedRegistry} operates with.
+ *
+ * @see WritableRegistry
+ * @see io.papermc.paper.registry.enums.EnumWritableRegistry
+ * @see io.papermc.paper.registry.access.RegistryAccess
+ */
+public interface ExtendedRegistry<T> extends ResourceKeyed<ExtendedRegistry<T>>, Iterable<T> {
+    Key ROOT_REGISTRY_KEY = Key.key("root");
+
+    /**
+     * Allows to register in the {@link io.papermc.paper.plugin.bootstrap.PluginBootstrap#bootstrap(PluginProviderContext)} method to any {@link Enum} represented {@link ExtendedRegistry} without the usage of {@link io.papermc.paper.lifecycle.ServerLifecyclePoints}.
+     * @param registryKey A {@link io.papermc.paper.registry.key.RegistryKey.EnumMutableRegistryKey} the {@link io.papermc.paper.registry.enums.EnumWritableRegistry} is associated with.
+     * @param value A value you want to register.
+     * @param <T> A type the {@link io.papermc.paper.registry.enums.EnumWritableRegistry} operates with.
+     */
+    static <T extends Enum<T> & Keyed> void register(@NotNull RegistryKey.EnumMutableRegistryKey<?, T> registryKey, @NotNull T value) {
+        API.simpleRegistry.register(registryKey, value);
+    }
+
+    /**
+     * Allows to register in the {@link io.papermc.paper.plugin.bootstrap.PluginBootstrap#bootstrap(PluginProviderContext)} method to any mutable {@link ExtendedRegistry} without the usage of {@link io.papermc.paper.lifecycle.ServerLifecyclePoints}.
+     * @param registryKey A {@link io.papermc.paper.registry.key.RegistryKey.MutableRegistryKey} the {@link WritableRegistry} is associated with.
+     * @param resourceKey A {@link ResourceKey} you want your value to be associated with.
+     * @param value A value you want to register.
+     * @param <T> A type the {@link WritableRegistry} operates with.
+     */
+    static <T> void register(@NotNull RegistryKey.MutableRegistryKey<?, T> registryKey, @NotNull ResourceKey<T> resourceKey, @NotNull T value) {
+        API.simpleRegistry.register(registryKey, resourceKey, value);
+    }
+
+    /**
+     * Allows to register in the {@link io.papermc.paper.plugin.bootstrap.PluginBootstrap#bootstrap(PluginProviderContext)} method to any mutable {@link ExtendedRegistry} without the usage of {@link io.papermc.paper.lifecycle.ServerLifecyclePoints}.
+     * @param registryKey A {@link io.papermc.paper.registry.key.RegistryKey.MutableRegistryKey} the {@link WritableRegistry} is associated with.
+     * @param key A {@link Key} you want your value to be associated with.
+     * @param value A value you want to register.
+     * @param <T> A type the {@link WritableRegistry} operates with.
+     */
+    static <T> void register(@NotNull RegistryKey.MutableRegistryKey<?, T> registryKey, @NotNull Key key, @NotNull T value) {
+        API.simpleRegistry.register(registryKey, key, value);
+    }
+
+    /**
+     * Obtains {@link Reference} if possible.
+     * @param resourceKey A given {@link ResourceKey}.
+     * @return {@link Optional#empty()} if there is no value associated with the given {@link ResourceKey}
+     */
+    @NotNull
+    Optional<Reference<T>> getReference(@Nullable ResourceKey<T> resourceKey);
+
+    /**
+     * Obtains {@link Reference} if possible using a numerical key.
+     * @param numericalKey A given numerical key
+     * @return {@link Optional#empty()} if there is no value associated with the given numerical key.
+     */
+    @NotNull
+    Optional<Reference<T>> getReference(int numericalKey);
+
+    /**
+     * Same as {@link #getReference(ResourceKey)} But throws an exception if there is no value associated with the given {@link ResourceKey}.
+     * @param resourceKey A given {@link ResourceKey}.
+     * @return A {@link Reference} if it's present.
+     */
+    @NotNull
+    default Reference<T> getReferenceOrThrow(@Nullable ResourceKey<T> resourceKey) {
+        return this.getReference(resourceKey)
+            .orElseThrow(() -> new IllegalStateException("Missing key in " + this.key() + " : " + resourceKey));
+    }
+
+    /**
+     * Gets a value as a {@link Reference} of this {@link ExtendedRegistry}.
+     * @param value A value.
+     * @return A {@link Reference}.
+     */
+    @Nullable
+    @Contract("null -> null")
+    Reference<T> asReference(@Nullable T value);
+
+    /**
+     * Gets value associated with the given {@link ResourceKey}.
+     * @param resourceKey A given {@link ResourceKey}.
+     * @return {@link Optional#empty()} if there is no value associated with the given {@link ResourceKey}.
+     */
+    @NotNull
+    default Optional<T> getOptional(@Nullable ResourceKey<T> resourceKey) {
+        return Optional.ofNullable(this.get(resourceKey));
+    }
+
+    /**
+     * Gets value associated with the given {@link Key}.
+     * @param key A given {@link Key}.
+     * @return {@link Optional#empty()} if there is no value associated with the given {@link Key}.
+     */
+    @NotNull
+    default Optional<T> getOptional(@Nullable Key key) {
+        return Optional.ofNullable(this.get(key));
+    }
+
+    /**
+     * Gets value associated with the given {@link ResourceKey} or throws an exception if it's not present.
+     * @param resourceKey A given {@link ResourceKey}.
+     * @return A value.
+     */
+    @NotNull
+    default T getOrThrow(@Nullable ResourceKey<T> resourceKey) throws IllegalStateException {
+        final T value = this.get(resourceKey);
+        if (value == null) {
+            throw new IllegalStateException("Missing key in " + this.key() + " : " + resourceKey);
+        } else {
+            return value;
+        }
+    }
+
+    /**
+     * Gets value associated with the given {@link ResourceKey} or null if it's not present.
+     * @param resourceKey A given {@link ResourceKey}.
+     * @return A value.
+     */
+    @Nullable
+    @Contract("null -> null")
+    T get(@Nullable ResourceKey<T> resourceKey);
+
+    /**
+     * Gets value associated with the given {@link Key} or null if it's not present.
+     * @param key A given {@link Key}.
+     * @return A value.
+     */
+    @Nullable
+    @Contract("null -> null")
+    T get(@Nullable Key key);
+
+    /**
+     * Gets a {@link Key} a given value is associated with or null if there is no such a value in this {@link ExtendedRegistry}.
+     * @param value A given value.
+     * @return A {@link Key} associated with the given value.
+     */
+    @Nullable
+    @Contract("null -> null")
+    Key key(@Nullable T value);
+
+    /**
+     * Gets a {@link ResourceKey} associated with a given value.
+     * @param value A given value.
+     * @return {@link Optional#empty()} if there is no {@link ResourceKey} associated with the given value.
+     */
+    @NotNull
+    Optional<ResourceKey<T>> resourceKey(@Nullable T value);
+
+    /**
+     * Gets a numerical key associated with a given value.
+     * @param value A given value.
+     * @return A numerical key associated with a given value.
+     */
+    int numericalKey(@NotNull T value);
+
+    /**
+     * Checks whether this {@link ExtendedRegistry} contains a given {@link Key} or not.
+     * @param key A given {@link Key}.
+     * @return True if this {@link ExtendedRegistry} contains a given {@link Key}.
+     */
+    boolean containsKey(@NotNull Key key);
+
+    /**
+     * Checks whether this {@link ExtendedRegistry} contains a given {@link ResourceKey} or not.
+     * @param resourceKey A given {@link ResourceKey}.
+     * @return True if this {@link ExtendedRegistry} contains a given {@link ResourceKey}.
+     */
+    boolean containsKey(@NotNull ResourceKey<T> resourceKey);
+
+    /**
+     * Returns a set of {@link Key} this {@link ExtendedRegistry} contains.
+     * @return A set of {@link Key} this {@link ExtendedRegistry} contains.
+     */
+    @NotNull
+    Set<Key> keySet();
+
+    /**
+     * Returns a set of {@link ResourceKey} this {@link ExtendedRegistry} contains.
+     * @return A set of {@link ResourceKey} this {@link ExtendedRegistry} contains.
+     */
+    @NotNull
+    Set<ResourceKey<T>> resourceKeySet();
+
+    /**
+     * Returns a set of entries this {@link ExtendedRegistry} contains.
+     * @return A set of entries.
+     */
+    @NotNull
+    Set<Map.Entry<ResourceKey<T>, T>> entrySet();
+
+    /**
+     * Returns a {@link Stream} of {@link Reference} this {@link ExtendedRegistry} contains.
+     * @return A {@link Stream} of {@link Reference} this {@link ExtendedRegistry} contains.
+     */
+    @NotNull
+    Stream<Reference<T>> references();
+
+    /**
+     * Returns a {@link Stream} of values this {@link ExtendedRegistry} contains.
+     * @return A {@link Stream} of values this {@link ExtendedRegistry} contains.
+     */
+    @NotNull
+    default Stream<T> stream() {
+        return StreamSupport.stream(this.spliterator(), false);
+    }
+
+    /**
+     * An {@link Enum} instance which either may be registered or get without registering.
+     * @param <E>
+     */
+    @ApiStatus.NonExtendable
+    interface EnumRegistryInstance<E extends Enum<E> & Keyed> {
+        /**
+         * @return Registered enum value using {@link ExtendedRegistry#register(RegistryKey.EnumMutableRegistryKey, Enum)}.
+         */
+        @NotNull
+        E register();
+
+        /**
+         * If you want to get a value without registering it, use this method.
+         *
+         * @return Plain value which wasn't registered.
+         */
+        @NotNull
+        E value();
+    }
+
+    @ApiStatus.Internal
+    interface EnumRegistryInstanceBuilder<E extends Enum<E> & Keyed> {
+        @NotNull
+        ExtendedRegistry.EnumRegistryInstance<E> build(@NotNull Key key);
+        
+        @NotNull
+        ExtendedRegistry.EnumRegistryInstance<E> build(@NotNull ResourceKey<E> resourceKey);
+    }
+
+    @ApiStatus.Internal
+    interface SimpleRegistry {
+        <T extends Enum<T> & Keyed> void register(@NotNull RegistryKey.EnumMutableRegistryKey<?, T> registryKey, @NotNull T value);
+
+        <T> void register(@NotNull RegistryKey<?, T> registryKey, @NotNull ResourceKey<T> resourceKey, @NotNull T value);
+
+        <T> void register(@NotNull RegistryKey<?, T> registryKey, @NotNull Key key, @NotNull T value);
+    }
+
+    @ApiStatus.Internal
+    final class API {
+        static ResourceKey.ResourceKeyFactory resourceKeyFactory;
+        static Reference.ReferenceFactory referenceFactory;
+        static RegistryKey.RegistryKeyFactory registryKeyFactory;
+        static SimpleRegistry simpleRegistry;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/Reference.java b/src/main/java/io/papermc/paper/registry/Reference.java
index d880810cbf05bc45051fe29515054211572e33b4..63380df17941526052f506925faca8da386910e0 100644
--- a/src/main/java/io/papermc/paper/registry/Reference.java
+++ b/src/main/java/io/papermc/paper/registry/Reference.java
@@ -1,5 +1,7 @@
 package io.papermc.paper.registry;
 
+import io.papermc.paper.registry.key.ResourceKey;
+import net.kyori.adventure.key.Key;
 import org.bukkit.Keyed;
 import org.bukkit.NamespacedKey;
 import org.bukkit.Registry;
@@ -12,7 +14,7 @@ import org.jetbrains.annotations.Nullable;
  *
  * @param <T> type of the value
  */
-public interface Reference<T extends Keyed> extends Keyed {
+public interface Reference<T> extends Keyed { // Removed "extends Keyed" on the generic, seem to not break anything.
 
     /**
      * Gets the value from the registry with the key.
@@ -29,6 +31,26 @@ public interface Reference<T extends Keyed> extends Keyed {
      */
     @Nullable T valueOrNull();
 
+    /**
+     * Checks whether the reference is bound to a {@link ExtendedRegistry} or not.
+     * @return True if it's bound.
+     */
+    boolean isBound();
+
+    /**
+     * Checks if the value is associated with the given {@link Key}
+     * @param key A given {@link Key}
+     * @return True if it's associated with the given {@link Key}.
+     */
+    boolean is(@NotNull Key key);
+
+    /**
+     * Checks if the value is associated with the given {@link ResourceKey}
+     * @param resourceKey A given {@link ResourceKey}
+     * @return True if it's associated with the given {@link ResourceKey}.
+     */
+    boolean is(@NotNull ResourceKey<T> resourceKey);
+
     /**
      * Creates a reference to a registered value.
      *
@@ -37,7 +59,14 @@ public interface Reference<T extends Keyed> extends Keyed {
      * @param <T> the type of the value
      * @return a reference
      */
+    @Deprecated
     static <T extends Keyed> @NotNull Reference<T> create(@NotNull Registry<T> registry, @NotNull NamespacedKey key) {
-        return new ReferenceImpl<>(registry, key);
+        return ExtendedRegistry.API.referenceFactory.create(registry, key);
+    }
+
+    @org.jetbrains.annotations.ApiStatus.Internal
+    interface ReferenceFactory {
+        @NotNull
+        <T extends Keyed> Reference<T> create(@NotNull Registry<T> registry, @NotNull Key key);
     }
 }
diff --git a/src/main/java/io/papermc/paper/registry/ReferenceImpl.java b/src/main/java/io/papermc/paper/registry/ReferenceImpl.java
index f29e76a6b66ddfec12ddf8db6dcb2df6083b5982..8ebd28fb9709f789e9bc664c737bb9e1516dbc91 100644
--- a/src/main/java/io/papermc/paper/registry/ReferenceImpl.java
+++ b/src/main/java/io/papermc/paper/registry/ReferenceImpl.java
@@ -1,5 +1,7 @@
 package io.papermc.paper.registry;
 
+import io.papermc.paper.registry.key.ResourceKey;
+import net.kyori.adventure.key.Key;
 import org.bukkit.Keyed;
 import org.bukkit.NamespacedKey;
 import org.bukkit.Registry;
@@ -8,6 +10,10 @@ import org.jetbrains.annotations.Nullable;
 
 import java.util.NoSuchElementException;
 
+/**
+ * @deprecated Moved to internals. The ConfiguredStructure API is generally broken and was replaced by upstream one, this is also gonna be yeeted.
+ */
+@Deprecated
 record ReferenceImpl<T extends Keyed>(@NotNull Registry<T> registry, @NotNull NamespacedKey key) implements Reference<T> {
 
     @Override
@@ -24,6 +30,21 @@ record ReferenceImpl<T extends Keyed>(@NotNull Registry<T> registry, @NotNull Na
         return this.registry.get(this.key);
     }
 
+    @Override
+    public boolean isBound() {
+        return false;
+    }
+
+    @Override
+    public boolean is(@NotNull Key key) {
+        return false;
+    }
+
+    @Override
+    public boolean is(@NotNull ResourceKey<T> resourceKey) {
+        return false;
+    }
+
     @Override
     public @NotNull NamespacedKey getKey() {
         return this.key;
diff --git a/src/main/java/io/papermc/paper/registry/WritableRegistry.java b/src/main/java/io/papermc/paper/registry/WritableRegistry.java
new file mode 100644
index 0000000000000000000000000000000000000000..67d52f48d9d5deefb5d2a2ddc4550d8ceb3256b3
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/WritableRegistry.java
@@ -0,0 +1,46 @@
+package io.papermc.paper.registry;
+
+import io.papermc.paper.registry.key.ResourceKey;
+import net.kyori.adventure.key.Key;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An {@link ExtendedRegistry} implementation which provides functionality to add a user defined game content.
+ *
+ * @param <T> A type this {@link WritableRegistry} operates with.
+ * @see io.papermc.paper.registry.access.WritableRegistryAccess
+ */
+public interface WritableRegistry<T> extends ExtendedRegistry<T> {
+    /**
+     * Associates the given {@link T} with a given {@link net.kyori.adventure.key.Key} and a given numerical key.
+     *
+     * @param numericalKey A numerical key you want to assign your {@link T} value to.
+     * @param key A {@link ResourceKey} you want to assign your {@link T} value to.
+     * @param value A {@link T} value you want to register.
+     * @return A {@link Reference} containing registered {@link T} instance.
+     */
+    @NotNull
+    Reference<T> registerMapping(int numericalKey, @NotNull ResourceKey<T> key, @NotNull T value);
+
+    /**
+     * Same as {@link WritableRegistry#registerMapping(int, ResourceKey, Object)} but computes the numerical key automatically.
+     *
+     * @param key A {@link ResourceKey} you want to assign your {@link T} value to.
+     * @param value A {@link T} value you want to register.
+     * @return A {@link Reference} containing registered {@link Enum} instance.
+     */
+    @NotNull
+    Reference<T> register(@NotNull ResourceKey<T> key, @NotNull T value);
+
+    /**
+     * Same as {@link WritableRegistry#register(ResourceKey, Object)} but with a {@link Key} instead.
+     *
+     * @param key A {@link Key} you want to assign your {@link T} value to.
+     * @param value A {@link T} value you want to register.
+     * @return A {@link Reference} containing registered {@link Enum} instance.
+     */
+    @NotNull
+    default Reference<T> register(@NotNull Key key, @NotNull T value) {
+        return this.register(ResourceKey.create(this.resourceKey(), key), value);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/access/RegistryAccess.java b/src/main/java/io/papermc/paper/registry/access/RegistryAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..a431ac040f5dd0858b2e961fbdca30c25e4cd4a8
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/access/RegistryAccess.java
@@ -0,0 +1,25 @@
+package io.papermc.paper.registry.access;
+
+import io.papermc.paper.registry.ExtendedRegistry;
+import io.papermc.paper.registry.key.RegistryKey;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Optional;
+
+/**
+ *  Provides {@link ExtendedRegistry} in various stages of Server initialization.
+ *  Note that {@link RegistryAccess} can be either composite or per-layer,
+ *  it means that {@link #registry(RegistryKey)} may return {@link Optional#empty()} based on where you get that {@link RegistryAccess} from.
+ */
+public interface RegistryAccess {
+
+    /**
+     * Returns a {@link ExtendedRegistry} which you can access to. Note that what types of {@link ExtendedRegistry} this method provides depends on a given {@link RegistryAccess}.
+     *
+     * @param key A given {@link RegistryKey} of a {@link ExtendedRegistry} you want to access.
+     * @return A {@link ExtendedRegistry} which you can access to.
+     * @param <E> A type this registry operates with.
+     */
+    @NotNull
+    <E> Optional<ExtendedRegistry<E>> registry(@NotNull RegistryKey<? extends RegistryKey.RegistryLayerType, E> key);
+}
diff --git a/src/main/java/io/papermc/paper/registry/access/WritableRegistryAccess.java b/src/main/java/io/papermc/paper/registry/access/WritableRegistryAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..634dcca879fa9eb8d7d6a7387754645a4a3095d8
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/access/WritableRegistryAccess.java
@@ -0,0 +1,33 @@
+package io.papermc.paper.registry.access;
+
+import io.papermc.paper.registry.WritableRegistry;
+import io.papermc.paper.registry.enums.EnumWritableRegistry;
+import io.papermc.paper.registry.key.RegistryKey;
+import org.bukkit.Keyed;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Same as {@link RegistryAccess} but guarantees that {@link WritableRegistry} instances it gives are safe to mutate based on its generic.
+ *
+ * @param <L> A layer / stage of server initialization when the {@link WritableRegistry} instances are safe to mutate.
+ */
+public interface WritableRegistryAccess<L extends RegistryKey.RegistryLayerType> extends RegistryAccess {
+    /**
+     * Gives a {@link WritableRegistry} only if the registry is generally safe to mutate and belongs to a layer that this {@link WritableRegistryAccess} guarantees its safe mutability.
+     *
+     * @param key A {@link RegistryKey} which shows that this registry is safe to mutate.
+     * @return A {@link WritableRegistry} instance.
+     * @param <E> A type the {@link WritableRegistry} operates with.
+     */
+    @NotNull
+    <E> WritableRegistry<E> registry(@NotNull RegistryKey.MutableRegistryKey<L, E> key);
+
+    /**
+     * Same as {@link #registry(RegistryKey.MutableRegistryKey)} but for {@link Enum}.
+     * @param key A {@link RegistryKey} which shows that this registry is safe to mutate.
+     * @return A {@link WritableRegistry} instance.
+     * @param <E> A type the {@link WritableRegistry} operates with.
+     */
+    @NotNull
+    <E extends Enum<E> & Keyed> EnumWritableRegistry<E> registry(@NotNull RegistryKey.EnumMutableRegistryKey<L, E> key);
+}
diff --git a/src/main/java/io/papermc/paper/registry/enums/EnumCreator.java b/src/main/java/io/papermc/paper/registry/enums/EnumCreator.java
new file mode 100644
index 0000000000000000000000000000000000000000..aba41ff94cb99f5db183398ce9792210efa2c5e3
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/enums/EnumCreator.java
@@ -0,0 +1,41 @@
+package io.papermc.paper.registry.enums;
+
+import io.papermc.paper.registry.key.RegistryKey;
+import io.papermc.paper.registry.key.ResourceKey;
+import net.kyori.adventure.key.Key;
+import org.bukkit.Keyed;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.function.Supplier;
+
+/**
+ * An internal API which allows to make new instances of {@link Enum} using {@link java.lang.invoke.MethodHandles}.
+ * It exists to support making new instances of Bukkit API enums without breaking backwards compatibility.
+ *
+ * @param <T> An {@link Enum} this {@link EnumCreator} creates / handles.
+ */
+@ApiStatus.Internal
+public interface EnumCreator<T extends Enum<T> & Keyed> {
+    /**
+     * Creates a new instance of an enum using constructor using {@link ResourceKey} and given parameters.
+     *
+     * @return A new {@link Enum} instance.
+     */
+    @NotNull
+    T create(@NotNull ResourceKey<T> resourceKey, @NotNull Object... params);
+
+    /**
+     * Creates a new instance of an enum using constructor using {@link Key} and given parameters.
+     *
+     * @return A new {@link Enum} instance.
+     */
+    @NotNull
+    T create(@NotNull Key key, @NotNull Object... params);
+
+    /**
+     *  An internal API for providing additional data for defined {@link Enum} values.
+     */
+    @NotNull
+    <P, API extends Enum<API> & Keyed> Supplier<P> param(@NotNull RegistryKey.EnumMutableRegistryKey<? extends RegistryKey.RegistryLayerType, API> registryKey, @NotNull Class<P> type, @NotNull Key key);
+}
diff --git a/src/main/java/io/papermc/paper/registry/enums/EnumWritableRegistry.java b/src/main/java/io/papermc/paper/registry/enums/EnumWritableRegistry.java
new file mode 100644
index 0000000000000000000000000000000000000000..aa53e205cb6ac3d8f8485c7504400a0875c36c9e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/enums/EnumWritableRegistry.java
@@ -0,0 +1,32 @@
+package io.papermc.paper.registry.enums;
+
+import io.papermc.paper.registry.ExtendedRegistry;
+import io.papermc.paper.registry.Reference;
+import org.bukkit.Keyed;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Same as {@link io.papermc.paper.registry.WritableRegistry} but for the {@link Enum} registration.
+ *
+ * @param <T> A type this {@link EnumWritableRegistry} operates with.
+ */
+public interface EnumWritableRegistry<T extends Enum<T> & Keyed> extends ExtendedRegistry<T> {
+    /**
+     * Associates the given {@link Enum} with its {@link net.kyori.adventure.key.Key} provided by the {@link Keyed} interface and its numerical key.
+     *
+     * @param numericalKey A numerical key you want to assign your {@link Enum} value to.
+     * @param value An {@link Enum} value you want to register.
+     * @return A {@link Reference} containing registered {@link Enum} instance.
+     */
+    @NotNull
+    Reference<T> registerMapping(int numericalKey, @NotNull T value);
+
+    /**
+     * Same as {@link EnumWritableRegistry#registerMapping(int, Enum)} but computes the numerical key automatically.
+     *
+     * @param value An {@link Enum} value you want to register.
+     * @return A {@link Reference} containing registered {@link Enum} instance.
+     */
+    @NotNull
+    Reference<T> register(@NotNull T value);
+}
diff --git a/src/main/java/io/papermc/paper/registry/key/RegistryKey.java b/src/main/java/io/papermc/paper/registry/key/RegistryKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..447f2e2dbf3558ccb041f151fe4f5233ac3afff3
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/key/RegistryKey.java
@@ -0,0 +1,68 @@
+package io.papermc.paper.registry.key;
+
+import io.papermc.paper.registry.ExtendedRegistry;
+import org.bukkit.Keyed;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Represents a key which contains various info of a {@link ExtendedRegistry} it belongs to.
+ * This key is used in {@link io.papermc.paper.registry.access.RegistryAccess} and {@link io.papermc.paper.registry.access.WritableRegistryAccess} to get an {@link ExtendedRegistry} instance.
+ * This key also is used in {@link ExtendedRegistry#register(MutableRegistryKey, ResourceKey, Object)} to allow registering without having to use the {@link io.papermc.paper.lifecycle.LifecyclePoint} system.
+ *
+ * @param <L> A layer / stage when the registry this key belongs to is safe to mutate.
+ * @param <E> A type the registry operates with.
+ */
+public interface RegistryKey<L extends RegistryKey.RegistryLayerType, E> extends ResourceKey<ExtendedRegistry<E>> {
+    /**
+     * Represents a {@link RegistryKey} which cannot be modified by a user.
+     *
+     * @param <L> A layer / stage when the registry this key belongs to is safe to mutate.
+     * @param <E> A type the registry operates with.
+     */
+    interface ImmutableRegistryKey<L extends RegistryKey.RegistryLayerType, E> extends RegistryKey<L, E> {}
+
+    /**
+     * Represents a {@link RegistryKey} which can be modified by a user and isn't an enum.
+     *
+     * @param <L> A layer / stage when the registry this key belongs to is safe to mutate.
+     * @param <E> A type the registry operates with.
+     */
+    interface MutableRegistryKey<L extends RegistryKey.RegistryLayerType, E> extends RegistryKey<L, E> {}
+
+    /**
+     * Represents a {@link RegistryKey} which can be modified by a user and which type is represented by an enum in the Bukkit API.
+     *
+     * @param <L> A layer / stage when the registry this key belongs to is safe to mutate.
+     * @param <E> A type the registry operates with.
+     */
+    interface EnumMutableRegistryKey<L extends RegistryKey.RegistryLayerType, E extends Enum<E> & Keyed> extends RegistryKey<L, E> {}
+
+    /**
+     * @return A type of registry layer / stage this key belongs to.
+     */
+    @NotNull
+    Class<? extends RegistryLayerType> layerType();
+
+    @ApiStatus.Internal
+    interface RegistryKeyFactory {
+        @NotNull
+        <L extends RegistryLayerType, E> ImmutableRegistryKey<L, E> createImmutable(@NotNull Class<E> clazz, @NotNull Class<? extends RegistryLayerType> layerType);
+
+        @NotNull
+        <L extends RegistryLayerType, E> MutableRegistryKey<L, E> createMutable(@NotNull Class<E> clazz, @NotNull Class<? extends RegistryLayerType> layerType);
+
+        @NotNull
+        <L extends RegistryLayerType, E extends Enum<E> & Keyed> EnumMutableRegistryKey<L, E> createEnumMutable(@NotNull Class<E> clazz, @NotNull Class<? extends RegistryLayerType> layerType);
+    }
+
+    /**
+     * Represents a layer / stage when the registry is initialized and safe to mutate, used in {@link io.papermc.paper.registry.access.WritableRegistryAccess}.
+     */
+    interface RegistryLayerType {
+        interface STATIC extends RegistryLayerType {}
+        interface WORLDGEN extends RegistryLayerType {}
+        interface DIMENSION extends RegistryLayerType {}
+        interface RELOADABLE extends RegistryLayerType {}
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/key/ResourceKey.java b/src/main/java/io/papermc/paper/registry/key/ResourceKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..a9b72b1f56c0c28bbf3a5e75db451a2daeb7f65b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/key/ResourceKey.java
@@ -0,0 +1,73 @@
+package io.papermc.paper.registry.key;
+
+import io.papermc.paper.registry.ExtendedRegistry;
+import net.kyori.adventure.key.Key;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Represents a key which contains information about its {@link Key} and the {@link Key} of its {@link ExtendedRegistry} it's able to be registered in.
+ *
+ * @param <T> A type of element which the {@link ExtendedRegistry} operates with.
+ */
+public interface ResourceKey<T> {
+    /**
+     * Returns a key the element is associated with.
+     * @return A key the element is associated with.
+     */
+    @NotNull
+    Key key();
+
+    /**
+     * Returns a key element's @{@link ExtendedRegistry} is associated with.
+     * @return A key element's @{@link ExtendedRegistry} is associated with.
+     */
+    @NotNull
+    Key registry();
+
+    /**
+     * Returns true if this {@link ResourceKey} belongs to the given {@link ResourceKey} of a {@link ExtendedRegistry}.
+     * @param registryKey A {@link ResourceKey} of a {@link ExtendedRegistry}.
+     * @return True if this {@link ResourceKey} belongs to the given {@link ResourceKey} of a {@link ExtendedRegistry}.
+     */
+    default boolean isFor(@NotNull ResourceKey<? extends ExtendedRegistry<T>> registryKey) {
+        return this.registry().equals(registryKey.key());
+    }
+
+    /**
+     * Creates a new {@link ResourceKey} based on provided {@link ResourceKey} which belongs to a {@link ExtendedRegistry} and a {@link Key} the element is associated with.
+     * @param registryKey A {@link ResourceKey} of a {@link ExtendedRegistry} the element of this key is associated with.
+     * @param key A {@link Key} which the element is associated with.
+     * @return A new {@link ResourceKey} instance.
+     * @param <T> A type of element which the {@link ExtendedRegistry} operates with.
+     */
+    @NotNull
+    static <T> ResourceKey<T> create(@NotNull ResourceKey<? extends ExtendedRegistry<T>> registryKey, @NotNull Key key) {
+        return API.resourceKeyFactory.create(registryKey, key);
+    }
+
+    /**
+     * Creates a new {@link ResourceKey} for a registry.
+     * @param registryKey A {@link Key} which the {@link ExtendedRegistry} is associated with.
+     * @return A {@link ResourceKey} of a {@link ExtendedRegistry}.
+     * @param <T> A type of element which the {@link ExtendedRegistry} operates with.
+     */
+    @NotNull
+    static <T> ResourceKey<? extends ExtendedRegistry<T>> create(@NotNull Key registryKey) {
+        return API.resourceKeyFactory.create(registryKey);
+    }
+
+    @ApiStatus.Internal
+    interface ResourceKeyFactory {
+        @NotNull
+        <T> ResourceKey<T> create(@NotNull ResourceKey<? extends ExtendedRegistry<T>> registryKey, @NotNull Key key);
+
+        @NotNull
+        <T> ResourceKey<? extends ExtendedRegistry<T>> create(@NotNull Key registryKey);
+    }
+
+    @ApiStatus.Internal
+    final class API {
+        static ResourceKey.ResourceKeyFactory resourceKeyFactory;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/key/ResourceKeyed.java b/src/main/java/io/papermc/paper/registry/key/ResourceKeyed.java
new file mode 100644
index 0000000000000000000000000000000000000000..aa9b8fa5f62496ac4d1e9d389733799506a891a9
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/key/ResourceKeyed.java
@@ -0,0 +1,25 @@
+package io.papermc.paper.registry.key;
+
+import net.kyori.adventure.key.Key;
+import net.kyori.adventure.key.Keyed;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Something which contains a {@link ResourceKey}.
+ * @param <T>  A type which {@link ResourceKey} contains.
+ */
+public interface ResourceKeyed<T> extends Keyed {
+    /**
+     * @return A {@link ResourceKey} of this object.
+     */
+    @NotNull
+    ResourceKey<? extends T> resourceKey();
+
+    /**
+     * @return A {@link Key} of an element this {@link ResourceKey} contains.
+     */
+    @Override
+    default @NotNull Key key() {
+        return this.resourceKey().key();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/registry/package-info.java b/src/main/java/io/papermc/paper/registry/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..e09b2f311d9f60cbbe294bd16a5979c0979cef5c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/package-info.java
@@ -0,0 +1,7 @@
+/**
+ * An experimental Paper plugins API which allows users to add new game content without breaking Bukkit API.
+ */
+@ApiStatus.Experimental
+package io.papermc.paper.registry;
+
+import org.jetbrains.annotations.ApiStatus;
diff --git a/src/test/java/io/papermc/paper/registry/SetupAPI.java b/src/test/java/io/papermc/paper/registry/SetupAPI.java
new file mode 100644
index 0000000000000000000000000000000000000000..9a056c7676dcdf0a04c73c16e7fc5351e0e5257b
--- /dev/null
+++ b/src/test/java/io/papermc/paper/registry/SetupAPI.java
@@ -0,0 +1,32 @@
+package io.papermc.paper.registry;
+
+import io.papermc.paper.registry.key.RegistryKey;
+import org.bukkit.Keyed;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Since we have Bukkit APIs touching Paper ones, we need to set up them for test to work.
+ */
+public class SetupAPI {
+    /**
+     * Nulls are enough for now.
+     */
+    public static void setup() {
+        ExtendedRegistry.API.registryKeyFactory = new RegistryKey.RegistryKeyFactory() {
+            @Override
+            public <L extends RegistryKey.RegistryLayerType, E> RegistryKey.@NotNull ImmutableRegistryKey<L, E> createImmutable(@NotNull Class<E> clazz, @NotNull Class<? extends RegistryKey.RegistryLayerType> layerType) {
+                return null;
+            }
+
+            @Override
+            public <L extends RegistryKey.RegistryLayerType, E> RegistryKey.@NotNull MutableRegistryKey<L, E> createMutable(@NotNull Class<E> clazz, @NotNull Class<? extends RegistryKey.RegistryLayerType> layerType) {
+                return null;
+            }
+
+            @Override
+            public <L extends RegistryKey.RegistryLayerType, E extends Enum<E> & Keyed> RegistryKey.@NotNull EnumMutableRegistryKey<L, E> createEnumMutable(@NotNull Class<E> clazz, @NotNull Class<? extends RegistryKey.RegistryLayerType> layerType) {
+                return null;
+            }
+        };
+    }
+}
diff --git a/src/test/java/org/bukkit/TestWorld.java b/src/test/java/org/bukkit/TestWorld.java
index f64d024f5bbf9482aaddb56597b23b04c66f21bf..0df3f2db306ef36487033cd12783b8a2b25193e7 100644
--- a/src/test/java/org/bukkit/TestWorld.java
+++ b/src/test/java/org/bukkit/TestWorld.java
@@ -18,6 +18,7 @@ public final class TestWorld implements InvocationHandler {
 
     static {
         try {
+            io.papermc.paper.registry.SetupAPI.setup(); // Paper - setup API for test to work
             io.papermc.paper.testing.TestServer.setup(); // Paper
 
             ImmutableMap.Builder<Method, MethodHandler> methodMap = ImmutableMap.builder();
