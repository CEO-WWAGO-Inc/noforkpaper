From f38ba4556d2f2748706a84a8bfc56cfe749e4be9 Mon Sep 17 00:00:00 2001
From: slicklibro <slicklibro@gmail.com>
Date: Fri, 20 Sep 2019 17:16:14 +1200
Subject: [PATCH] Ticket level per-player view distance API

This PR implements the per-player view distance API at the ticket level.
This somewhat clean solution comes from the result of many complicated ones (and research).
The view distance will determine how far the player can add tickets to chunks.
The tracking view distance will determine how far the player can track chunks.
All chunks with player tickets within this range will also be served by the server, allowing shared view distance from other players without impacting performance.

The added class calculates a player ticket attached area map, a player tracked
area map that excludes chunks with no tickets attached, as well as as a binary
update queue simultaneously, through an efficient although specific coordinate
compression algorithm.

diff --git a/src/main/java/co/aikar/timings/WorldTimingsHandler.java b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
index ddec62fbf..0a5a099b4 100644
--- a/src/main/java/co/aikar/timings/WorldTimingsHandler.java
+++ b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
@@ -75,6 +75,8 @@ public class WorldTimingsHandler {
     public final Timing chunkUnloadDataSave;
 
     public final Timing playerMobDistanceMapUpdate;
+    public final Timing playerTicketAreaMapUpdate;
+    public final Timing playerTicketAreaMapRemove;
 
     public WorldTimingsHandler(World server) {
         String name = server.worldData.getName() +" - ";
@@ -148,6 +150,8 @@ public class WorldTimingsHandler {
         chunkUnloadDataSave = Timings.ofSafe(name + "Chunk unload - Data Serialization");
 
         playerMobDistanceMapUpdate = Timings.ofSafe(name + "Per Player Mob Spawning - Distance Map Update");
+        playerTicketAreaMapUpdate = Timings.ofSafe(name + "Player Ticket Area Map - Update");
+        playerTicketAreaMapRemove = Timings.ofSafe(name + "Player Ticket Area Map  - Remove");
     }
 
     public static Timing getTickList(WorldServer worldserver, String timingsType) {
diff --git a/src/main/java/com/destroystokyo/paper/util/PlayerTicketAreaMap.java b/src/main/java/com/destroystokyo/paper/util/PlayerTicketAreaMap.java
new file mode 100644
index 000000000..a9fa61bd4
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/PlayerTicketAreaMap.java
@@ -0,0 +1,391 @@
+package com.destroystokyo.paper.util;
+
+import it.unimi.dsi.fastutil.ints.*;
+import it.unimi.dsi.fastutil.longs.*;
+import it.unimi.dsi.fastutil.objects.*;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.EntityPlayer;
+
+import javax.annotation.Nullable;
+
+/*
+  base logic note for ticket level per player view distance.
+
+  in the default update queue, only changed minimum levels are updated
+  this poses issues when view distances overlap, as we hit a midpoint barrier
+
+  e.g overlapping levels which do not surpass the peak midpoint
+  p1 has vd of 8, p2 has vd of 2, p1 and p2 have 9 chunks in between
+  p1 1 2 3 4 5 4 3 2 1 p2
+  p1 x x x x x x x y y y
+  x are tickets added by p1, and y are tickets added by p2, we want the action above.
+  in reality however this happens as only chunks before the midpoint are updated by mojang's default queue when p1 moves
+  p1 1 2 3 4 5 4 3 2 1 p2
+  p1 x x x x _ _ _ y y y
+  _ represents unloaded chunks without tickets, thus this default model fails and we must use an algorithm to account for overlaps & all cases efficiently
+
+  using coordinate compression we graph overlapping squares & squares that need action to compressed cells accordingly
+  we extract the corner coordinates of each filled cell that requires an action, loop through the coordinates and add the pos pairs accordingly to our update queue
+
+  we also simultaneously calculate the area map in the same iteration for maximum efficiency
+
+*/
+
+/**
+ * This class calculates a player ticket attached area map, a player tracked area map that excludes chunks with no tickets attached, as well as
+ * as a binary update queue simultaneously, through an efficient although specific coordinate compression algorithm.
+ *
+ * @author slicklibro */
+
+public class PlayerTicketAreaMap {
+
+    //byte constants, these can be anything but 0
+    public static final byte ADD = 1;
+    public static final byte REMOVE = -1;
+    public static final byte EXISTING = -2;
+    public static final byte TRACK = -3;
+    public static final byte UNTRACK = -4;
+    public static final byte OVERLAP = -5;
+    public static final byte TRACK_OVERLAP = -6;
+    public static final byte TRACK_EXISTING = -7;
+
+    private final Int2ObjectMap<Square> squares = new Int2ObjectOpenHashMap<>();
+    private final Int2ObjectMap<Square> trackSquares = new Int2ObjectOpenHashMap<>();
+
+    private Long2ByteMap toUpdate = new Long2ByteOpenHashMap();
+
+    //players mapped to chunks that should be ticketed
+    public final Long2ObjectMap<ObjectSet<EntityPlayer>> areaMap = new Long2ObjectOpenHashMap<>();
+
+    //players mapped to chunks that should be ticketed within their tracking range
+    public final Long2ObjectMap<ObjectSet<EntityPlayer>> areaMapTracked = new Long2ObjectOpenHashMap<>();
+
+    public class Square {
+        public int x, z, u, v, action;
+        public Square(int x1, int z1, int u1, int v1, int action1) {
+            x = x1; z = z1; u = u1; v = v1; action = action1;
+        }
+    }
+
+    public void updatePlayer(EntityPlayer entityplayer, long chunkPair) {
+        int cx = ChunkCoordIntPair.getX(chunkPair);
+        int cz = ChunkCoordIntPair.getZ(chunkPair);
+        int pvd = entityplayer.getViewDistance() - 2;
+
+        boolean flag = false;
+
+        //algorithm that graphs coordinate compressed map of squares overlapping current player's squares that need to be updated, as well as any squares that need to be purged
+        Square currSqr = new Square(cx - pvd, cz - pvd, cx + pvd + 1, cz + pvd + 1, EXISTING);
+        Square old = this.squares.get(entityplayer.getUniqueID().hashCode());
+        this.squares.put(entityplayer.getUniqueID().hashCode(), new Square(cx - pvd, cz - pvd, cx + pvd + 1, cz + pvd + 1, EXISTING));
+
+        if (old == null || old == this.squares.defaultReturnValue()) {  flag = true; old = currSqr; }
+        Square lastSqr = new Square(old.x, old.z, old.u, old.v, old.action);
+
+        //row & col must be sorted to represent cells correctly, treeset to perform headSet().size() to obtain index
+        IntSortedSet row = new IntRBTreeSet(IntComparators.NATURAL_COMPARATOR);
+        IntSortedSet col = new IntRBTreeSet(IntComparators.NATURAL_COMPARATOR);
+        ObjectList<Square> toproc = new ObjectArrayList<>();
+
+        //assign appropriate actions to squares
+        lastSqr.action = REMOVE; currSqr.action = ADD;
+        toproc.add(lastSqr); toproc.add(currSqr);
+        row.add(lastSqr.z); row.add(lastSqr.v); col.add(lastSqr.x); col.add(lastSqr.u);
+        row.add(currSqr.z); row.add(currSqr.v); col.add(currSqr.x); col.add(currSqr.u);
+
+        //if both the player's last square and new square overlap, form intersect square and add that to process
+        if (lastSqr.x < currSqr.u && lastSqr.u > currSqr.x && lastSqr.z < currSqr.v && lastSqr.v > currSqr.z && !flag) {
+            Square ovdsqr = new Square(Math.max(lastSqr.x, currSqr.x), Math.max(lastSqr.z, currSqr.z), Math.min(lastSqr.u, currSqr.u), Math.min(lastSqr.v, currSqr.v), OVERLAP);
+            toproc.add(ovdsqr);
+            row.add(ovdsqr.z); row.add(ovdsqr.v); col.add(ovdsqr.x); col.add(ovdsqr.u);
+        }
+
+        //handle tracking
+        int trackPvd = entityplayer.getTrackViewDistance() - 2;
+
+        boolean flagTrack = false;
+
+        Square currTrackSqr = new Square(cx - trackPvd, cz - trackPvd, cx + trackPvd + 1, cz + trackPvd + 1, TRACK_EXISTING);
+        Square oldTrackSqr = this.trackSquares.get(entityplayer.getUniqueID().hashCode());
+        this.trackSquares.put(entityplayer.getUniqueID().hashCode(), new Square(cx - trackPvd, cz - trackPvd, cx + trackPvd + 1, cz + trackPvd + 1, TRACK_EXISTING));
+
+        if (oldTrackSqr == null || oldTrackSqr == this.squares.defaultReturnValue()) {  flagTrack = true; oldTrackSqr = currSqr; }
+        Square lastTrackSqr = new Square(oldTrackSqr.x, oldTrackSqr.z, oldTrackSqr.u, oldTrackSqr.v, oldTrackSqr.action);
+
+        //iterate through all squares and only add squares that overlap the last/curr squares to process
+        ObjectIterator<Int2ObjectMap.Entry<Square>> sqriterator = this.squares.int2ObjectEntrySet().iterator();
+
+        while (sqriterator.hasNext()) {
+            it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry<Square> e = sqriterator.next();
+            int uid = e.getIntKey();
+            Square sqr = e.getValue();
+            if (uid == entityplayer.getUniqueID().hashCode()) continue;
+            //check if square overlaps, if so add it to process
+            if ((sqr.x < currTrackSqr.u && sqr.u > currTrackSqr.x && sqr.z < currTrackSqr.v && sqr.v > currTrackSqr.z) ||
+                (sqr.x < lastTrackSqr.u && sqr.u > lastTrackSqr.x && sqr.z < lastTrackSqr.v && sqr.v > lastTrackSqr.z) ||
+                (sqr.x < currSqr.u && sqr.u > currSqr.x && sqr.z < currSqr.v && sqr.v > currSqr.z) ||
+                (sqr.x < lastSqr.u && sqr.u > lastSqr.x && sqr.z < lastSqr.v && sqr.v > lastSqr.z)) {
+
+                toproc.add(sqr);
+                row.add(sqr.z); row.add(sqr.v); col.add(sqr.x); col.add(sqr.u);
+            }
+        }
+
+        //add tracking squares afterwards
+        lastTrackSqr.action = UNTRACK; currTrackSqr.action = TRACK;
+        toproc.add(lastTrackSqr); toproc.add(currTrackSqr);
+        row.add(lastTrackSqr.z); row.add(lastTrackSqr.v); col.add(lastTrackSqr.x); col.add(lastTrackSqr.u);
+        row.add(currTrackSqr.z); row.add(currTrackSqr.v); col.add(currTrackSqr.x); col.add(currTrackSqr.u);
+
+        if (lastTrackSqr.x < currTrackSqr.u && lastTrackSqr.u > currTrackSqr.x && lastTrackSqr.z < currTrackSqr.v && lastTrackSqr.v > currTrackSqr.z && !flagTrack) {
+            Square trackOvdSqr = new Square(Math.max(lastTrackSqr.x, currTrackSqr.x), Math.max(lastTrackSqr.z, currTrackSqr.z), Math.min(lastTrackSqr.u, currTrackSqr.u), Math.min(lastTrackSqr.v, currTrackSqr.v), TRACK_OVERLAP);
+            toproc.add(trackOvdSqr);
+            row.add(trackOvdSqr.z); row.add(trackOvdSqr.v); col.add(trackOvdSqr.x); col.add(trackOvdSqr.u);
+        }
+
+
+        ObjectListIterator<Square> it = toproc.iterator();
+        //coordinate compress & fill map with squares to process (in correct order to form overlapped map)
+        int[][] grid = new int[row.size()][col.size()];
+        int[][] attachGrid = new int[row.size()][col.size()];
+        int[][] attachTrackGrid = new int[row.size()][col.size()];
+
+        while (it.hasNext()) {
+            Square sqr = it.next();
+            for (int s = row.headSet(sqr.z).size(); s < row.headSet(sqr.v).size(); s++) {
+                for (int t = col.headSet(sqr.x).size(); t < col.headSet(sqr.u).size(); t++) {
+                    if(sqr.action == ADD || sqr.action == REMOVE || sqr.action == OVERLAP) {
+                        attachGrid[s][t] = sqr.action;
+                    }
+
+                    if(sqr.action == TRACK || sqr.action == UNTRACK || sqr.action == TRACK_OVERLAP) {
+                        attachTrackGrid[s][t] = sqr.action;
+                        //do not track cells without tickets
+                        if(grid[s][t] == 0 || grid[s][t] == REMOVE) {
+                            attachTrackGrid[s][t] = UNTRACK;
+                        }
+
+                        if(sqr.action == TRACK_OVERLAP || sqr.action == TRACK) {
+                            if(grid[s][t] == EXISTING || grid[s][t] == ADD) {
+                                attachTrackGrid[s][t] = TRACK;
+                            }
+                        }
+
+                    } else {
+                        grid[s][t] = sqr.action;
+                    }
+                }
+            }
+        }
+
+        //check against cells on filled map
+        int[] rw = row.toIntArray(); int[] cl = col.toIntArray();
+        for (int s = 0; s < row.size() - 1; s++) {
+            for (int t = 0; t < col.size() - 1; t++) {
+                if (grid[s][t] == REMOVE) {
+                    //decompress/loop through coordinates and queue to update
+                    for (int x = cl[t]; x < cl[t + 1]; x++) {
+                        for (int z = rw[s]; z < rw[s + 1]; z++) {
+                            long pair = ChunkCoordIntPair.asLong(x, z);
+                            toUpdate.put(pair, (byte) REMOVE);
+                        }
+                    }
+
+                } else if (grid[s][t] == ADD) {
+                    for (int x = cl[t]; x < cl[t + 1]; x++) {
+                        for (int z = rw[s]; z < rw[s + 1]; z++) {
+                            long pair = ChunkCoordIntPair.asLong(x, z);
+                            toUpdate.put(pair, (byte) ADD);
+                        }
+                    }
+                }
+                if(attachGrid[s][t] == ADD) {
+                    for (int x = cl[t]; x < cl[t + 1]; x++) {
+                        for (int z = rw[s]; z < rw[s + 1]; z++) {
+                            long pair = ChunkCoordIntPair.asLong(x, z);
+                            this.attach(pair, entityplayer);
+                        }
+                    }
+                } else if (attachGrid[s][t] == REMOVE) {
+                    for (int x = cl[t]; x < cl[t + 1]; x++) {
+                        for (int z = rw[s]; z < rw[s + 1]; z++) {
+                            long pair = ChunkCoordIntPair.asLong(x, z);
+                            this.detach(pair, entityplayer);
+                        }
+                    }
+                }
+                if(attachTrackGrid[s][t] == TRACK) {
+                    for (int x = cl[t]; x < cl[t + 1]; x++) {
+                        for (int z = rw[s]; z < rw[s + 1]; z++) {
+                            long pair = ChunkCoordIntPair.asLong(x, z);
+                            this.attachTrack(pair, entityplayer);
+                        }
+                    }
+                } else if (attachTrackGrid[s][t] == UNTRACK) {
+                    for (int x = cl[t]; x < cl[t + 1]; x++) {
+                        for (int z = rw[s]; z < rw[s + 1]; z++) {
+                            long pair = ChunkCoordIntPair.asLong(x, z);
+                            this.detachTrack(pair, entityplayer);
+                        }
+                    }
+                }
+
+            }
+
+        }
+
+    }
+
+    public void removePlayer(EntityPlayer entityplayer) {
+        //similar to above, this time dealing with full removal
+        Square remSqr = this.squares.remove(entityplayer.getUniqueID().hashCode());
+        Square remTrackSqr = this.trackSquares.remove(entityplayer.getUniqueID().hashCode());
+        if(remSqr != null && remSqr != this.squares.defaultReturnValue() && remTrackSqr != null && remTrackSqr != this.trackSquares.defaultReturnValue()) {
+            IntSortedSet row = new IntRBTreeSet(IntComparators.NATURAL_COMPARATOR);
+            IntSortedSet col = new IntRBTreeSet(IntComparators.NATURAL_COMPARATOR);
+            ObjectList<Square> toproc = new ObjectArrayList<>();
+            ObjectIterator<Int2ObjectMap.Entry<Square>> sqriterator = this.squares.int2ObjectEntrySet().iterator();
+
+            remSqr.action = REMOVE;
+            toproc.add(remSqr);
+            row.add(remSqr.z); row.add(remSqr.v); col.add(remSqr.x); col.add(remSqr.u);
+
+            while (sqriterator.hasNext()) {
+                it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry<Square> e = sqriterator.next();
+                Square sqr = e.getValue();
+                if (sqr.x < remSqr.u && sqr.u > remSqr.x && sqr.z < remSqr.v && sqr.v > remSqr.z) {
+                    toproc.add(sqr);
+                    row.add(sqr.z); row.add(sqr.v); col.add(sqr.x); col.add(sqr.u);
+                }
+            }
+
+            remTrackSqr.action = UNTRACK;
+            toproc.add(remTrackSqr);
+            row.add(remTrackSqr.z); row.add(remTrackSqr.v); col.add(remTrackSqr.x); col.add(remTrackSqr.u);
+
+            ObjectListIterator<Square> it = toproc.iterator();
+
+            int[][] grid = new int[row.size()][col.size()];
+            int[][] attachGrid = new int[row.size()][col.size()];
+            int[][] attachTrackGrid = new int[row.size()][col.size()];
+
+            while (it.hasNext()) {
+                Square sqr = it.next();
+                for (int s = row.headSet(sqr.z).size(); s < row.headSet(sqr.v).size(); s++) {
+                    for (int t = col.headSet(sqr.x).size(); t < col.headSet(sqr.u).size(); t++) {
+                        if(sqr.action == REMOVE) {
+                            attachGrid[s][t] = sqr.action;
+                        }
+                        if(sqr.action == UNTRACK) {
+                            attachTrackGrid[s][t] = sqr.action;
+                        } else {
+                            grid[s][t] = sqr.action;
+                        }
+                    }
+                }
+            }
+
+            int[] rw = row.toIntArray(); int[] cl = col.toIntArray();
+            for (int s = 0; s < row.size() - 1; s++) {
+                for (int t = 0; t < col.size() - 1; t++) {
+                    if (grid[s][t] == REMOVE) {
+                        for (int x = cl[t]; x < cl[t + 1]; x++) {
+                            for (int z = rw[s]; z < rw[s + 1]; z++) {
+                                long pair = ChunkCoordIntPair.asLong(x, z);
+                                toUpdate.put(pair, (byte) REMOVE);
+                            }
+                        }
+                    }
+                    if (attachGrid[s][t] == REMOVE) {
+                        for (int x = cl[t]; x < cl[t + 1]; x++) {
+                            for (int z = rw[s]; z < rw[s + 1]; z++) {
+                                long pair = ChunkCoordIntPair.asLong(x, z);
+                                this.detach(pair, entityplayer);
+                            }
+                        }
+                    }
+                    if (attachTrackGrid[s][t] == UNTRACK) {
+                        for (int x = cl[t]; x < cl[t + 1]; x++) {
+                            for (int z = rw[s]; z < rw[s + 1]; z++) {
+                                long pair = ChunkCoordIntPair.asLong(x, z);
+                                this.detachTrack(pair, entityplayer);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    public byte removeUpdate(long pair) {
+        return this.toUpdate.remove(pair);
+    }
+
+    public Long2ByteMap getUpdates() {
+        return this.toUpdate;
+    }
+
+    public void clearUpdates() {
+        this.toUpdate.clear();
+    }
+
+    @Nullable
+    public ObjectSet<EntityPlayer> getPlayersTicketing(long pair) {
+        return this.areaMap.get(pair);
+    }
+
+    @Nullable
+    public ObjectSet<EntityPlayer> getPlayersTicketing(int chunkX, int chunkZ) {
+        return this.getPlayersTicketing(ChunkCoordIntPair.asLong(chunkX, chunkZ));
+    }
+
+    @Nullable
+    public ObjectSet<EntityPlayer> getPlayersTicketing(ChunkCoordIntPair chunkCoordIntPair) {
+        return this.getPlayersTicketing(chunkCoordIntPair.x, chunkCoordIntPair.z);
+    }
+
+    @Nullable
+    public ObjectSet<EntityPlayer> getPlayersTracking(long pair) {
+        return this.areaMapTracked.get(pair);
+    }
+
+    @Nullable
+    public ObjectSet<EntityPlayer> getPlayersTracking(int chunkX, int chunkZ) {
+        return this.getPlayersTracking(ChunkCoordIntPair.asLong(chunkX, chunkZ));
+    }
+
+    @Nullable
+    public ObjectSet<EntityPlayer> getPlayersTracking(ChunkCoordIntPair chunkCoordIntPair) {
+        return this.getPlayersTracking(chunkCoordIntPair.x, chunkCoordIntPair.z);
+    }
+
+    public int size() {
+        return this.areaMap.size();
+    }
+    
+    private void attach(long l, EntityPlayer player) {
+        this.areaMap.computeIfAbsent(l, l2 -> new ObjectOpenHashSet<>()).add(player);
+    }
+
+    private void detach(long l, EntityPlayer player) {
+        ObjectSet objectSet = (ObjectSet)this.areaMap.get(l);
+        if(objectSet != null) {
+            objectSet.remove(player);
+            if (objectSet.isEmpty()) this.areaMap.remove(l);
+        }
+    }
+
+    private void attachTrack(long l, EntityPlayer player) {
+        this.areaMapTracked.computeIfAbsent(l, l2 -> new ObjectOpenHashSet<>()).add(player);
+    }
+
+    private void detachTrack(long l, EntityPlayer player) {
+        ObjectSet objectSet = (ObjectSet)this.areaMapTracked.get(l);
+        if(objectSet != null) {
+            objectSet.remove(player);
+            if (objectSet.isEmpty()) this.areaMapTracked.remove(l);
+        }
+    }
+
+}
diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index 63a688725..191bede32 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -1,7 +1,6 @@
 package net.minecraft.server;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Sets;
 import com.mojang.datafixers.util.Either;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
@@ -20,7 +19,7 @@ import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ObjectSet;
 import it.unimi.dsi.fastutil.objects.ObjectSortedSet;
-import java.util.Set;
+
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import javax.annotation.Nullable;
@@ -43,6 +42,11 @@ public abstract class ChunkMapDistance {
     private final LongSet l = new LongOpenHashSet();
     private final Executor m;
     private long currentTick;
+    //Paper start ticket level pp-view-dist
+    protected abstract com.destroystokyo.paper.util.PlayerTicketAreaMap getPlayerTicketAreaMap();
+    protected abstract void updatePlayerTicketAreaMap(EntityPlayer player, long pair);
+    protected abstract void removePlayerTicketAreaMap(EntityPlayer player);
+    //Paper end
 
     protected ChunkMapDistance(Executor executor, Executor executor1) {
         executor1.getClass();
@@ -234,6 +238,7 @@ public abstract class ChunkMapDistance {
         ((ObjectSet) this.c.computeIfAbsent(i, (j) -> {
             return new ObjectOpenHashSet();
         })).add(entityplayer);
+        this.updatePlayerTicketAreaMap(entityplayer, i); //Paper ticket level pp-view-dist
         this.f.b(i, 0, true);
         this.g.b(i, 0, true);
     }
@@ -251,6 +256,10 @@ public abstract class ChunkMapDistance {
 
     }
 
+    public void fullRemove(EntityPlayer player) {
+        this.removePlayerTicketAreaMap(player); //Paper ticket level pp-view-dist
+    }
+
     protected String c(long i) {
         ObjectSortedSet<Ticket<?>> objectsortedset = (ObjectSortedSet) this.tickets.get(i);
         String s;
@@ -278,6 +287,10 @@ public abstract class ChunkMapDistance {
         return this.f.a.containsKey(i);
     }
 
+    public boolean naturalSpawnChunksHave(long i) {
+        return this.f.a.containsKey(i); //Paper ticket level pp-view-dist
+    }
+
     public String c() {
         return this.i.a();
     }
@@ -372,20 +385,20 @@ public abstract class ChunkMapDistance {
                 byte b0 = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getByteValue();
                 long j = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getLongKey();
 
-                this.a(j, b0, this.c(b0), b0 <= i - 2);
+                this.a(j, b0, this.c(b0), b0 <= i - 2, i); //Paper ticket level pp-view-dist
             }
 
             this.e = i;
         }
 
-        private void a(long i, int j, boolean flag, boolean flag1) {
+        private void a(long i, int j, boolean flag, boolean flag1, int vd) { //Paper ticket level pp-view-dist
             if (flag != flag1) {
                 Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, ChunkMapDistance.b, new ChunkCoordIntPair(i), ChunkMapDistance.this.currentTick);
 
                 if (flag1) {
                     ChunkMapDistance.this.j.a(ChunkTaskQueueSorter.a(() -> { // Craftbukkit - decompile error
                         ChunkMapDistance.this.m.execute(() -> {
-                            if (this.c(this.c(i))) {
+                            if (this.c(i) <= vd) { //Paper ticket level pp-view-dist
                                 ChunkMapDistance.this.addTicket(i, ticket);
                                 ChunkMapDistance.this.l.add(i);
                             } else {
@@ -430,13 +443,46 @@ public abstract class ChunkMapDistance {
                             }
 
                         });
-                        this.a(i, k, this.c(j), this.c(k));
                     }
-                }
 
+                    //Paper start ticket level pp-view-dist
+                    //attach update queue to default queue
+                    byte action = ChunkMapDistance.this.getPlayerTicketAreaMap().removeUpdate(i);
+                    if(action == com.destroystokyo.paper.util.PlayerTicketAreaMap.ADD) {
+                        this.a(i, k, false, true, Integer.MAX_VALUE);
+                    } else if (action == com.destroystokyo.paper.util.PlayerTicketAreaMap.REMOVE) {
+                        this.a(i, k, true, false, Integer.MAX_VALUE);
+                    }
+                }
                 this.g.clear();
             }
 
+            /*
+              in the above update queue handling, we attach all updates to the default queue (before the midpoint)
+              below, we run all updates that the default queue does not handle (past the midpoint)
+
+              we must attach updates in this manner to maintain the integrity of the priority queue sorter/throttler by using default level values
+
+             */
+
+            if (!ChunkMapDistance.this.getPlayerTicketAreaMap().getUpdates().isEmpty()) {
+                ObjectIterator<it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry> updates = ChunkMapDistance.this.getPlayerTicketAreaMap().getUpdates().long2ByteEntrySet().iterator();
+
+                while(updates.hasNext()) {
+                    it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry e = updates.next();
+                    long chunkPair = e.getLongKey();
+                    byte action = e.getByteValue();
+                    if(action == com.destroystokyo.paper.util.PlayerTicketAreaMap.ADD) {
+                        this.a(chunkPair, this.c(chunkPair), false, true, Integer.MAX_VALUE);
+                    } else if (action == com.destroystokyo.paper.util.PlayerTicketAreaMap.REMOVE) {
+                        this.a(chunkPair, this.c(chunkPair), true, false, Integer.MAX_VALUE);
+                    }
+                }
+
+                ChunkMapDistance.this.getPlayerTicketAreaMap().clearUpdates();
+            }
+            //Paper end
+
         }
 
         private boolean c(int i) {
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index e7539dd79..f06be7b16 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -557,11 +557,10 @@ public class ChunkProviderServer extends IChunkProvider {
             EnumCreatureType[] aenumcreaturetype = EnumCreatureType.values();
             // Paper start - per player mob spawning
             int[] worldMobCount;
-            if (this.playerChunkMap.playerMobDistanceMap != null) {
+            //Paper start ticket level pp-view-dist
+            if (this.world.paperConfig.perPlayerMobSpawns) {
                 // update distance map
-                this.world.timings.playerMobDistanceMapUpdate.startTiming();
-                this.playerChunkMap.playerMobDistanceMap.update(this.world.players, this.playerChunkMap.viewDistance);
-                this.world.timings.playerMobDistanceMapUpdate.stopTiming();
+                //Paper end
                 // re-set mob counts
                 for (EntityPlayer player : this.world.players) {
                     Arrays.fill(player.mobCounts, 0);
@@ -641,8 +640,14 @@ public class ChunkProviderServer extends IChunkProvider {
 
                                     if (this.world.paperConfig.perPlayerMobSpawns) {
                                         int minDiff = Integer.MAX_VALUE;
-                                        for (EntityPlayer entityplayer : this.playerChunkMap.playerMobDistanceMap.getPlayersInRange(chunk.getPos())) {
-                                            minDiff = Math.min(limit - this.playerChunkMap.getMobCountNear(entityplayer, enumcreaturetype), minDiff);
+                                        //Paper start ticket level pp-view-dist
+                                        it.unimi.dsi.fastutil.objects.ObjectSet<EntityPlayer> players = this.playerChunkMap.playerTicketAreaMap.getPlayersTracking(chunk.getPos());
+                                        if(players != null) {
+                                            for (EntityPlayer entityplayer : players) {
+                                                if(entityplayer.isSpectator() || !entityplayer.affectsSpawning) continue;
+                                                //Paper end
+                                                minDiff = Math.min(limit - this.playerChunkMap.getMobCountNear(entityplayer, enumcreaturetype), minDiff);
+                                            }
                                         }
                                         difference = (minDiff == Integer.MAX_VALUE) ? 0 : minDiff;
                                     }
diff --git a/src/main/java/net/minecraft/server/EntityEnderDragon.java b/src/main/java/net/minecraft/server/EntityEnderDragon.java
index c8c74f2b3..6a84a1a58 100644
--- a/src/main/java/net/minecraft/server/EntityEnderDragon.java
+++ b/src/main/java/net/minecraft/server/EntityEnderDragon.java
@@ -570,9 +570,9 @@ public class EntityEnderDragon extends EntityInsentient implements IMonster {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1028, new BlockPosition(this), 0);
                 // Paper start
-                int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
+                //int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
-                    //final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = player.getTrackViewDistance() * 16; //Paper ticket level pp-view-dist
                     // Paper end
                     double deltaX = this.locX - player.locX;
                     double deltaZ = this.locZ - player.locZ;
diff --git a/src/main/java/net/minecraft/server/EntityHuman.java b/src/main/java/net/minecraft/server/EntityHuman.java
index cd73cde8d..9b9bc19a2 100644
--- a/src/main/java/net/minecraft/server/EntityHuman.java
+++ b/src/main/java/net/minecraft/server/EntityHuman.java
@@ -80,6 +80,38 @@ public abstract class EntityHuman extends EntityLiving {
     public String spawnWorld = "";
     public int oldLevel = -1;
 
+    //Paper start ticket level pp-view-dist
+    private int viewDistance;
+    private int trackViewDistance;
+    public int lastViewDistance;
+    public int lastTrackViewDistance;
+    public int getViewDistance() { return this.viewDistance; }
+    public int getTicketViewDistance() { return this.viewDistance; }
+    public int getTrackViewDistance() { return this.trackViewDistance; }
+    public void setTrackViewDistance(int trackViewDistance) {
+        this.lastTrackViewDistance = this.trackViewDistance;
+        this.trackViewDistance = MathHelper.clamp(trackViewDistance, this.viewDistance, 33);
+        if(this.lastTrackViewDistance != this.trackViewDistance) this.updateViewDistancePackets();
+    }
+    public void setTicketViewDistance(int ticketViewDistance) {
+        this.lastViewDistance = this.viewDistance;
+        this.viewDistance = MathHelper.clamp(ticketViewDistance, 3, this.trackViewDistance);
+    }
+    public void setViewDistance(int viewDistance) {
+        this.lastViewDistance = this.viewDistance;
+        this.viewDistance = MathHelper.clamp(viewDistance, 3, 33);
+        this.setTrackViewDistance(viewDistance);
+    }
+    public void updateViewDistancePackets() {
+        if(this instanceof EntityPlayer) {
+            if(((EntityPlayer) this).playerConnection != null) {
+                ((EntityPlayer) this).playerConnection.sendPacket(new PacketPlayOutViewDistance(this.trackViewDistance));
+                ((WorldServer) this.world).getChunkProvider().playerChunkMap.updateTrackViewDistance((EntityPlayer) this, this.trackViewDistance);
+            }
+        }
+    }
+    //Paper end
+
     @Override
     public CraftHumanEntity getBukkitEntity() {
         return (CraftHumanEntity) super.getBukkitEntity();
@@ -98,6 +130,7 @@ public abstract class EntityHuman extends EntityLiving {
 
         this.setPositionRotation((double) blockposition.getX() + 0.5D, (double) (blockposition.getY() + 1), (double) blockposition.getZ() + 0.5D, 0.0F, 0.0F);
         this.aX = 180.0F;
+        this.setViewDistance(this.world.spigotConfig.viewDistance); //Paper ticket level pp-view-dist
     }
 
     public boolean a(World world, BlockPosition blockposition, EnumGamemode enumgamemode) {
diff --git a/src/main/java/net/minecraft/server/EntityLightning.java b/src/main/java/net/minecraft/server/EntityLightning.java
index 27bf271bb..7580f1da6 100644
--- a/src/main/java/net/minecraft/server/EntityLightning.java
+++ b/src/main/java/net/minecraft/server/EntityLightning.java
@@ -59,8 +59,9 @@ public class EntityLightning extends Entity {
             // CraftBukkit start - Use relative location for far away sounds
             // this.world.playSound((EntityHuman) null, this.locX, this.locY, this.locZ, SoundEffects.ENTITY_LIGHTNING_BOLT_THUNDER, SoundCategory.WEATHER, 10000.0F, 0.8F + this.random.nextFloat() * 0.2F);
             float pitch = 0.8F + this.random.nextFloat() * 0.2F;
-            int viewDistance = ((WorldServer) this.world).getServer().getViewDistance() * 16;
+            //int viewDistance = ((WorldServer) this.world).getServer().getViewDistance() * 16;
             for (EntityPlayer player : (List<EntityPlayer>) (List) this.world.getPlayers()) {
+                int viewDistance = player.getTrackViewDistance() * 16; //Paper ticket level pp-view-dist
                 double deltaX = this.locX - player.locX;
                 double deltaZ = this.locZ - player.locZ;
                 double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/server/EntityWither.java b/src/main/java/net/minecraft/server/EntityWither.java
index 8b3052b11..dc2ff9482 100644
--- a/src/main/java/net/minecraft/server/EntityWither.java
+++ b/src/main/java/net/minecraft/server/EntityWither.java
@@ -208,9 +208,9 @@ public class EntityWither extends EntityMonster implements IRangedEntity {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1023, new BlockPosition(this), 0);
                 // Paper start
-                int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
+                //int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
-                    //final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = player.getTrackViewDistance() * 16; //Paper ticket level pp-view-dist
                     // Paper end
                     double deltaX = this.locX - player.locX;
                     double deltaZ = this.locZ - player.locZ;
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index 34d0ab0d5..47592917f 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -103,6 +103,27 @@ public class PlayerChunk {
         return this.entityTickingFuture;
     }
 
+    //Paper start ticket level pp-view-dist
+    public CompletableFuture<Either<Chunk, PlayerChunk.Failure>> getEntityTickingChunkFuture() { return this.b(); } //Paper OBFHELPER
+    public CompletableFuture<Either<Chunk, PlayerChunk.Failure>> getTickingChunkFuture() { return this.a(); } //Paper OBFHELPER
+
+    @Nullable
+    public Chunk getEntityTickingChunk() {
+        CompletableFuture<Either<Chunk, PlayerChunk.Failure>> completablefuture = this.getEntityTickingChunkFuture();
+        Either<Chunk, PlayerChunk.Failure> either = completablefuture.getNow(null);
+
+        return either == null ? null : either.left().orElse(null);
+    }
+
+    @Nullable
+    public Chunk getTickingChunk() {
+        CompletableFuture<Either<Chunk, PlayerChunk.Failure>> completablefuture = this.getTickingChunkFuture();
+        Either<Chunk, PlayerChunk.Failure> either = completablefuture.getNow(null);
+
+        return either == null ? null : either.left().orElse(null);
+    }
+    //Paper end
+
     public CompletableFuture<Either<Chunk, PlayerChunk.Failure>> c() {
         return this.fullChunkFuture;
     }
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 59e74900f..380159b0f 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -4,10 +4,7 @@ import co.aikar.timings.Timing; // Paper
 import com.destroystokyo.paper.PaperWorldConfig; // Paper
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.ComparisonChain; // Paper
 import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
-import com.google.common.collect.Sets;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Either;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
@@ -22,7 +19,6 @@ import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import java.io.File;
 import java.io.IOException;
 import java.io.Writer;
-import java.util.ArrayList;
 import java.util.HashMap; // Paper
 import java.util.Iterator;
 import java.util.List;
@@ -78,7 +74,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     public final Int2ObjectMap<PlayerChunkMap.EntityTracker> trackedEntities;
     private final Queue<Runnable> A;
     int viewDistance; // Paper - private -> package private
-    public final com.destroystokyo.paper.util.PlayerMobDistanceMap playerMobDistanceMap; // Paper
+    //public final com.destroystokyo.paper.util.PlayerMobDistanceMap playerMobDistanceMap; // Paper replaced with player ticket area map
+    public final com.destroystokyo.paper.util.PlayerTicketAreaMap playerTicketAreaMap; //Paper ticket level pp-view-dist
 
     // CraftBukkit start - recursion-safe executor for Chunk loadCallback() and unloadCallback()
     public final CallbackExecutor callbackExecutor = new CallbackExecutor();
@@ -136,7 +133,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         this.m = supplier;
         this.n = new VillagePlace(new File(this.x, "poi"), datafixer, this.world); // Paper
         this.setViewDistance(i);
-        this.playerMobDistanceMap = this.world.paperConfig.perPlayerMobSpawns ? new com.destroystokyo.paper.util.PlayerMobDistanceMap() : null; // Paper
+        //this.playerMobDistanceMap = this.world.paperConfig.perPlayerMobSpawns ? new com.destroystokyo.paper.util.PlayerMobDistanceMap() : null; // Paper replaced with player ticket area map
+        this.playerTicketAreaMap = new com.destroystokyo.paper.util.PlayerTicketAreaMap(); //Paper ticket level pp-view-dist
     }
 
     public void updatePlayerMobTypeMap(Entity entity) {
@@ -147,8 +145,14 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         int chunkZ = (int)Math.floor(entity.locZ) >> 4;
         int index = entity.getEntityType().getEnumCreatureType().ordinal();
 
-        for (EntityPlayer player : this.playerMobDistanceMap.getPlayersInRange(chunkX, chunkZ)) {
-            ++player.mobCounts[index];
+        //Paper start ticket level pp-view-dist
+        it.unimi.dsi.fastutil.objects.ObjectSet<EntityPlayer> players = this.playerTicketAreaMap.getPlayersTracking(chunkX, chunkZ);
+        if(players != null) {
+            for (EntityPlayer player : players) {
+                if(player.isSpectator() || !player.affectsSpawning) continue;
+                //Paper end
+                ++player.mobCounts[index];
+            }
         }
     }
 
@@ -935,30 +939,33 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     protected void setViewDistance(int i) {
         int j = MathHelper.clamp(i + 1, 3, 33);
+        //Paper start ticket level pp-view-dist
+        this.chunkDistanceManager.a(j);
+        this.viewDistance = j;
 
-        if (j != this.viewDistance) {
-            int k = this.viewDistance;
-
-            this.viewDistance = j;
-            this.chunkDistanceManager.a(this.viewDistance);
-            ObjectIterator objectiterator = this.updatingChunks.values().iterator();
+        if(this.world.players != null && !this.world.players.isEmpty()) {
+            for (EntityPlayer player : this.world.players) {
+                player.setViewDistance(j);
+            }
+        }
+        //Paper end
+    }
 
-            while (objectiterator.hasNext()) {
-                PlayerChunk playerchunk = (PlayerChunk) objectiterator.next();
-                ChunkCoordIntPair chunkcoordintpair = playerchunk.i();
+    //Paper start ticket level pp-view-dist
+    public void updateTrackViewDistance(EntityPlayer player, int i) {
+        for (int x = player.chunkX - i; x <= player.chunkX + i; ++x) {
+            for (int z = player.chunkZ - i; z <= player.chunkZ + i; ++z) {
+                ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(x, z);
                 Packet<?>[] apacket = new Packet[2];
+                int i1 = b(chunkcoordintpair, player, true);
+                boolean flag = i1 <= player.lastTrackViewDistance;
+                boolean flag1 = i1 <= i;
 
-                this.a(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    int l = b(chunkcoordintpair, entityplayer, true);
-                    boolean flag = l <= k;
-                    boolean flag1 = l <= this.viewDistance;
-
-                    this.sendChunk(entityplayer, chunkcoordintpair, apacket, flag, flag1);
-                });
+                this.sendChunk(player, chunkcoordintpair, apacket, flag, flag1);
             }
         }
-
     }
+    //Paper end
 
     protected void sendChunk(EntityPlayer entityplayer, ChunkCoordIntPair chunkcoordintpair, Packet<?>[] apacket, boolean flag, boolean flag1) {
         if (entityplayer.world == this.world) {
@@ -966,10 +973,13 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 PlayerChunk playerchunk = this.getVisibleChunk(chunkcoordintpair.pair());
 
                 if (playerchunk != null) {
-                    Chunk chunk = playerchunk.getChunk();
+                    Chunk chunk = playerchunk.getTickingChunk(); //for clarification
 
                     if (chunk != null) {
                         this.a(entityplayer, apacket, chunk);
+                    } else {
+                        //send unload for non ticking chunks (> 32)
+                        entityplayer.a(chunkcoordintpair); //Paper ticket level pp-view-dist
                     }
 
                     PacketDebug.a(this.world, chunkcoordintpair);
@@ -1201,29 +1211,38 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     boolean isOutsideOfRange(ChunkCoordIntPair chunkcoordintpair, boolean reducedRange) {
-        int chunkRange = world.spigotConfig.mobSpawnRange;
-        chunkRange = (chunkRange > world.spigotConfig.viewDistance) ? (byte) world.spigotConfig.viewDistance : chunkRange;
-        chunkRange = (chunkRange > 8) ? 8 : chunkRange;
-
-        final int finalChunkRange = chunkRange; // Paper for lambda below
         //double blockRange = (reducedRange) ? Math.pow(chunkRange << 4, 2) : 16384.0D; // Paper - use from event
         // Spigot end
         long i = chunkcoordintpair.pair();
-
-        return !this.chunkDistanceManager.d(i) ? true : this.playerMap.a(i).noneMatch((entityplayer) -> {
+        //Paper start ticket level pp-view-dist
+        it.unimi.dsi.fastutil.objects.ObjectSet<EntityPlayer> playerset = this.playerTicketAreaMap.getPlayersTracking(i);
+        if(playerset == null || playerset.isEmpty()) return true;
+        if(!this.chunkDistanceManager.naturalSpawnChunksHave(i)) return true;
+
+        it.unimi.dsi.fastutil.objects.ObjectIterator<EntityPlayer> players = playerset.iterator();
+
+        while(players.hasNext()) {
+            EntityPlayer entityplayer = players.next();
+            int playerChunkRange = world.spigotConfig.mobSpawnRange;
+            playerChunkRange = (playerChunkRange > entityplayer.getTrackViewDistance()) ? (byte) entityplayer.getTrackViewDistance() : playerChunkRange;
+            playerChunkRange = (playerChunkRange > 8) ? 8 : playerChunkRange;
             // Paper start -
             com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent event;
             double blockRange = 16384.0D;
             if (reducedRange) {
-                event = new com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent(entityplayer.getBukkitEntity(), (byte) finalChunkRange);
+                event = new com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent(entityplayer.getBukkitEntity(), (byte) playerChunkRange); //Paper ticket level pp-view-dist
                 event.callEvent();
                 blockRange = (double) ((event.getSpawnRadius() << 4) * (event.getSpawnRadius() << 4));
                 if (event.isCancelled()) return true;
             }
 
-            return (!entityplayer.isSpectator() && a(chunkcoordintpair, (Entity) entityplayer) < blockRange); // Spigot
-            // Paper end
-        });
+            if(!entityplayer.isSpectator() && a(chunkcoordintpair, (Entity) entityplayer) < blockRange) {
+                return false; // Spigot
+            }
+            //Paper end
+        }
+        return true;
+        //Paper end
     }
 
     private boolean b(EntityPlayer entityplayer) {
@@ -1251,8 +1270,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             }
         }
 
-        for (int k = i - this.viewDistance; k <= i + this.viewDistance; ++k) {
-            for (int l = j - this.viewDistance; l <= j + this.viewDistance; ++l) {
+        //Paper start ticket level pp-view-dist
+        int playerViewDistance = entityplayer.getTrackViewDistance();
+        for (int k = i - playerViewDistance; k <= i + playerViewDistance; ++k) {
+            for (int l = j - playerViewDistance; l <= j + playerViewDistance; ++l) {
+                //Paper end
                 ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k, l);
 
                 this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], !flag, flag);
@@ -1320,18 +1342,20 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         int k1;
         int l1;
 
-        if (Math.abs(i1 - i) <= this.viewDistance * 2 && Math.abs(j1 - j) <= this.viewDistance * 2) {
-            k1 = Math.min(i, i1) - this.viewDistance;
-            l1 = Math.min(j, j1) - this.viewDistance;
-            int i2 = Math.max(i, i1) + this.viewDistance;
-            int j2 = Math.max(j, j1) + this.viewDistance;
+        //Paper start ticket level pp-view-dist
+        int playerViewDistance = entityplayer.getTrackViewDistance();
+        if (Math.abs(i1 - i) <= playerViewDistance * 2 && Math.abs(j1 - j) <= playerViewDistance * 2) {
+            k1 = Math.min(i, i1) - playerViewDistance;
+            l1 = Math.min(j, j1) - playerViewDistance;
+            int i2 = Math.max(i, i1) + playerViewDistance;
+            int j2 = Math.max(j, j1) + playerViewDistance;
 
             for (int k2 = k1; k2 <= i2; ++k2) {
                 for (int l2 = l1; l2 <= j2; ++l2) {
                     ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k2, l2);
-                    boolean flag3 = a(chunkcoordintpair, i1, j1) <= this.viewDistance;
-                    boolean flag4 = a(chunkcoordintpair, i, j) <= this.viewDistance;
-
+                    boolean flag3 = a(chunkcoordintpair, i1, j1) <= playerViewDistance;
+                    boolean flag4 = a(chunkcoordintpair, i, j) <= playerViewDistance;
+                    //Paper end
                     this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], flag3, flag4);
                 }
             }
@@ -1340,8 +1364,10 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             boolean flag5;
             boolean flag6;
 
-            for (k1 = i1 - this.viewDistance; k1 <= i1 + this.viewDistance; ++k1) {
-                for (l1 = j1 - this.viewDistance; l1 <= j1 + this.viewDistance; ++l1) {
+            //Paper start ticket level pp-view-dist
+            for (k1 = i1 - playerViewDistance; k1 <= i1 + playerViewDistance; ++k1) {
+                for (l1 = j1 - playerViewDistance; l1 <= j1 + playerViewDistance; ++l1) {
+                    //Paper end
                     chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
                     flag5 = true;
                     flag6 = false;
@@ -1349,8 +1375,10 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 }
             }
 
-            for (k1 = i - this.viewDistance; k1 <= i + this.viewDistance; ++k1) {
-                for (l1 = j - this.viewDistance; l1 <= j + this.viewDistance; ++l1) {
+            //Paper start ticket level pp-view-dist
+            for (k1 = i - playerViewDistance; k1 <= i + playerViewDistance; ++k1) {
+                for (l1 = j - playerViewDistance; l1 <= j + playerViewDistance; ++l1) {
+                    //Paper end
                     chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
                     flag5 = false;
                     flag6 = true;
@@ -1365,8 +1393,12 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     public Stream<EntityPlayer> a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
         return this.playerMap.a(chunkcoordintpair.pair()).filter((entityplayer) -> {
             int i = b(chunkcoordintpair, entityplayer, true);
-
-            return i > this.viewDistance ? false : !flag || i == this.viewDistance;
+            //Paper start ticket level pp-view-dist
+            PlayerChunk playerchunk = this.getVisibleChunk(chunkcoordintpair.pair());
+            //check ticking chunk
+            if(playerchunk == null || playerchunk.getTickingChunk() == null) return false;
+            return i > entityplayer.getTrackViewDistance() ? false : !flag || i == entityplayer.getTrackViewDistance();
+            //Paper end
         });
     }
 
@@ -1411,7 +1443,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         org.spigotmc.AsyncCatcher.catchOp("entity untrack"); // Spigot
         if (entity instanceof EntityPlayer) {
             EntityPlayer entityplayer = (EntityPlayer) entity;
-
+            this.chunkDistanceManager.fullRemove((EntityPlayer) entity); //Paper ticket level pp-view-dist
             this.a(entityplayer, false);
             ObjectIterator objectiterator = this.trackedEntities.values().iterator();
 
@@ -1616,19 +1648,20 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
             if (entityplayer != this.tracker) {
                 Vec3D vec3d = (new Vec3D(entityplayer.locX, entityplayer.locY, entityplayer.locZ)).d(this.tracker.getPositionVector()); // MC-155077, SPIGOT-5113
-                int i = Math.min(this.trackingDistance, (PlayerChunkMap.this.viewDistance - 1) * 16);
+                //Paper start ticket level pp-view-dist
+                int i = Math.min(this.trackingDistance, (entityplayer.getTrackViewDistance() - 1) * 16);
                 boolean flag = vec3d.x >= (double) (-i) && vec3d.x <= (double) i && vec3d.z >= (double) (-i) && vec3d.z <= (double) i && this.tracker.a(entityplayer);
+                ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(this.tracker.chunkX, this.tracker.chunkZ);
+                PlayerChunk playerchunk = PlayerChunkMap.this.getVisibleChunk(chunkcoordintpair.pair());
+                //untrack if chunk is not entity ticking,
+                //as the default tracking range check - 1 only operates correctly when all view distances are equal and constant
 
-                if (flag) {
+                if (flag && playerchunk != null && (playerchunk.getEntityTickingChunk() != null)) {
                     boolean flag1 = this.tracker.attachedToPlayer;
 
                     if (!flag1) {
-                        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(this.tracker.chunkX, this.tracker.chunkZ);
-                        PlayerChunk playerchunk = PlayerChunkMap.this.getVisibleChunk(chunkcoordintpair.pair());
-
-                        if (playerchunk != null && playerchunk.getChunk() != null) {
-                            flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= PlayerChunkMap.this.viewDistance;
-                        }
+                        flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= entityplayer.getTrackViewDistance();
+                        //Paper end
                     }
 
                     // CraftBukkit start - respect vanish API
@@ -1666,6 +1699,27 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     class a extends ChunkMapDistance {
 
+        //Paper start ticket level pp-view-dist
+        @Override
+        protected com.destroystokyo.paper.util.PlayerTicketAreaMap getPlayerTicketAreaMap() {
+            return PlayerChunkMap.this.playerTicketAreaMap;
+        }
+
+        @Override
+        protected void updatePlayerTicketAreaMap(EntityPlayer player, long pair) {
+            try(co.aikar.timings.Timing ignored = PlayerChunkMap.this.world.timings.playerTicketAreaMapUpdate.startTiming()) {
+                PlayerChunkMap.this.playerTicketAreaMap.updatePlayer(player, pair);
+            }
+        }
+
+        @Override
+        protected void removePlayerTicketAreaMap(EntityPlayer player) {
+            try(co.aikar.timings.Timing ignored = PlayerChunkMap.this.world.timings.playerTicketAreaMapRemove.startTiming()) {
+                PlayerChunkMap.this.playerTicketAreaMap.removePlayer(player);
+            }
+        }
+        //Paper end
+
         protected a(Executor executor, Executor executor1) {
             super(executor, executor1);
         }
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 3cb443c4f..476da855d 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -155,7 +155,7 @@ public abstract class PlayerList {
 
         // CraftBukkit - getType()
         // Spigot - view distance
-        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), worldserver.spigotConfig.viewDistance, worldserver.getGameRules().getBoolean(GameRules.REDUCED_DEBUG_INFO)));
+        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), entityplayer.getTrackViewDistance(), worldserver.getGameRules().getBoolean(GameRules.REDUCED_DEBUG_INFO))); //Paper ticket level pp-view-dist
         entityplayer.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.sendPacket(new PacketPlayOutCustomPayload(PacketPlayOutCustomPayload.a, (new PacketDataSerializer(Unpooled.buffer())).a(this.getServer().getServerModName())));
         playerconnection.sendPacket(new PacketPlayOutServerDifficulty(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
@@ -699,7 +699,7 @@ public abstract class PlayerList {
         WorldData worlddata = worldserver.getWorldData();
 
         entityplayer1.playerConnection.sendPacket(new PacketPlayOutRespawn(worldserver.worldProvider.getDimensionManager().getType(), worldserver.getWorldData().getType(), entityplayer1.playerInteractManager.getGameMode()));
-        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(worldserver.spigotConfig.viewDistance)); // Spigot
+        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(entityplayer1.getTrackViewDistance())); // Spigot //Paper ticket level pp-view-dist
         entityplayer1.spawnIn(worldserver);
         entityplayer1.dead = false;
         entityplayer1.playerConnection.teleport(new Location(worldserver.getWorld(), entityplayer1.locX, entityplayer1.locY, entityplayer1.locZ, entityplayer1.yaw, entityplayer1.pitch));
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index e920545df..6c05f0be5 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1986,12 +1986,28 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public int getViewDistance() {
-        throw new NotImplementedException("Per-Player View Distance APIs need further understanding to properly implement"); // TODO
+        return getHandle().getViewDistance(); //Paper ticket level pp-view-dist
     }
 
     @Override
     public void setViewDistance(int viewDistance) {
-        throw new NotImplementedException("Per-Player View Distance APIs need further understanding to properly implement"); // TODO
+        getHandle().setViewDistance(viewDistance); //Paper ticket level pp-view-dist
+    }
+
+    public void setTicketViewDistance(int ticketViewDistance) {
+        getHandle().setTicketViewDistance(ticketViewDistance); //Paper ticket level pp-view-dist
+    }
+
+    public int getTrackViewDistance() {
+        return getHandle().getTrackViewDistance(); //Paper ticket level pp-view-dist
+    }
+
+    public int getTicketViewDistance() {
+        return getHandle().getTicketViewDistance(); //Paper ticket level pp-view-dist
+    }
+
+    public void setTrackViewDistance(int trackViewDistance) {
+        getHandle().setTrackViewDistance(trackViewDistance); //Paper ticket level pp-view-dist
     }
     //Paper end
 
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index 92601c581..84fc6bfc4 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -122,13 +122,14 @@ public class ActivationRange
         int maxRange = Math.max( monsterActivationRange, animalActivationRange );
         maxRange = Math.max( maxRange, raiderActivationRange );
         maxRange = Math.max( maxRange, miscActivationRange );
-        maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange );
+        //maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange ); //Paper ticket level pp-view-dist
 
         for ( EntityHuman player : world.getPlayers() )
         {
 
+            int playerMaxRange = maxRange = Math.min( ( player.getTrackViewDistance() << 4 ) - 8, maxRange ); //Paper ticket level pp-view-dist
             player.activatedTick = MinecraftServer.currentTick;
-            maxBB = player.getBoundingBox().grow( maxRange, 256, maxRange );
+            maxBB = player.getBoundingBox().grow( playerMaxRange, 256, playerMaxRange ); //Paper ticket level pp-view-dist
             ActivationType.MISC.boundingBox = player.getBoundingBox().grow( miscActivationRange, 256, miscActivationRange );
             ActivationType.RAIDER.boundingBox = player.getBoundingBox().grow( raiderActivationRange, 256, raiderActivationRange );
             ActivationType.ANIMAL.boundingBox = player.getBoundingBox().grow( animalActivationRange, 256, animalActivationRange );
-- 
2.20.1.windows.1

