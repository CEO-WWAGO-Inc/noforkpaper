From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Mon, 17 Oct 2022 18:00:40 -0400
Subject: [PATCH] Paper Item API


diff --git a/build.gradle.kts b/build.gradle.kts
index 9f5694204091e23c4771657127a06f98e27ad8f1..5fbedbdff32c43e9f2a89995eed6c406c3151890 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -31,6 +31,7 @@ dependencies {
     api("com.googlecode.json-simple:json-simple:1.1.1") {
         isTransitive = false // includes junit
     }
+    api("io.leangen.geantyref:geantyref:1.3.13") // Paper
     api("it.unimi.dsi:fastutil:8.5.6")
     apiAndDocs(platform("net.kyori:adventure-bom:$adventureVersion"))
     apiAndDocs("net.kyori:adventure-api")
diff --git a/src/main/java/io/papermc/paper/inventory/item/ItemStack.java b/src/main/java/io/papermc/paper/inventory/item/ItemStack.java
new file mode 100644
index 0000000000000000000000000000000000000000..14f562309433091198f1a8baf166d840507eff66
--- /dev/null
+++ b/src/main/java/io/papermc/paper/inventory/item/ItemStack.java
@@ -0,0 +1,106 @@
+package io.papermc.paper.inventory.item;
+
+import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableMap;
+import net.kyori.adventure.text.event.HoverEvent;
+import net.kyori.adventure.text.event.HoverEventSource;
+import net.kyori.adventure.translation.Translatable;
+import org.bukkit.Bukkit;
+import org.bukkit.Material;
+import org.bukkit.enchantments.Enchantment;
+import org.bukkit.inventory.meta.ItemMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Map;
+
+public interface ItemStack extends HoverEventSource<HoverEvent.ShowItem>, Translatable, Cloneable {
+
+    @NotNull
+    Material getMaterial();
+
+    // This is behavior that is not officially supported anymore, and shouldn't be either.
+    @Deprecated
+    void setMaterial(@NotNull Material material);
+
+    int getSize();
+
+    void setSize(int size);
+
+    @Nullable
+    ItemMeta getMeta();
+
+    void setMeta(@Nullable ItemMeta meta);
+
+    // Enchantment Utilities
+    default boolean containsEnchantment(@NotNull Enchantment ench) {
+        ItemMeta meta = this.getMeta();
+
+        return meta != null && meta.hasEnchant(ench);
+    }
+
+    default int getEnchantmentLevel(@NotNull Enchantment ench) {
+        ItemMeta meta = this.getMeta();
+        return meta == null ? 0 : meta.getEnchantLevel(ench);
+    }
+
+    default Map<Enchantment, Integer> getEnchantments() {
+        ItemMeta meta = this.getMeta();
+        return meta == null ? ImmutableMap.of() : meta.getEnchants();
+    }
+
+    default void addEnchantments(@NotNull Map<Enchantment, Integer> enchantments) {
+        Preconditions.checkArgument(enchantments != null, "Enchantments cannot be null");
+        for (Map.Entry<Enchantment, Integer> entry : enchantments.entrySet()) {
+            this.addEnchantment(entry.getKey(), entry.getValue());
+        }
+    }
+
+    default void addEnchantment(@NotNull Enchantment ench, int level) {
+        Preconditions.checkArgument(ench != null, "Enchantment cannot be null");
+        if ((level < ench.getStartLevel()) || (level > ench.getMaxLevel())) {
+            throw new IllegalArgumentException("Enchantment level is either too low or too high (given " + level + ", bounds are " + ench.getStartLevel() + " to " + ench.getMaxLevel() + ")");
+        } else if (!ench.canEnchantItem(this)) {
+            throw new IllegalArgumentException("Specified enchantment cannot be applied to this itemstack");
+        }
+
+        this.addUnsafeEnchantment(ench, level);
+    }
+
+    default void addUnsafeEnchantments(@NotNull Map<Enchantment, Integer> enchantments) {
+        for (Map.Entry<Enchantment, Integer> entry : enchantments.entrySet()) {
+            addUnsafeEnchantment(entry.getKey(), entry.getValue());
+        }
+    }
+
+    default void addUnsafeEnchantment(@NotNull Enchantment ench, int level) {
+        ItemMeta itemMeta = this.getMeta();
+        //ItemMeta itemMeta = (meta == null ? meta = Bukkit.getItemFactory().getItemMeta(type) : meta); TODO: WHY?
+        if (itemMeta != null) {
+            itemMeta.addEnchant(ench, level, true);
+        }
+    }
+
+    default int removeEnchantment(@NotNull Enchantment ench) {
+        int level = getEnchantmentLevel(ench);
+        ItemMeta meta = this.getMeta();
+        if (level == 0 || meta == null) {
+            return level;
+        }
+        meta.removeEnchant(ench);
+        return level;
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * This is not the same as getting the translation key
+     * for the material of this itemstack.
+     */
+    @Override
+    default @NotNull String translationKey() {
+        return Bukkit.getUnsafe().getTranslationKey(this);
+    }
+
+
+}
diff --git a/src/main/java/io/papermc/paper/inventory/item/property/EnchantmentMap.java b/src/main/java/io/papermc/paper/inventory/item/property/EnchantmentMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..f97b6ea6e324d018225a4000a9e3c0e5d5617be5
--- /dev/null
+++ b/src/main/java/io/papermc/paper/inventory/item/property/EnchantmentMap.java
@@ -0,0 +1,13 @@
+package io.papermc.paper.inventory.item.property;
+
+import org.bukkit.enchantments.Enchantment;
+
+import java.util.Map;
+
+public interface EnchantmentMap {
+
+    Map<Enchantment, Integer> getMap();
+
+    // utilities?
+
+}
diff --git a/src/main/java/io/papermc/paper/inventory/item/property/ItemProperties.java b/src/main/java/io/papermc/paper/inventory/item/property/ItemProperties.java
new file mode 100644
index 0000000000000000000000000000000000000000..0f1ccd4862275421ef14d5dd3ce5fff7038d0444
--- /dev/null
+++ b/src/main/java/io/papermc/paper/inventory/item/property/ItemProperties.java
@@ -0,0 +1,29 @@
+package io.papermc.paper.inventory.item.property;
+
+import io.leangen.geantyref.TypeToken;
+import io.papermc.paper.property.TagHolder;
+import io.papermc.paper.property.TagProperty;
+import net.kyori.adventure.text.Component;
+
+import java.util.List;
+
+public interface ItemProperties {
+
+    // COMMON
+    TagProperty<EnchantmentMap> ENCHANTMENTS = TagProperty.of("Enchantments", TypeToken.get(EnchantmentMap.class));
+    TagProperty<Boolean> TAG_UNBREAKABLE = TagProperty.of("Unbreakable", TypeToken.get(Boolean.class));
+    TagProperty<> TAG_CAN_DESTROY_BLOCK_LIST = TagProperty.of("CanDestroy", );
+    TagProperty TAG_CAN_PLACE_ON_BLOCK_LIST = TagProperty.of("CanPlaceOn", );
+    TagProperty TAG_HIDE_FLAGS = TagProperty.of("HideFlags", );
+
+    ItemProperty TAG_REPAIR_COST = ItemProperty.of("RepairCost", );
+
+
+    // DISPLAY PROPERTIES
+    TagProperty<TagHolder> DISPLAY = TagProperty.of("display", TypeToken.get(TagHolder.class));
+
+    TagProperty<Component> TAG_DISPLAY_NAME = TagProperty.of("Name", TypeToken.get(Component.class));
+    TagProperty<List<Component>> TAG_LORE = TagProperty.of("Lore", new TypeToken<>() {});
+
+
+}
diff --git a/src/main/java/io/papermc/paper/property/TagHolder.java b/src/main/java/io/papermc/paper/property/TagHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..3ff0c020022c363bccdb848c7ee5e6cbad4c97c1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/TagHolder.java
@@ -0,0 +1,9 @@
+package io.papermc.paper.property;
+
+public interface TagHolder {
+
+    <T> T getTagValue(TagProperty<T> property);
+
+    <T> void setTagValue(TagProperty<T> property, T value);
+
+}
diff --git a/src/main/java/io/papermc/paper/property/TagProperty.java b/src/main/java/io/papermc/paper/property/TagProperty.java
new file mode 100644
index 0000000000000000000000000000000000000000..eaa435bce8cbc0500fed5f02a4bb06887670a7a5
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/TagProperty.java
@@ -0,0 +1,11 @@
+package io.papermc.paper.property;
+
+import io.leangen.geantyref.TypeToken;
+
+public record TagProperty<T>(String name, TypeToken<T> value) {
+
+    public static <T> TagProperty<T> of(String name, TypeToken<T> clazz) {
+        return new TagProperty<>(name, clazz);
+    }
+
+}
diff --git a/src/main/java/org/bukkit/UnsafeValues.java b/src/main/java/org/bukkit/UnsafeValues.java
index 88acc4d2bd56748630840dc9f1c2cb253711eb38..e7e4e716036dfb1f962715902876ee6580a6061b 100644
--- a/src/main/java/org/bukkit/UnsafeValues.java
+++ b/src/main/java/org/bukkit/UnsafeValues.java
@@ -147,7 +147,7 @@ public interface UnsafeValues {
      * locale when using a {@link net.kyori.adventure.text.TranslatableComponent}.<br>
      * @return the translation key
      */
-    String getTranslationKey(ItemStack itemStack);
+    String getTranslationKey(io.papermc.paper.inventory.item.ItemStack itemStack);
 
     /**
      * Creates and returns the next EntityId available.
diff --git a/src/main/java/org/bukkit/enchantments/Enchantment.java b/src/main/java/org/bukkit/enchantments/Enchantment.java
index 69a048eb4e48c92db70c3d6b6aa4ae96326b9705..313de77f43eadd8503b553a3e863ebefb72bb9f6 100644
--- a/src/main/java/org/bukkit/enchantments/Enchantment.java
+++ b/src/main/java/org/bukkit/enchantments/Enchantment.java
@@ -294,7 +294,7 @@ public abstract class Enchantment implements Keyed, net.kyori.adventure.translat
      * @param item Item to test
      * @return True if the enchantment may be applied, otherwise False
      */
-    public abstract boolean canEnchantItem(@NotNull ItemStack item);
+    public abstract boolean canEnchantItem(@NotNull io.papermc.paper.inventory.item.ItemStack item); // Paper
     // Paper start
     /**
      * Get the name of the enchantment with its applied level.
diff --git a/src/main/java/org/bukkit/inventory/ItemStack.java b/src/main/java/org/bukkit/inventory/ItemStack.java
index b8a344fd900dcbd4b28085a54b85b16c742e9c6f..035458e01ba1de41fb52feda46159e59e68efabd 100644
--- a/src/main/java/org/bukkit/inventory/ItemStack.java
+++ b/src/main/java/org/bukkit/inventory/ItemStack.java
@@ -24,7 +24,7 @@ import org.jetbrains.annotations.Nullable;
  * use this class to encapsulate Materials for which {@link Material#isItem()}
  * returns false.</b>
  */
-public class ItemStack implements Cloneable, ConfigurationSerializable, net.kyori.adventure.text.event.HoverEventSource<net.kyori.adventure.text.event.HoverEvent.ShowItem>, net.kyori.adventure.translation.Translatable { // Paper
+public class ItemStack implements Cloneable, ConfigurationSerializable, net.kyori.adventure.text.event.HoverEventSource<net.kyori.adventure.text.event.HoverEvent.ShowItem>, net.kyori.adventure.translation.Translatable, io.papermc.paper.inventory.item.ItemStack { // Paper
     private Material type = Material.AIR;
     private int amount = 0;
     private MaterialData data = null;
@@ -977,5 +977,35 @@ public class ItemStack implements Cloneable, ConfigurationSerializable, net.kyor
     public boolean canRepair(@NotNull ItemStack toBeRepaired) {
         return Bukkit.getUnsafe().isValidRepairItemStack(toBeRepaired, this);
     }
+
+    @Override
+    public @NotNull Material getMaterial() {
+        return this.getType();
+    }
+
+    @Override
+    public void setMaterial(@NotNull Material material) {
+        this.setType(material);
+    }
+
+    @Override
+    public int getSize() {
+        return this.getAmount();
+    }
+
+    @Override
+    public void setSize(int size) {
+        this.setAmount(size);
+    }
+
+    @Override
+    public @Nullable ItemMeta getMeta() {
+        return this.getMeta();
+    }
+
+    @Override
+    public void setMeta(ItemMeta meta) {
+        this.setMeta(meta);
+    }
     // Paper end
 }
