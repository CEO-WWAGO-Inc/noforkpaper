From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: RyGuy <TheRealRyGuy@users.noreply.github.com>
Date: Tue, 21 Mar 2023 20:38:44 -0400
Subject: [PATCH] New specific event watching command


diff --git a/src/main/java/io/papermc/paper/command/PaperCommand.java b/src/main/java/io/papermc/paper/command/PaperCommand.java
index 652c7df2c783de56b947535ff25781b0af47fbf0..179378bc8ed71aa5590788d310ee04d02cad5649 100644
--- a/src/main/java/io/papermc/paper/command/PaperCommand.java
+++ b/src/main/java/io/papermc/paper/command/PaperCommand.java
@@ -46,6 +46,7 @@ public final class PaperCommand extends Command {
         commands.put(Set.of("mobcaps", "playermobcaps"), new MobcapsCommand());
         commands.put(Set.of("dumplisteners"), new DumpListenersCommand());
         commands.put(Set.of("dumpevents"), new EventVerboseCommand());
+        commands.put(Set.of("watchevent"), new EventWatcherCommand());
 
         return commands.entrySet().stream()
             .flatMap(entry -> entry.getKey().stream().map(s -> Map.entry(s, entry.getValue())))
diff --git a/src/main/java/io/papermc/paper/command/subcommands/EventVerboseCommand.java b/src/main/java/io/papermc/paper/command/subcommands/EventVerboseCommand.java
index 165bb5324aa06e4bd204a570b45b185b0bd11a84..f4ad22037f0f7dfac5e8bf357a27f1f184c3cf3f 100644
--- a/src/main/java/io/papermc/paper/command/subcommands/EventVerboseCommand.java
+++ b/src/main/java/io/papermc/paper/command/subcommands/EventVerboseCommand.java
@@ -127,11 +127,11 @@ public class EventVerboseCommand implements PaperSubcommand {
             this.event = event;
         }
 
-        @Nullable
         /**
          * Properly serialize our Wrapper into a JsonObject, so we can log it properly
          * @implNote Is null if the event has only final fields
          */
+        @Nullable
         private JsonObject serialize() {
             JsonObject parent = new JsonObject();
             parent.addProperty("timestamp", timestamp);
diff --git a/src/main/java/io/papermc/paper/command/subcommands/EventWatcherCommand.java b/src/main/java/io/papermc/paper/command/subcommands/EventWatcherCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..323596f65198f53c8c6cec200ee37723b78fb8f4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/subcommands/EventWatcherCommand.java
@@ -0,0 +1,151 @@
+package io.papermc.paper.command.subcommands;
+
+import com.google.common.collect.Lists;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.google.gson.internal.Streams;
+import com.google.gson.stream.JsonWriter;
+import io.papermc.paper.command.PaperSubcommand;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.CommandSender;
+import org.bukkit.event.Event;
+import org.bukkit.event.Listener;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.io.IOException;
+import java.io.PrintStream;
+import java.io.StringWriter;
+import java.lang.reflect.Field;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.time.LocalDateTime;
+import java.time.format.DateTimeFormatter;
+import java.util.*;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.GREEN;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+
+@DefaultQualifier(NonNull.class)
+public class EventWatcherCommand implements PaperSubcommand {
+
+    /**
+     * The key is the equivalent of {@link Class#getSimpleName()} on the class,
+     * and value is the file we're trying to log to
+     */
+    private static final List<Watcher> watching = Collections.synchronizedList(new ArrayList<>()); //only sync in the rare case that multiple people are debugging, should be unnecessary
+    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd_HH.mm.ss");
+
+
+    public static void tryLog(Event event, @Nullable Listener listener) { //listener should only be null on the initial event call
+        Optional<Watcher> watcher = watching.stream().filter(w -> w.eventPath.equals(event.getClass().getSimpleName())).findFirst();
+        watcher.ifPresent(value -> value.log(event, listener));
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String subCommand, String[] args) {
+        if(args.length < 1) {
+            sender.sendMessage(text("Invalid Usage! /paper watchevent [event path]", RED));
+            return true;
+        }
+        Optional<Watcher> watcherO = watching.stream().filter(w -> w.eventPath.equals(args[0])).findFirst();
+        if(watcherO.isPresent()) {
+            Watcher w = watcherO.get();
+            try {
+                w.dump();
+                sender.sendMessage(text("Successfully dumped event information to " + w.file, GREEN));
+            }catch(IOException ex) {
+                sender.sendMessage(text("Failed to dump event verbose! See the console for more info.", RED));
+                MinecraftServer.LOGGER.warn("Error occurred while creating event verbose files", ex);
+            }
+            watching.remove(w);
+        }else {
+            Path parent = Path.of("debug");
+            Path path = parent.resolve("event-" + args[0] + "-" + FORMATTER.format(LocalDateTime.now()) + ".txt");
+            try {
+                Files.createDirectories(parent);
+                Files.createFile(path);
+                watching.add(new Watcher(args[0], path));
+                sender.sendMessage(text("Now watching event " + args[0] + "!", GREEN));
+            } catch(IOException ex) {
+                sender.sendMessage(text("Failed to create logging files! See the console for more info.", RED));
+                MinecraftServer.LOGGER.warn("Error occurred while creating event verbose files", ex);
+            }
+        }
+        return true;
+    }
+
+    /**
+     * A wrapper class for readability, essentially just handles storage of every Event we're watching for as well as
+     * that events verbose, and it's relevant file to store it
+     */
+    private static class Watcher {
+        private final String eventPath;
+        private final Path file;
+        private final List<Wrapper> wrappers;
+
+        private Watcher(String eventPath, Path file) {
+            this.eventPath = eventPath;
+            this.file = file;
+            this.wrappers = Lists.newArrayList();
+        }
+
+        public void log(Event ev, Listener l) {
+            wrappers.add(new Wrapper(ev, l));
+        }
+
+        public void dump() throws IOException{
+            JsonArray array = new JsonArray();
+            wrappers.forEach(w -> array.add(w.serialize()));
+
+            StringWriter stringWriter = new StringWriter();
+            JsonWriter jsonWriter = new JsonWriter(stringWriter);
+            jsonWriter.setIndent(" ");
+            jsonWriter.setLenient(false);
+            Streams.write(array, jsonWriter);
+
+            try (PrintStream out = new PrintStream(Files.newOutputStream(file), false, StandardCharsets.UTF_8)) {
+                out.print(stringWriter);
+            }
+        }
+    }
+
+    /**
+     * Wrapper class to store all relevant information
+     */
+    private static final class Wrapper {
+        private final Listener listener;
+        private final String timestamp;
+        private final Event event;
+
+        public Wrapper(Event event, Listener listener) {
+            this.listener = listener;
+            this.timestamp = FORMATTER.format(LocalDateTime.now());
+            this.event = event;
+        }
+
+        private JsonObject serialize() {
+            JsonObject parent = new JsonObject();
+            parent.addProperty("timestamp", timestamp);
+            parent.addProperty("listener", listener != null ? listener.getClass().getCanonicalName() : "INITIAL CALL");
+            JsonObject obj = new JsonObject();
+            obj.addProperty("event", event.getEventName());
+            try {
+                for (Field f : event.getClass().getDeclaredFields()) {
+                    if(f.getName().equalsIgnoreCase("handlers"))
+                        continue;
+                    f.setAccessible(true);
+                    Object field = f.get(event);
+                    obj.addProperty(f.getName(), field == null ? "null" : field.toString());
+                }
+            } catch(SecurityException | IllegalAccessException ex) {
+                MinecraftServer.LOGGER.warn("Failure to serialize event verbose", ex);
+            }
+            parent.add("info", obj);
+            return parent;
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
index dfb91cb8e19e0159e0eba9367ca7396125da6d1c..48dd9149110a3e7548a610eb80d6d301ba6121e2 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
@@ -5,6 +5,7 @@ import com.destroystokyo.paper.event.server.ServerExceptionEvent;
 import com.destroystokyo.paper.exception.ServerEventException;
 import com.google.common.collect.Sets;
 import io.papermc.paper.command.subcommands.EventVerboseCommand;
+import io.papermc.paper.command.subcommands.EventWatcherCommand;
 import org.bukkit.Server;
 import org.bukkit.Warning;
 import org.bukkit.event.Event;
@@ -43,6 +44,7 @@ class PaperEventManager {
             throw new IllegalStateException(event.getEventName() + " may only be triggered synchronously.");
         }
         EventVerboseCommand.tryLogEvent(event);
+        EventWatcherCommand.tryLog(event, null);
 
         HandlerList handlers = event.getHandlers();
         RegisteredListener[] listeners = handlers.getRegisteredListeners();
@@ -54,6 +56,7 @@ class PaperEventManager {
 
             try {
                 registration.callEvent(event);
+                EventWatcherCommand.tryLog(event, registration.getListener());
             } catch (AuthorNagException ex) {
                 Plugin plugin = registration.getPlugin();
 
