From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: derverdox <mail.ysp@web.de>
Date: Sun, 3 Dec 2023 02:56:42 +0100
Subject: [PATCH] Adding PredicateChoice to Paper API


diff --git a/src/main/java/io/papermc/paper/inventory/recipe/StackedContentsExtraMap.java b/src/main/java/io/papermc/paper/inventory/recipe/StackedContentsExtraMap.java
index 63db0b843c5bd11f979e613ba6cfac9d9da956bb..f0758b3ee7da21f23132fcdf5b10c9554af3ef9a 100644
--- a/src/main/java/io/papermc/paper/inventory/recipe/StackedContentsExtraMap.java
+++ b/src/main/java/io/papermc/paper/inventory/recipe/StackedContentsExtraMap.java
@@ -24,39 +24,52 @@ public final class StackedContentsExtraMap {
     private final Int2ObjectMap<ItemStack> idToExactChoice = new Int2ObjectOpenHashMap<>();
     private final StackedContents contents;
     public final Map<Ingredient, IntList> extraStackingIds = new IdentityHashMap<>();
+    private Recipe<?> recipe;
 
     public StackedContentsExtraMap(final StackedContents contents, final Recipe<?> recipe) {
         this.exactChoiceIds.defaultReturnValue(-1);
         this.contents = contents;
         this.initialize(recipe);
     }
+    /**
+     * Instead of using the items an ingredient provides we choose a different approach.
+     * PredicateChoices do not have those "template items". That is why we use the items in the stacked contents as "template items"
+     * Whenever we account a stack we test if there is any ingredient that would return true on test(itemStack).
+     * Else we act as if the item was not in the inventory.
+     * As a result, there is no need to change the vanilla implementation of RecipePicker.
+     */
 
     private void initialize(final Recipe<?> recipe) {
-        if (recipe.hasExactIngredients()) {
-            for (final Ingredient ingredient : recipe.getIngredients()) {
-                if (!ingredient.isEmpty() && ingredient.exact) {
-                    final net.minecraft.world.item.ItemStack[] items = ingredient.getItems();
-                    final IntList idList = new IntArrayList(items.length);
-                    for (final ItemStack item : items) {
-                        idList.add(this.registerExact(item)); // I think not copying the stack here is safe because cb copies the stack when creating the ingredient
-                        if (!item.hasTag()) {
-                            // add regular index if it's a plain itemstack but still registered as exact
-                            idList.add(StackedContents.getStackingIndex(item));
-                        }
-                    }
-                    idList.sort(IntComparators.NATURAL_COMPARATOR);
-                    this.extraStackingIds.put(ingredient, idList);
-                }
-            }
+        this.recipe = recipe;
+        for (final Ingredient ingredient : recipe.getIngredients()) {
+            if(ingredient.isEmpty())
+                continue;
+            extraStackingIds.put(ingredient, new IntArrayList());
         }
     }
 
     private int registerExact(final ItemStack exactChoice) {
+        if(exactChoice.isEmpty())
+            return -1;
         final int existing = this.exactChoiceIds.getInt(exactChoice);
         if (existing > -1) {
             return existing;
         }
         final int id = this.idCounter.getAndIncrement();
+        boolean isPotentialIngredient = false;
+        for (final Ingredient ingredient : this.recipe.getIngredients()) {
+            if (ingredient.test(exactChoice)) {
+                isPotentialIngredient = true;
+                final IntList idList = extraStackingIds.computeIfAbsent(ingredient, ingredient1 -> new IntArrayList());
+                idList.add(id);
+                if (!exactChoice.hasTag())
+                    idList.add(StackedContents.getStackingIndex(exactChoice));
+                idList.sort(IntComparators.NATURAL_COMPARATOR);
+            }
+        }
+
+        if(!isPotentialIngredient)
+            return -1;
         this.exactChoiceIds.put(exactChoice, id);
         this.idToExactChoice.put(id, exactChoice);
         return id;
@@ -67,6 +80,7 @@ public final class StackedContentsExtraMap {
     }
 
     public boolean accountStack(final ItemStack stack, final int count) {
+        registerExact(stack);
         if (!this.exactChoiceIds.isEmpty()) {
             final int id = this.exactChoiceIds.getInt(stack);
             if (id >= 0) {
@@ -74,6 +88,7 @@ public final class StackedContentsExtraMap {
                 return true;
             }
         }
-        return false;
+        // We always want to use extra map
+        return true;
     }
 }
diff --git a/src/main/java/net/minecraft/world/entity/player/StackedContents.java b/src/main/java/net/minecraft/world/entity/player/StackedContents.java
index 26b236a764177ac16d53f5cbaf83d3e21d015ebc..82eda864013cbebf94a28e9de49efc23c562238d 100644
--- a/src/main/java/net/minecraft/world/entity/player/StackedContents.java
+++ b/src/main/java/net/minecraft/world/entity/player/StackedContents.java
@@ -24,7 +24,8 @@ public class StackedContents {
     @Nullable public io.papermc.paper.inventory.recipe.StackedContentsExtraMap extrasMap = null; // Paper
 
     public void accountSimpleStack(ItemStack stack) {
-        if (this.extrasMap != null && stack.hasTag() && this.extrasMap.accountStack(stack, Math.min(64, stack.getCount()))) return; // Paper - max of 64 due to accountStack method below
+        // We always want to use extra map!
+        if (this.extrasMap != null /*&& stack.hasTag()*/ && this.extrasMap.accountStack(stack, Math.min(64, stack.getCount()))) return; // Paper - max of 64 due to accountStack method below
         if (!stack.isDamaged() && !stack.isEnchanted() && !stack.hasCustomHoverName()) {
             this.accountStack(stack);
         }
@@ -39,7 +40,8 @@ public class StackedContents {
         if (!stack.isEmpty()) {
             int i = getStackingIndex(stack);
             int j = Math.min(maxCount, stack.getCount());
-            if (this.extrasMap != null && stack.hasTag() && this.extrasMap.accountStack(stack, j)) return; // Paper - if an exact ingredient, don't include it
+            // We always want to use extra map!
+            if (this.extrasMap != null /*&& stack.hasTag()*/ && this.extrasMap.accountStack(stack, j)) return; // Paper - if an exact ingredient, don't include it
             this.put(i, j);
         }
 
diff --git a/src/main/java/net/minecraft/world/item/crafting/Ingredient.java b/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
index 06fe5b056d78d42cdf78437eeabe1786d596b7f8..d9a0917a6f0291023042c01b33f5ca8793e441f0 100644
--- a/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
+++ b/src/main/java/net/minecraft/world/item/crafting/Ingredient.java
@@ -7,6 +7,7 @@ import com.mojang.serialization.Codec;
 import com.mojang.serialization.DataResult;
 import com.mojang.serialization.JsonOps;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
+import de.verdox.predicatechoice.PredicateChoice;
 import it.unimi.dsi.fastutil.ints.IntArrayList;
 import it.unimi.dsi.fastutil.ints.IntComparators;
 import it.unimi.dsi.fastutil.ints.IntList;
@@ -29,11 +30,13 @@ import net.minecraft.world.entity.player.StackedContents;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.ItemLike;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
 
 public final class Ingredient implements Predicate<ItemStack> {
 
     public static final Ingredient EMPTY = new Ingredient(Stream.empty());
     private final Ingredient.Value[] values;
+    private PredicateChoice predicateChoice;
     @Nullable
     public ItemStack[] itemStacks;
     @Nullable
@@ -42,6 +45,11 @@ public final class Ingredient implements Predicate<ItemStack> {
     public static final Codec<Ingredient> CODEC = Ingredient.codec(true);
     public static final Codec<Ingredient> CODEC_NONEMPTY = Ingredient.codec(false);
 
+    public Ingredient(PredicateChoice predicateChoice) {
+        List<org.bukkit.inventory.ItemStack> bukkitChoices = predicateChoice.getRecipeBookTemplates();
+        this.predicateChoice = predicateChoice;
+        this.values = bukkitChoices.stream().map(CraftItemStack::asNMSCopy).map(ItemValue::new).toArray(Value[]::new);
+    }
     public Ingredient(Stream<? extends Ingredient.Value> entries) {
         this.values = (Ingredient.Value[]) entries.toArray((i) -> {
             return new Ingredient.Value[i];
@@ -70,6 +78,9 @@ public final class Ingredient implements Predicate<ItemStack> {
         } else if (this.isEmpty()) {
             return itemstack.isEmpty();
         } else {
+            if (predicateChoice != null) {
+                return predicateChoice.test(itemstack.getBukkitStack());
+            }
             ItemStack[] aitemstack = this.getItems();
             int i = aitemstack.length;
 
@@ -269,4 +280,7 @@ public final class Ingredient implements Predicate<ItemStack> {
             return Collections.singleton(this.item);
         }
     }
+    public @Nullable PredicateChoice getPredicateChoice() {
+        return predicateChoice;
+    }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftRecipe.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftRecipe.java
index 13d25d118eb4d3ef35a4cdfb9bbde9ed83f6c04b..fb2ad3895989f68ca604dc1a7546842315f5dd49 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftRecipe.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftRecipe.java
@@ -3,6 +3,7 @@ package org.bukkit.craftbukkit.inventory;
 import com.google.common.base.Preconditions;
 import java.util.ArrayList;
 import java.util.List;
+import de.verdox.predicatechoice.PredicateChoice;
 import net.minecraft.world.item.crafting.Ingredient;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 import org.bukkit.inventory.ItemStack;
@@ -30,7 +31,11 @@ public interface CraftRecipe extends Recipe {
         } else if (bukkit instanceof RecipeChoice.ExactChoice) {
             stack = new Ingredient(((RecipeChoice.ExactChoice) bukkit).getChoices().stream().map((mat) -> new net.minecraft.world.item.crafting.Ingredient.ItemValue(CraftItemStack.asNMSCopy(mat))));
             stack.exact = true;
-        } else {
+        }
+        else if(bukkit instanceof PredicateChoice predicateChoice){
+            stack = new Ingredient(predicateChoice);
+        }
+        else {
             throw new IllegalArgumentException("Unknown recipe stack instance " + bukkit);
         }
 
@@ -49,6 +54,8 @@ public interface CraftRecipe extends Recipe {
             return null;
         }
 
+        if(list.getPredicateChoice() != null)
+            return list.getPredicateChoice();
         if (list.exact) {
             List<org.bukkit.inventory.ItemStack> choices = new ArrayList<>(list.itemStacks.length);
             for (net.minecraft.world.item.ItemStack i : list.itemStacks) {
