From 1cc9daf3260d6376cc1eea78ad389e7140e88fc3 Mon Sep 17 00:00:00 2001
From: slicklibro <slicklibro@gmail.com>
Date: Fri, 20 Sep 2019 17:16:14 +1200
Subject: [PATCH] Ticket level per-player view distance API

This PR implements the per-player view distance API at the ticket level.
This somewhat clean solution comes from the result of many complicated ones (and research).
The view-distance config value will determine the global distance (and set maximum) of normal view distance interactions with entities, mob-spawning and tracking.
All chunks with player tickets within this range will also be served by the server, allowing shared view distance from other players without impacting performance.

diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index 63a68872..4561857b 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -43,6 +43,16 @@ public abstract class ChunkMapDistance {
     private final LongSet l = new LongOpenHashSet();
     private final Executor m;
     private long currentTick;
+    //Paper start ticket level pp-view-dist
+    protected final it.unimi.dsi.fastutil.ints.Int2ObjectMap<Square> squares = new it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap<>();
+    protected it.unimi.dsi.fastutil.longs.Long2ByteMap update = new it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap();
+    class Square {
+        public int x, y, u, v, ticket;
+        public Square(int x1, int y1, int u1, int v1, int ticket1) {
+            x = x1; y = y1; u = u1; v = v1; ticket = ticket1;
+        }
+    }
+    //Paper end
 
     protected ChunkMapDistance(Executor executor, Executor executor1) {
         executor1.getClass();
@@ -234,6 +244,88 @@ public abstract class ChunkMapDistance {
         ((ObjectSet) this.c.computeIfAbsent(i, (j) -> {
             return new ObjectOpenHashSet();
         })).add(entityplayer);
+
+        //Paper start ticket level pp-view-dist
+        int cx = ChunkCoordIntPair.getX(i);
+        int cz = ChunkCoordIntPair.getZ(i);
+
+        int pvd = entityplayer.getViewDistance() - 2;
+
+        Square vdsqr = new Square(cx - pvd, cz - pvd, cx + pvd + 1, cz + pvd + 1, 0);
+        Square sto = this.squares.get(entityplayer.getId());
+        this.squares.put(entityplayer.getId(), new Square(cx - pvd, cz - pvd, cx + pvd + 1, cz + pvd + 1, 0));
+
+        if(sto == null) sto = vdsqr;
+        Square oldsqr = new Square(sto.x, sto.y, sto.u, sto.v, sto.ticket);
+
+        it.unimi.dsi.fastutil.ints.IntSortedSet row = new it.unimi.dsi.fastutil.ints.IntRBTreeSet(it.unimi.dsi.fastutil.ints.IntComparators.NATURAL_COMPARATOR);
+        it.unimi.dsi.fastutil.ints.IntSortedSet col = new it.unimi.dsi.fastutil.ints.IntRBTreeSet(it.unimi.dsi.fastutil.ints.IntComparators.NATURAL_COMPARATOR);
+        it.unimi.dsi.fastutil.objects.ObjectList<Square> toproc = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+
+        vdsqr.ticket = 1; oldsqr.ticket = -1;
+        toproc.add(oldsqr); toproc.add(vdsqr);
+        row.add(oldsqr.y); row.add(oldsqr.v); col.add(oldsqr.x); col.add(oldsqr.u);
+        row.add(vdsqr.y); row.add(vdsqr.v); col.add(vdsqr.x); col.add(vdsqr.u);
+
+        if(oldsqr.x < vdsqr.u && oldsqr.u > vdsqr.x && oldsqr.y < vdsqr.v && oldsqr.v > vdsqr.y && !sto.equals(vdsqr)) {
+            Square ovdsqr = new Square(Math.max(oldsqr.x, vdsqr.x), Math.max(oldsqr.y, vdsqr.y), Math.min(oldsqr.u, vdsqr.u), Math.min(oldsqr.v, vdsqr.v), 0);
+            toproc.add(ovdsqr);
+            row.add(ovdsqr.y); row.add(ovdsqr.v); col.add(ovdsqr.x); col.add(ovdsqr.u);
+        }
+
+        ObjectIterator<it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry<Square>> sqriterator = this.squares.int2ObjectEntrySet().iterator();
+        while(sqriterator.hasNext()) {
+            it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry<Square> e = sqriterator.next();
+            int uid = e.getIntKey();
+            Square sqr = e.getValue();
+            if(uid == entityplayer.getId()) continue;
+            if(sqr.ticket == -2) { this.squares.remove(uid); continue; }
+            if ((sqr.x < vdsqr.u && sqr.u > vdsqr.x && sqr.y < vdsqr.v && sqr.v > vdsqr.y) ||
+                (sqr.x < oldsqr.u && sqr.u > oldsqr.x && sqr.y < oldsqr.v && sqr.v > oldsqr.y )) {
+                toproc.add(sqr);
+                row.add(sqr.y); row.add(sqr.v); col.add(sqr.x); col.add(sqr.u);
+            }
+        }
+
+        it.unimi.dsi.fastutil.objects.ObjectListIterator<Square> it = toproc.iterator();
+        //coordinate compression
+
+        int[][] grid = new int[row.size()][col.size()];
+
+        while(it.hasNext()) {
+            Square sqr = it.next();
+            for(int s = row.headSet(sqr.y).size(); s < row.headSet(sqr.v).size(); s++) {
+                for(int t = col.headSet(sqr.x).size(); t < col.headSet(sqr.u).size(); t++) {
+                    grid[s][t] = sqr.ticket;
+                }
+            }
+        }
+
+        int[] rw = row.toIntArray(); int[] cl = col.toIntArray();
+        for(int s = 0; s < row.size() - 1; s++) {
+            for(int t = 0; t < col.size() - 1; t++){
+                if(grid[s][t] == -1) {
+                    for(int x = cl[t]; x < cl[t+1]; x++) {
+                        for(int z = rw[s]; z < rw[s+1]; z++) {
+                            long pair = ChunkCoordIntPair.asLong(x, z);
+                            update.put(pair, (byte) -1);
+                        }
+                    }
+
+                } else if(grid[s][t] == 1) {
+                    for(int x = cl[t]; x < cl[t+1]; x++) {
+                        for(int z = rw[s]; z < rw[s+1]; z++) {
+                            long pair = ChunkCoordIntPair.asLong(x, z);
+                            update.put(pair, (byte) 1);
+                        }
+                    }
+                }
+            }
+
+
+        }
+        //Paper end
+
         this.f.b(i, 0, true);
         this.g.b(i, 0, true);
     }
@@ -241,7 +333,8 @@ public abstract class ChunkMapDistance {
     public void b(SectionPosition sectionposition, EntityPlayer entityplayer) {
         long i = sectionposition.u().pair();
         ObjectSet<EntityPlayer> objectset = (ObjectSet) this.c.get(i);
-
+        Square sqr = this.squares.get(entityplayer.getId());
+        this.squares.put(entityplayer.getId(), new Square(sqr.x, sqr.y, sqr.u, sqr.v, -2));
         objectset.remove(entityplayer);
         if (objectset.isEmpty()) {
             this.c.remove(i);
@@ -372,20 +465,20 @@ public abstract class ChunkMapDistance {
                 byte b0 = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getByteValue();
                 long j = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getLongKey();
 
-                this.a(j, b0, this.c(b0), b0 <= i - 2);
+                this.a(j, b0, this.c(b0), b0 <= i - 2, i); //Paper ticket level pp-view-dist
             }
 
             this.e = i;
         }
 
-        private void a(long i, int j, boolean flag, boolean flag1) {
+        private void a(long i, int j, boolean flag, boolean flag1, int vd) { //Paper ticket level pp-view-dist
             if (flag != flag1) {
                 Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, ChunkMapDistance.b, new ChunkCoordIntPair(i), ChunkMapDistance.this.currentTick);
 
                 if (flag1) {
                     ChunkMapDistance.this.j.a(ChunkTaskQueueSorter.a(() -> { // Craftbukkit - decompile error
                         ChunkMapDistance.this.m.execute(() -> {
-                            if (this.c(this.c(i))) {
+                            if (this.c(i) <= vd) { //Paper ticket level pp-view-dist
                                 ChunkMapDistance.this.addTicket(i, ticket);
                                 ChunkMapDistance.this.l.add(i);
                             } else {
@@ -430,10 +523,33 @@ public abstract class ChunkMapDistance {
                             }
 
                         });
-                        this.a(i, k, this.c(j), this.c(k));
+                    }
+
+                    //Paper start ticket level pp-view-dist
+                    byte f = ChunkMapDistance.this.update.remove(i);
+                    if(f == 1) {
+                        this.a(i, k, false, true, Integer.MAX_VALUE);
+                    } else if (f == -1) {
+                        this.a(i, k, true, false, Integer.MAX_VALUE);
                     }
                 }
 
+                ObjectIterator<it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry> it = ChunkMapDistance.this.update.long2ByteEntrySet().iterator();
+
+                while(it.hasNext()) {
+                    it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry e = it.next();
+                    long i = e.getLongKey();
+                    byte f = e.getByteValue();
+                    if(f == 1) {
+                        this.a(i, this.c(i), false, true, Integer.MAX_VALUE);
+                    } else if (f == -1) {
+                        this.a(i, this.c(i), true, false, Integer.MAX_VALUE);
+                    }
+                }
+
+                ChunkMapDistance.this.update.clear();
+                //Paper end
+
                 this.g.clear();
             }
 
diff --git a/src/main/java/net/minecraft/server/EntityHuman.java b/src/main/java/net/minecraft/server/EntityHuman.java
index cd73cde8..2186a81e 100644
--- a/src/main/java/net/minecraft/server/EntityHuman.java
+++ b/src/main/java/net/minecraft/server/EntityHuman.java
@@ -80,6 +80,16 @@ public abstract class EntityHuman extends EntityLiving {
     public String spawnWorld = "";
     public int oldLevel = -1;
 
+    //Paper start ticket level pp-view-dist
+    private int viewDistance;
+    public int lastViewDistance;
+    public int getViewDistance() { return this.viewDistance; }
+    public void setViewDistance(int i) {
+        this.lastViewDistance = this.viewDistance;
+        this.viewDistance = MathHelper.clamp(i, 3, ((WorldServer) this.world).getChunkProvider().playerChunkMap.viewDistance);
+    }
+    //Paper end
+
     @Override
     public CraftHumanEntity getBukkitEntity() {
         return (CraftHumanEntity) super.getBukkitEntity();
@@ -98,6 +108,9 @@ public abstract class EntityHuman extends EntityLiving {
 
         this.setPositionRotation((double) blockposition.getX() + 0.5D, (double) (blockposition.getY() + 1), (double) blockposition.getZ() + 0.5D, 0.0F, 0.0F);
         this.aX = 180.0F;
+        this.setViewDistance(((WorldServer) this.world).getChunkProvider().playerChunkMap.viewDistance);  //Paper ticket level pp-view-dist
+        if(((WorldServer) this.world).getChunkProvider().playerChunkMap.viewDistance == 0) this.setViewDistance(this.world.spigotConfig.viewDistance); //Paper ticket level pp-view-dist
+        this.lastViewDistance = this.getViewDistance(); //Paper ticket level pp-view-dist
     }
 
     public boolean a(World world, BlockPosition blockposition, EnumGamemode enumgamemode) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index e920545d..fd56fe1f 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1986,12 +1986,12 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public int getViewDistance() {
-        throw new NotImplementedException("Per-Player View Distance APIs need further understanding to properly implement"); // TODO
+        return getHandle().getViewDistance(); //Paper ticket level pp-view-dist
     }
 
     @Override
     public void setViewDistance(int viewDistance) {
-        throw new NotImplementedException("Per-Player View Distance APIs need further understanding to properly implement"); // TODO
+        getHandle().setViewDistance(viewDistance); //Paper ticket level pp-view-dist
     }
     //Paper end
 
-- 
2.20.1.windows.1

