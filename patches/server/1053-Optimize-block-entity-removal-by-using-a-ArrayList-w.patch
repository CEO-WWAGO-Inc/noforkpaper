From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MrPowerGamerBR <git@mrpowergamerbr.com>
Date: Sat, 25 Nov 2023 01:36:45 -0300
Subject: [PATCH] Optimize block entity removal by using a ArrayList with bulk
 remove by index

The blockEntityTickers list was replaced with a custom list based on fastutil's ObjectArrayList with a small yet huge change for us: A method that allows us to remove a list of indexes from the list. 

This is WAY FASTER than using removeAll with a list of entries to be removed, because we don't need to calculate the identity of each block entity to be removed, and we can jump directly to where the search should begin, giving a performance boost for small removals (because we don't need to loop thru the entire list to find what element should be removed) and a performance boost for big removals (no need to calculate the identity of each block entity).

diff --git a/src/main/java/io/papermc/paper/util/BlockEntityTickersList.java b/src/main/java/io/papermc/paper/util/BlockEntityTickersList.java
new file mode 100644
index 0000000000000000000000000000000000000000..8f8d44d520395a2ea6f0842c7ecebc7b954bd194
--- /dev/null
+++ b/src/main/java/io/papermc/paper/util/BlockEntityTickersList.java
@@ -0,0 +1,69 @@
+package io.papermc.paper.util;
+
+import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Set;
+import net.minecraft.world.level.block.entity.TickingBlockEntity;
+
+/**
+ * A list for ServerLevel's blockEntityTickers
+ *
+ * This list is behaves identically to ObjectArrayList, but it has an additional method, `removeAllByIndex`, that allows a list of integers to be passed indicating what
+ * indexes should be deleted from the list
+ *
+ * This is faster than using removeAll, since we don't need to compare the identity of each block entity, and faster than looping thru each index manually and deleting with remove,
+ * since we don't need to resize the array every single remove.
+ */
+public class BlockEntityTickersList extends ObjectArrayList<TickingBlockEntity> {
+    /** Creates a new array list with {@link #DEFAULT_INITIAL_CAPACITY} capacity. */
+    public BlockEntityTickersList() {
+        super();
+    }
+
+    /**
+     * Creates a new array list and fills it with a given collection.
+     *
+     * @param c a collection that will be used to fill the array list.
+     */
+    public BlockEntityTickersList(final Collection<? extends TickingBlockEntity> c) {
+        super(c);
+    }
+
+    /**
+     * Removes elements by their index.
+     */
+    public boolean removeAllByIndex(final int startSearchFromIndex, final Set<Integer> c) {
+        final int requiredMatches = c.size();
+        if (requiredMatches == 0)
+            return false; // exit early, we don't need to do anything
+
+        final Object[] a = this.a;
+        int j = startSearchFromIndex;
+        int matches = 0;
+        for (int i = startSearchFromIndex; i < size; i++) { // If the user knows the first index to be removed, we can skip a lot of unnecessary comparsions
+            if (!c.contains(i)) {
+                a[j++] = a[i];
+            } else {
+                matches++;
+            }
+
+            if (matches == requiredMatches) { // Exit the loop if we already removed everything, we don't need to check anything else
+                // We need to update the final size here, because we know that we already found everything!
+                // Because we know that the size must be currentSize - requiredMatches (because we have matched everything), let's update the value
+                // However, we need to copy the rest of the stuff over
+                if (i != (size - 1)) { // If it isn't the last index...
+                    // i + 1 because we want to copy the *next* element over
+                    // and the size - i - 1 is because we want to get the current size, minus the current index (which is i), and then - 1 because we want to copy -1 ahead (remember, we are adding +1 to copy the *next* element)
+                    System.arraycopy(a, i + 1, a, j, size - i - 1);
+                }
+                j = size - requiredMatches;
+                break;
+            }
+        }
+        Arrays.fill(a, j, size, null);
+        final boolean modified = size != j;
+        size = j;
+        return modified;
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 2354a0e5d15e9be633d9fe3a1a9feefe7b9b7782..d0315a911c79fdfe4531cc92be0e3028ce38b952 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -117,7 +117,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public static final int TICKS_PER_DAY = 24000;
     public static final int MAX_ENTITY_SPAWN_Y = 20000000;
     public static final int MIN_ENTITY_SPAWN_Y = -20000000;
-    protected final List<TickingBlockEntity> blockEntityTickers = Lists.newArrayList(); public final int getTotalTileEntityTickers() { return this.blockEntityTickers.size(); } // Paper
+    protected final io.papermc.paper.util.BlockEntityTickersList blockEntityTickers = new io.papermc.paper.util.BlockEntityTickersList(); /* Lists.newArrayList(); */ public final int getTotalTileEntityTickers() { return this.blockEntityTickers.size(); } // Paper
     protected final NeighborUpdater neighborUpdater;
     private final List<TickingBlockEntity> pendingBlockEntityTickers = Lists.newArrayList();
     private boolean tickingBlockEntities;
@@ -1268,8 +1268,12 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         // Spigot start
         // Iterator iterator = this.blockEntityTickers.iterator();
         int tilesThisCycle = 0;
-        var toRemove = new it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet<TickingBlockEntity>(net.minecraft.Util.identityStrategy()); // Paper - use removeAll
-        toRemove.add(null);
+        // var toRemove = new it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet<TickingBlockEntity>(net.minecraft.Util.identityStrategy()); // Paper - use removeAll
+        // toRemove.add(null);
+        // Paper start - optimize block entity removal
+        var toRemove = new java.util.HashSet<Integer>(); // For some reason, Java's HashSet seems to be faster than fastutil's only if we are removing HUGE amounts of tile entities, idk why
+        var startSearchFromIndex = -1;
+        // Paper end
         for (tileTickPosition = 0; tileTickPosition < this.blockEntityTickers.size(); tileTickPosition++) { // Paper - Disable tick limiters
             this.tileTickPosition = (this.tileTickPosition < this.blockEntityTickers.size()) ? this.tileTickPosition : 0;
             TickingBlockEntity tickingblockentity = (TickingBlockEntity) this.blockEntityTickers.get(this.tileTickPosition);
@@ -1277,6 +1281,11 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
             if (tickingblockentity == null) {
                 this.getCraftServer().getLogger().severe("Spigot has detected a null entity and has removed it, preventing a crash");
                 tilesThisCycle--;
+                // Paper start - optimize block entity removal
+                toRemove.add(tileTickPosition);
+                if (startSearchFromIndex == -1)
+                    startSearchFromIndex = tileTickPosition;
+                // Paper end
                 continue;
             }
             // Spigot end
@@ -1284,7 +1293,12 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
             if (tickingblockentity.isRemoved()) {
                 // Spigot start
                 tilesThisCycle--;
-                toRemove.add(tickingblockentity); // Paper - use removeAll
+                // Paper start - optimize block entity removal
+                // toRemove.add(tickingblockentity); // Paper - use removeAll
+                toRemove.add(tileTickPosition);
+                if (startSearchFromIndex == -1)
+                    startSearchFromIndex = tileTickPosition;
+                // Paper end
                 // Spigot end
             } else if (this.shouldTickBlocksAt(tickingblockentity.getPos())) {
                 tickingblockentity.tick();
@@ -1295,7 +1309,10 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 // Paper end - execute chunk tasks during tick
             }
         }
-        this.blockEntityTickers.removeAll(toRemove);
+        // Paper start - optimize block entity removal
+        // this.blockEntityTickers.removeAll(toRemove);
+        this.blockEntityTickers.removeAllByIndex(startSearchFromIndex, toRemove); // We don't need to care about if the startSearchFromIndex can be -1 here, since if it is -1, then the toRemove list is empty and the call will fast fail
+        // Paper end
 
         this.timings.tileEntityTick.stopTiming(); // Spigot
         this.tickingBlockEntities = false;
