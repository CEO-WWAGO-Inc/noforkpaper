From 01047138bc62ad5073293af68d50fcd08f553ca6 Mon Sep 17 00:00:00 2001
From: kickash32 <kickash32@gmail.com>
Date: Fri, 26 Jul 2019 10:24:32 +0500
Subject: [PATCH] implement optional per player mob spawns


diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index 318a470e..ff1e27e7 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -562,4 +562,9 @@ public class PaperWorldConfig {
     private void disableRelativeProjectileVelocity() {
         disableRelativeProjectileVelocity = getBoolean("game-mechanics.disable-relative-projectile-velocity", false);
     }
+
+    public boolean perPlayerMobSpawns = false;
+    private void perPlayerMobSpawns() {
+        perPlayerMobSpawns = getBoolean("per-player-mob-spawns", false);
+    }
 }
diff --git a/src/main/java/com/destroystokyo/paper/util/LeakyResettableList.java b/src/main/java/com/destroystokyo/paper/util/LeakyResettableList.java
new file mode 100644
index 00000000..bc331938
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/LeakyResettableList.java
@@ -0,0 +1,144 @@
+package com.destroystokyo.paper.util;
+
+import org.apache.commons.lang.NotImplementedException;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+
+public final class LeakyResettableList<E> implements List<E> {
+
+    private Object[] elements;
+    private int size;
+
+    public LeakyResettableList() {
+        this(16);
+    }
+
+    public LeakyResettableList(final int capacity) {
+        this.elements = new Object[capacity];
+    }
+
+    public int size() {
+        return this.size;
+    }
+
+    public void clear() {
+        this.size = 0;
+    }
+
+    public E get(final int index) {
+        if (index < 0 || index >= this.size) {
+            throw new IndexOutOfBoundsException("Index: " + index);
+        }
+        //noinspection unchecked
+        return (E)this.elements[index];
+    }
+
+    public boolean add(final E element) {
+        if (this.size == this.elements.length) {
+            this.elements = Arrays.copyOf(this.elements, this.size * 2);
+        }
+        this.elements[this.size++] = element;
+        return true;
+    }
+
+    // Unimplemented methods below vvv
+
+    @Override
+    public boolean isEmpty() {
+        throw new NotImplementedException(); // TODO
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        throw new NotImplementedException(); // TODO
+    }
+
+    @Override
+    public Iterator<E> iterator() {
+        throw new NotImplementedException(); // TODO
+    }
+
+    @Override
+    public Object[] toArray() {
+        throw new NotImplementedException(); // TODO
+    }
+
+    @Override
+    public <T> T[] toArray(T[] a) {
+        throw new NotImplementedException(); // TODO
+    }
+
+    @Override
+    public E set(int index, E element) {
+        throw new NotImplementedException(); // TODO
+    }
+
+    @Override
+    public void add(int index, E element) {
+        throw new NotImplementedException(); // TODO
+    }
+
+    @Override
+    public E remove(int index) {
+        throw new NotImplementedException(); // TODO
+    }
+
+    @Override
+    public int indexOf(Object o) {
+        throw new NotImplementedException(); // TODO
+    }
+
+    @Override
+    public int lastIndexOf(Object o) {
+        throw new NotImplementedException(); // TODO
+    }
+
+    @Override
+    public ListIterator<E> listIterator() {
+        throw new NotImplementedException(); // TODO
+    }
+
+    @Override
+    public ListIterator<E> listIterator(int index) {
+        throw new NotImplementedException(); // TODO
+    }
+
+    @Override
+    public List<E> subList(int fromIndex, int toIndex) {
+        throw new NotImplementedException(); // TODO
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        throw new NotImplementedException(); // TODO
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> c) {
+        throw new NotImplementedException(); // TODO
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends E> c) {
+        throw new NotImplementedException(); // TODO
+    }
+
+    @Override
+    public boolean addAll(int index, Collection<? extends E> c) {
+        throw new NotImplementedException(); // TODO
+    }
+
+    @Override
+    public boolean removeAll(Collection<?> c) {
+        throw new NotImplementedException(); // TODO
+    }
+
+    @Override
+    public boolean retainAll(Collection<?> c) {
+        throw new NotImplementedException(); // TODO
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 2554c284..15c99fde 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -440,6 +440,7 @@ public class ChunkProviderServer extends IChunkProvider {
             int l = this.chunkMapDistance.b();
             EnumCreatureType[] aenumcreaturetype = EnumCreatureType.values();
             Object2IntMap<EnumCreatureType> object2intmap = this.world.l();
+            List<Entity> newlySpawnedEntities = new com.destroystokyo.paper.util.LeakyResettableList<>();
 
             this.world.getMethodProfiler().exit();
             this.playerChunkMap.f().forEach((playerchunk) -> {
@@ -489,8 +490,24 @@ public class ChunkProviderServer extends IChunkProvider {
                                 if (enumcreaturetype != EnumCreatureType.MISC && (!enumcreaturetype.c() || this.allowAnimals) && (enumcreaturetype.c() || this.allowMonsters) && (!enumcreaturetype.d() || flag2)) {
                                     int k1 = limit * l / ChunkProviderServer.b; // CraftBukkit - use per-world limits
 
-                                    if (object2intmap.getInt(enumcreaturetype) <= k1) {
-                                        SpawnerCreature.a(enumcreaturetype, (World) this.world, chunk, blockposition);
+                                    // Paper start - only allow spawns upto the limit per chunk and update count afterwards
+                                    int currEntityCount = object2intmap.getInt(enumcreaturetype);
+                                    int difference = k1 - currEntityCount;
+
+                                    if(this.world.paperConfig.perPlayerMobSpawns){
+                                        int minDiff = Integer.MAX_VALUE;
+                                        for(EntityPlayer entityplayer : playerChunkMap.getPlayersNear(chunk.getPos())) {
+                                            if (entityplayer.isSpectator() || !entityplayer.affectsSpawning) { continue; }
+                                            minDiff = Math.min(limit - this.world.getMobCountNear(entityplayer, enumcreaturetype), minDiff);
+                                        }
+                                        difference = (minDiff == Integer.MAX_VALUE) ? 0 : minDiff;
+                                    }
+
+                                    if (difference > 0) {
+                                        SpawnerCreature.spawnMobs(enumcreaturetype, this.world, chunk, blockposition, difference, newlySpawnedEntities); // Populates newlySpawnedEntities
+                                        object2intmap.put(enumcreaturetype, currEntityCount + newlySpawnedEntities.size());
+                                        this.world.updatePlayerMobCounts(newlySpawnedEntities); // Clears newlySpawnedEntities
+                                    // Paper end
                                     }
                                 }
                             }
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 18695d9b..6adcabd1 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -80,6 +80,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public boolean queueHealthUpdatePacket = false;
     public net.minecraft.server.PacketPlayOutUpdateHealth queuedHealthUpdatePacket;
     // Paper end
+    public int[] mobCounts = new int[5];
 
     // CraftBukkit start
     public String displayName;
diff --git a/src/main/java/net/minecraft/server/EntityTypes.java b/src/main/java/net/minecraft/server/EntityTypes.java
index a7fc34f8..63c193d7 100644
--- a/src/main/java/net/minecraft/server/EntityTypes.java
+++ b/src/main/java/net/minecraft/server/EntityTypes.java
@@ -253,6 +253,7 @@ public class EntityTypes<T extends Entity> {
         return this.be;
     }
 
+    public EnumCreatureType getEnumCreatureType(){ return this.e(); } // Paper - OBFHELPER
     public EnumCreatureType e() {
         return this.ba;
     }
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index b447c49a..008f0c2d 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -146,6 +146,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         return d2 * d2 + d3 * d3;
     }
 
+    private static int distanceBetween(ChunkCoordIntPair chunkcoordintpair, EntityPlayer entityplayer) { return b(chunkcoordintpair, entityplayer, true); } // Paper - OBFHELPER
     private static int b(ChunkCoordIntPair chunkcoordintpair, EntityPlayer entityplayer, boolean flag) {
         int i;
         int j;
@@ -1097,6 +1098,14 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     }
 
+    // Paper start
+    public List<EntityPlayer> getPlayersNear(ChunkCoordIntPair chunkcoordintpair) {
+        List<EntityPlayer> players = this.playerMap.getPlayers();
+        players.removeIf(
+            entityplayer -> distanceBetween(chunkcoordintpair, entityplayer) > this.viewDistance);
+        return players;
+    }
+    // Paper end
     @Override
     public Stream<EntityPlayer> a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
         return this.playerMap.a(chunkcoordintpair.pair()).filter((entityplayer) -> {
diff --git a/src/main/java/net/minecraft/server/PlayerMap.java b/src/main/java/net/minecraft/server/PlayerMap.java
index f386c4e9..eb96a5ca 100644
--- a/src/main/java/net/minecraft/server/PlayerMap.java
+++ b/src/main/java/net/minecraft/server/PlayerMap.java
@@ -2,6 +2,8 @@ package net.minecraft.server;
 
 import it.unimi.dsi.fastutil.objects.Object2BooleanMap;
 import it.unimi.dsi.fastutil.objects.Object2BooleanOpenHashMap;
+import java.util.ArrayList; // Paper
+import java.util.List; // Paper
 import java.util.stream.Stream;
 
 public final class PlayerMap {
@@ -10,6 +12,7 @@ public final class PlayerMap {
 
     public PlayerMap() {}
 
+    public List<EntityPlayer> getPlayers() { return new ArrayList<>(this.a.keySet()); } // Paper - Based on method below without streams
     public Stream<EntityPlayer> a(long i) {
         return this.a.keySet().stream();
     }
diff --git a/src/main/java/net/minecraft/server/SpawnerCreature.java b/src/main/java/net/minecraft/server/SpawnerCreature.java
index c6ea37ff..440df23d 100644
--- a/src/main/java/net/minecraft/server/SpawnerCreature.java
+++ b/src/main/java/net/minecraft/server/SpawnerCreature.java
@@ -16,7 +16,12 @@ public final class SpawnerCreature {
 
     private static final Logger LOGGER = LogManager.getLogger();
 
+    // Paper start - add maxSpawns parameter and return spawned mobs
     public static void a(EnumCreatureType enumcreaturetype, World world, Chunk chunk, BlockPosition blockposition) {
+        spawnMobs(enumcreaturetype, world, chunk, blockposition, Integer.MAX_VALUE, new java.util.ArrayList<>());
+    }
+    public static void spawnMobs(EnumCreatureType enumcreaturetype, World world, Chunk chunk, BlockPosition blockposition, int maxSpawns, List<Entity> mobsSpawnedAddToThis) {
+    // Paper end
         ChunkGenerator<?> chunkgenerator = world.getChunkProvider().getChunkGenerator();
         int i = 0;
         BlockPosition blockposition1 = getRandomPosition(world, chunk);
@@ -117,7 +122,11 @@ public final class SpawnerCreature {
                                                             if (world.addEntity(entityinsentient, SpawnReason.NATURAL)) {
                                                                 ++i;
                                                                 ++i2;
+                                                                // Paper start - stop when limit is reached
+                                                                mobsSpawnedAddToThis.add(entityinsentient);
                                                             }
+                                                            if (mobsSpawnedAddToThis.size() >= maxSpawns){ return; }
+                                                            // Paper end
                                                             // CraftBukkit end
                                                             if (i >= entityinsentient.dC()) {
                                                                 return;
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 64915965..1f1cd674 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -46,6 +46,10 @@ import org.bukkit.event.entity.CreatureSpawnEvent;
 import org.bukkit.event.server.MapInitializeEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
 // CraftBukkit end
+// Paper start
+import java.util.ArrayList;
+import java.util.EnumMap;
+// Paper end
 
 public class WorldServer extends World {
 
@@ -846,6 +850,7 @@ public class WorldServer extends World {
     }
 
     public Object2IntMap<EnumCreatureType> l() {
+        List<Entity> filteredEntities = new com.destroystokyo.paper.util.LeakyResettableList<>(); // Paper
         Object2IntMap<EnumCreatureType> object2intmap = new Object2IntOpenHashMap();
         ObjectIterator objectiterator = this.entitiesById.values().iterator();
 
@@ -871,13 +876,33 @@ public class WorldServer extends World {
                     continue;
                 }
                 // Paper end
+                filteredEntities.add(entity); // Paper
                 object2intmap.mergeInt(enumcreaturetype, 1, Integer::sum);
             }
         }
 
+        updatePlayerMobCounts(filteredEntities); // Paper
         return object2intmap;
     }
 
+    // Paper start
+    public void updatePlayerMobCounts(List<Entity> entities) {
+        if (!this.paperConfig.perPlayerMobSpawns) { entities.clear(); return; }
+        for (int i = 0; i < entities.size(); i++) {
+            Entity entity = entities.get(i);
+            ((ChunkProviderServer) this.chunkProvider).playerChunkMap.getPlayersNear(entity.getChunkAtLocation().getPos()).forEach( (player) -> {
+                EnumCreatureType enumType = entity.getEntityType().getEnumCreatureType();
+                player.mobCounts[enumType.ordinal()]++;
+            });
+        }
+        entities.clear();
+    }
+
+    public int getMobCountNear(EntityPlayer entityPlayer, EnumCreatureType enumCreatureType) {
+        return entityPlayer.mobCounts[enumCreatureType.ordinal()];
+    }
+    // Paper end
+
     @Override
     public boolean addEntity(Entity entity) {
         // CraftBukkit start
-- 
2.22.0

