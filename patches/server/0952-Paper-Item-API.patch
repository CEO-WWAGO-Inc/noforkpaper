From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Mon, 17 Oct 2022 18:00:34 -0400
Subject: [PATCH] Paper Item API


diff --git a/src/main/java/io/papermc/paper/inventory/item/PaperItemStack.java b/src/main/java/io/papermc/paper/inventory/item/PaperItemStack.java
new file mode 100644
index 0000000000000000000000000000000000000000..1d8b4b61099fd41520534fc00c3b9f819a28520d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/inventory/item/PaperItemStack.java
@@ -0,0 +1,11 @@
+package io.papermc.paper.inventory.item;
+
+import net.minecraft.world.item.Items;
+
+public class PaperItemStack {
+
+
+    public static net.minecraft.world.item.ItemStack asVanillaCopy(io.papermc.paper.inventory.item.ItemStack paperItemStack) {
+        return new net.minecraft.world.item.ItemStack(Items.STONE);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/inventory/item/VanillaItemStack.java b/src/main/java/io/papermc/paper/inventory/item/VanillaItemStack.java
new file mode 100644
index 0000000000000000000000000000000000000000..7ce4f52240a560edb1198b26a966d31614b57d2e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/inventory/item/VanillaItemStack.java
@@ -0,0 +1,64 @@
+package io.papermc.paper.inventory.item;
+
+import io.papermc.paper.adventure.PaperAdventure;
+import net.kyori.adventure.key.Key;
+import net.kyori.adventure.text.event.HoverEvent;
+import net.minecraft.world.item.Item;
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.inventory.meta.ItemMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.function.UnaryOperator;
+
+public class VanillaItemStack implements ItemStack {
+
+    private final net.minecraft.world.item.ItemStack itemStack;
+
+    public VanillaItemStack(@NotNull net.minecraft.world.item.ItemStack vanilla) {
+        this.itemStack = vanilla;
+    }
+
+    @Override
+    public @NotNull Material getMaterial() {
+        return CraftMagicNumbers.getMaterial(this.itemStack.getItem());
+    }
+
+    @Override
+    public void setMaterial(@NotNull Material material) {
+        this.itemStack.setItem(CraftMagicNumbers.getItem(material));
+    }
+
+    @Override
+    public int getSize() {
+        return this.itemStack.getCount();
+    }
+
+    @Override
+    public void setSize(int size) {
+        this.itemStack.setCount(size);
+    }
+
+    @Override
+    public @Nullable ItemMeta getMeta() {
+        return null;
+    }
+
+    @Override
+    public void setMeta(@Nullable ItemMeta meta) {
+
+    }
+
+    @Override
+    public @NotNull HoverEvent<HoverEvent.ShowItem> asHoverEvent(@NotNull UnaryOperator<HoverEvent.ShowItem> op) {
+        Key key = CraftMagicNumbers.getMaterial(this.itemStack.getItem()).getKey();
+
+        return HoverEvent.showItem(op.apply(HoverEvent.ShowItem.of(key, this.itemStack.getCount(), PaperAdventure.asBinaryTagHolder(this.itemStack.getTag()))));
+    }
+
+    @Override
+    public @NotNull String translationKey() {
+        return null;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/MetaPropertySkeletons.java b/src/main/java/io/papermc/paper/item/MetaPropertySkeletons.java
new file mode 100644
index 0000000000000000000000000000000000000000..ed92fbdf46183ce5a84e2f57cef23e6d7cab356f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/MetaPropertySkeletons.java
@@ -0,0 +1,59 @@
+package io.papermc.paper.item;
+
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.value.Value;
+import org.bukkit.potion.PotionData;
+import org.bukkit.potion.PotionType;
+
+import java.util.List;
+
+import static io.papermc.paper.inventory.item.properties.ItemProperties.*;
+
+public interface MetaPropertySkeletons {
+
+
+
+    List<PropertyKey<?>> CRAFT_LEATHER_ARMOR = List.of(
+        COLOR
+    );
+
+    List<PropertyKey<?>> CRAFT_REPAIRABLE = List.of(
+        REPAIR_COST
+    );
+
+    // CraftMetaPotion
+//    PropertyHolder.Immutable DEFAULT_STATE = PropertyHolder.Immutable.builder()
+//        .of(DEFAULT_POTION_TYPE, Value.of(DEFAULT_POTION_TYPE, new PotionData(PotionType.UNCRAFTABLE, false, false)))
+//        .build();
+
+    List<PropertyKey<?>> CRAFT_META_POTION = List.of(
+        DEFAULT_POTION_TYPE,
+        CUSTOM_POTION_EFFECTS,
+        COLOR
+    );
+
+    // CraftMetaSkull
+    List<PropertyKey<?>> CRAFT_META_SKULL = List.of(
+        SKULL_OWNER
+    );
+
+    // CraftMetaSpawnEgg
+    List<PropertyKey<?>> CRAFT_META_SPAWN_EGG = List.of(
+        ENTITY_TAG
+    );
+
+    // CraftMetaSuspiciousStew
+    List<PropertyKey<?>> CRAFT_META_SUSPICIOUS_STEW = List.of(
+        STEW_EFFECTS
+    );
+
+    // CraftMetaTropicalFishBucket
+    List<PropertyKey<?>> CRAFT_META_TROPICAL_FISH_BUCKET = List.of(
+        TROPICAL_FISH_BUCKET_VARIANT,
+        ENTITY_TAG
+    );
+
+
+
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaAxolotlBucket.java b/src/main/java/io/papermc/paper/item/meta/MetaAxolotlBucket.java
new file mode 100644
index 0000000000000000000000000000000000000000..633e974c2abd66713710ae899bec456afaba0c9a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaAxolotlBucket.java
@@ -0,0 +1,43 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.Material;
+import org.bukkit.entity.Axolotl;
+import org.bukkit.inventory.meta.AxolotlBucketMeta;
+import org.jetbrains.annotations.NotNull;
+
+public class MetaAxolotlBucket extends PaperMeta implements AxolotlBucketMeta {
+
+    public MetaAxolotlBucket(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.itemHolder(compoundTag), material);
+    }
+
+    @Override
+    public @NotNull Axolotl.Variant getVariant() {
+        return this.propertyHolder.get(ItemProperties.VARIANT);
+    }
+
+    @Override
+    public void setVariant(Axolotl.@NotNull Variant variant) {
+        this.propertyHolder.set(ItemProperties.VARIANT, variant);
+    }
+
+    @Override
+    public boolean hasVariant() {
+        return this.propertyHolder.hasProperty(ItemProperties.VARIANT);
+    }
+
+    @Override
+    public @NotNull MetaAxolotlBucket clone() {
+        return (MetaAxolotlBucket) super.clone();
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.propertyHolder.unset(ItemProperties.VARIANT);
+        this.propertyHolder.unset(ItemProperties.ENTITY_TAG);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaBanner.java b/src/main/java/io/papermc/paper/item/meta/MetaBanner.java
new file mode 100644
index 0000000000000000000000000000000000000000..a213e7eece9f83470f4cb6ef4b20dc5247885510
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaBanner.java
@@ -0,0 +1,90 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.value.ListValue;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.DyeColor;
+import org.bukkit.Material;
+import org.bukkit.block.banner.Pattern;
+import org.bukkit.inventory.meta.BannerMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+public class MetaBanner extends PaperMeta implements BannerMeta {
+
+    public MetaBanner(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.itemHolder(compoundTag), material);
+    }
+
+    @Override
+    public @NotNull MetaBanner clone() {
+        return (MetaBanner) super.clone();
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.propertyHolder.unset(ItemProperties.BLOCK_ENTITY_TAG);
+    }
+
+    @Override
+    public @Nullable DyeColor getBaseColor() {
+        return this.getFromPropertyPath(ItemProperties.BLOCK_ENTITY_TAG, PaperMetaProperties.BASE);
+    }
+
+    @Override
+    public void setBaseColor(@Nullable DyeColor color) {
+        this.setFromPropertyPath(ItemProperties.BLOCK_ENTITY_TAG, PaperMetaProperties.BASE, color);
+    }
+
+    @Override
+    public @NotNull List<Pattern> getPatterns() {
+        return this.getFromPropertyPath(ItemProperties.BLOCK_ENTITY_TAG, PaperMetaProperties.PATTERNS);
+    }
+
+    @Override
+    public void setPatterns(@NotNull List<Pattern> patterns) {
+        this.setFromPropertyPath(ItemProperties.BLOCK_ENTITY_TAG, PaperMetaProperties.PATTERNS, patterns);
+    }
+
+    @Override
+    public void addPattern(@NotNull Pattern pattern) {
+        PropertyHolder.Mutable holder = this.propertyHolder.getOrCreate(ItemProperties.BLOCK_ENTITY_TAG);
+        ListValue<Pattern> patterns = holder.getOrCreate(PaperMetaProperties.PATTERNS);
+        patterns.add(pattern);
+    }
+
+    @Override
+    public @NotNull Pattern getPattern(int i) {
+        PropertyHolder.Mutable holder = this.propertyHolder.getOrCreate(ItemProperties.BLOCK_ENTITY_TAG);
+        ListValue<Pattern> patterns = holder.getOrCreate(PaperMetaProperties.PATTERNS);
+        return patterns.get(i);
+    }
+
+    @Override
+    public @NotNull Pattern removePattern(int i) {
+        PropertyHolder.Mutable holder = this.propertyHolder.getOrCreate(ItemProperties.BLOCK_ENTITY_TAG);
+        ListValue<Pattern> patterns = holder.getOrCreate(PaperMetaProperties.PATTERNS);
+
+        return patterns.remove(i);
+    }
+
+    @Override
+    public void setPattern(int i, @NotNull Pattern pattern) {
+        PropertyHolder.Mutable holder = this.propertyHolder.getOrCreate(ItemProperties.BLOCK_ENTITY_TAG);
+        ListValue<Pattern> patterns = holder.getOrCreate(PaperMetaProperties.PATTERNS);
+
+        patterns.insert(pattern, i);
+    }
+
+    @Override
+    public int numberOfPatterns() {
+        PropertyHolder.Mutable holder = this.propertyHolder.getOrCreate(ItemProperties.BLOCK_ENTITY_TAG);
+        ListValue<Pattern> patterns = holder.getOrCreate(PaperMetaProperties.PATTERNS);
+
+        return patterns.size();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaBlockState.java b/src/main/java/io/papermc/paper/item/meta/MetaBlockState.java
new file mode 100644
index 0000000000000000000000000000000000000000..40ba70b7a821472a7a22f11094797120fecb99e2
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaBlockState.java
@@ -0,0 +1,108 @@
+package io.papermc.paper.item.meta;
+
+import com.destroystokyo.paper.MaterialSetTag;
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.StoredPropertyHolder;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.value.Value;
+import net.minecraft.nbt.CompoundTag;
+import org.apache.commons.lang.Validate;
+import org.bukkit.DyeColor;
+import org.bukkit.Material;
+import org.bukkit.block.BlockState;
+import org.bukkit.craftbukkit.block.CraftBanner;
+import org.bukkit.craftbukkit.block.CraftBlockEntityState;
+import org.bukkit.craftbukkit.block.CraftBlockStates;
+import org.bukkit.inventory.meta.BlockStateMeta;
+import org.jetbrains.annotations.NotNull;
+
+public class MetaBlockState extends PaperMeta implements BlockStateMeta {
+
+    private static final PropertyKey<Value<String>> IDENTIFIER = PropertyKey.of("id", String.class);
+
+    public MetaBlockState(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.itemHolder(compoundTag), material);
+    }
+
+    @Override
+    public boolean hasBlockState() {
+        return this.propertyHolder.hasProperty(ItemProperties.BLOCK_ENTITY_TAG);
+    }
+
+    @Override
+    public BlockState getBlockState() {
+        StoredPropertyHolder holder = this.propertyHolder.getValue(ItemProperties.BLOCK_ENTITY_TAG);
+
+        Material stateMaterial = (this.material != Material.SHIELD) ? this.material : shieldToBannerHack(holder); // Only actually used for jigsaws
+        if (holder != null) {
+            if (this.material == Material.SHIELD) {
+                holder.set(IDENTIFIER, "minecraft:banner");
+            } else if (this.material == Material.BEE_NEST || this.material == Material.BEEHIVE) {
+                holder.set(IDENTIFIER, "minecraft:beehive");
+            } else if (MaterialSetTag.SHULKER_BOXES.isTagged(this.material)) {
+                holder.set(IDENTIFIER, "minecraft:shulker_box");
+            }
+        }
+
+        // This is expected to always return a CraftBlockEntityState for the passed material:
+        return CraftBlockStates.getBlockState(stateMaterial, null); // TODO
+    }
+
+    @Override
+    public void setBlockState(BlockState blockState) {
+        Validate.notNull(blockState, "blockState must not be null");
+
+        Material stateMaterial = (this.material != Material.SHIELD) ? this.material : shieldToBannerHack(this.propertyHolder.getValue(ItemProperties.BLOCK_ENTITY_TAG));
+        Class<?> blockStateType = CraftBlockStates.getBlockStateType(stateMaterial);
+        Validate.isTrue(blockStateType == blockState.getClass() && blockState instanceof CraftBlockEntityState, "Invalid blockState for " + this.material);
+
+        PropertyHolder.Mutable mutable = NbtPropertyHolder.simpleBlob(((CraftBlockEntityState) blockState).getSnapshotNBT());
+        this.propertyHolder.set(ItemProperties.BLOCK_ENTITY_TAG, mutable);
+        // Set shield base
+        if (this.material == Material.SHIELD) {
+            mutable.set(PaperMetaProperties.BASE, ((CraftBanner) blockState).getBaseColor());
+        }
+    }
+
+    private static Material shieldToBannerHack(StoredPropertyHolder tag) {
+        if (tag == null) {
+            return Material.WHITE_BANNER;
+        }
+
+        DyeColor colorValue = tag.get(PaperMetaProperties.BASE);
+        if (colorValue == null) {
+            return Material.WHITE_BANNER;
+        }
+
+        return switch (colorValue) {
+            case WHITE -> Material.WHITE_BANNER;
+            case ORANGE -> Material.ORANGE_BANNER;
+            case MAGENTA -> Material.MAGENTA_BANNER;
+            case LIGHT_BLUE -> Material.LIGHT_BLUE_BANNER;
+            case YELLOW -> Material.YELLOW_BANNER;
+            case LIME -> Material.LIME_BANNER;
+            case PINK -> Material.PINK_BANNER;
+            case GRAY -> Material.GRAY_BANNER;
+            case LIGHT_GRAY -> Material.LIGHT_GRAY_BANNER;
+            case CYAN -> Material.CYAN_BANNER;
+            case PURPLE -> Material.PURPLE_BANNER;
+            case BLUE -> Material.BLUE_BANNER;
+            case BROWN -> Material.BROWN_BANNER;
+            case GREEN -> Material.GREEN_BANNER;
+            case RED -> Material.RED_BANNER;
+            case BLACK -> Material.BLACK_BANNER;
+        };
+    }
+
+    @Override
+    public @NotNull MetaBlockState clone() {
+        return (MetaBlockState) super.clone();
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.propertyHolder.unset(ItemProperties.BLOCK_ENTITY_TAG);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaBook.java b/src/main/java/io/papermc/paper/item/meta/MetaBook.java
new file mode 100644
index 0000000000000000000000000000000000000000..ce27284fe7aff8bc1962de36597b4314fd54466e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaBook.java
@@ -0,0 +1,475 @@
+package io.papermc.paper.item.meta;
+
+import com.google.common.collect.ImmutableList;
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.nbt.primitives.ComponentNbtPrimitive;
+import io.papermc.paper.property.nbt.types.WrappedListNbt;
+import io.papermc.paper.property.value.ListValue;
+import io.papermc.paper.property.value.Value;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.md_5.bungee.chat.ComponentSerializer;
+import net.minecraft.nbt.CompoundTag;
+import org.apache.commons.lang.Validate;
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
+import org.bukkit.inventory.meta.BookMeta;
+import org.jetbrains.annotations.NotNull;
+import org.spigotmc.ValidateUtils;
+
+import java.util.AbstractList;
+import java.util.Arrays;
+import java.util.List;
+
+// TODO: Cleanup, I hate all of this
+public class MetaBook extends PaperMeta implements BookMeta {
+
+    private static final PropertyKey<ListValue<Component>> PAGES_WRITTEN_STRING_WRAPPER = PropertyKey.ofList("pages", Component.class);
+
+    static final int MAX_PAGES = 100;
+    static final int MAX_PAGE_LENGTH = 320; // 256 limit + 64 characters to allow for psuedo colour codes
+    static final int MAX_TITLE_LENGTH = 32;
+
+
+    public MetaBook(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.configuredItemHolder(compoundTag, (holder) -> {
+            holder.register(PAGES_WRITTEN_STRING_WRAPPER, new WrappedListNbt<>(new ComponentNbtPrimitive()));
+        }), material);
+    }
+
+    @Override
+    public boolean hasAuthor() {
+        return MetaBook.this.propertyHolder.hasProperty(ItemProperties.AUTHOR);
+    }
+
+    @Override
+    public boolean hasTitle() {
+        return MetaBook.this.propertyHolder.hasProperty(ItemProperties.TITLE);
+    }
+
+    @Override
+    public boolean hasPages() {
+        ListValue<Component> pages = this.propertyHolder.getValue(ItemProperties.PAGES);
+        return pages != null && !pages.isEmpty();
+    }
+
+    @Override
+    public boolean hasGeneration() {
+        return this.propertyHolder.hasProperty(ItemProperties.GENERATION);
+    }
+
+    @Override
+    public String getTitle() {
+        String author = MetaBook.this.propertyHolder.get(ItemProperties.AUTHOR);
+        if (author != null) {
+            author = ValidateUtils.limit(author, io.papermc.paper.configuration.GlobalConfiguration.get().itemValidation.book.author);
+        }
+
+        return author;
+    }
+
+    @Override
+    public boolean setTitle(final String title) {
+        if (title == null) {
+            MetaBook.this.propertyHolder.unset(ItemProperties.AUTHOR);
+            return true;
+        } else if (title.length() > MAX_TITLE_LENGTH) {
+            return false;
+        }
+
+        MetaBook.this.propertyHolder.set(ItemProperties.AUTHOR, title);
+        return true;
+    }
+
+    @Override
+    public String getAuthor() {
+        String author = MetaBook.this.propertyHolder.get(ItemProperties.AUTHOR);
+        if (author != null) {
+            author = ValidateUtils.limit(author, io.papermc.paper.configuration.GlobalConfiguration.get().itemValidation.book.author);
+        }
+
+        return author;
+    }
+
+    @Override
+    public void setAuthor(String author) {
+        if (author != null) {
+            author = ValidateUtils.limit(author, io.papermc.paper.configuration.GlobalConfiguration.get().itemValidation.book.author);
+        }
+
+        MetaBook.this.propertyHolder.set(ItemProperties.AUTHOR, author);
+    }
+
+    @Override
+    public Generation getGeneration() {
+        Value<Integer> generation = MetaBook.this.propertyHolder.getValue(ItemProperties.GENERATION);
+
+        return (generation == null) ? null : Generation.values()[generation.getValue()];
+    }
+
+    @Override
+    public void setGeneration(Generation generation) {
+        if (generation == null) {
+            MetaBook.this.propertyHolder.unset(ItemProperties.GENERATION);
+        } else {
+            MetaBook.this.propertyHolder.set(ItemProperties.GENERATION, generation.ordinal());
+        }
+    }
+
+    @Override
+    public net.kyori.adventure.text.Component title() {
+        String title = MetaBook.this.propertyHolder.get(ItemProperties.TITLE);
+        return title == null ? null : net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(title);
+    }
+
+    @Override
+    public org.bukkit.inventory.meta.BookMeta title(net.kyori.adventure.text.Component title) {
+        this.setTitle(title == null ? null : net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().serialize(title));
+        return this;
+    }
+
+    @Override
+    public net.kyori.adventure.text.Component author() {
+        String author = MetaBook.this.propertyHolder.get(ItemProperties.AUTHOR);
+        return author == null ? null : net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(author);
+    }
+
+    @Override
+    public org.bukkit.inventory.meta.BookMeta author(net.kyori.adventure.text.Component author) {
+        this.setAuthor(author == null ? null : net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().serialize(author));
+        return this;
+    }
+
+    @Override
+    public net.kyori.adventure.text.Component page(final int page) {
+        Validate.isTrue(isValidPage(page), "Invalid page number");
+        return MetaBook.this.propertyHolder.getValue(this.getPageProperty()).get(page);
+    }
+
+    @Override
+    public void page(final int page, net.kyori.adventure.text.Component data) {
+        if (!isValidPage(page)) {
+            throw new IllegalArgumentException("Invalid page number " + page + "/" + this.getPageCount());
+        }
+        ListValue<Component> pages = MetaBook.this.propertyHolder.getValue(this.getPageProperty());
+
+        if (data == null) {
+            data = net.kyori.adventure.text.Component.empty();
+        }
+        pages.insert(data, page - 1);
+    }
+
+    @Override
+    public List<net.kyori.adventure.text.Component> pages() {
+        ListValue<Component> pages = MetaBook.this.propertyHolder.getValue(this.getPageProperty());
+        if (pages == null) {
+            return List.of();
+        }
+
+        return pages.getValue();
+    }
+
+    @Override
+    public BookMeta pages(List<net.kyori.adventure.text.Component> pages) {
+        MetaBook.this.propertyHolder.unset(this.getPageProperty());
+        for (net.kyori.adventure.text.Component page : pages) {
+            addPages(page);
+        }
+        return this;
+    }
+
+    @Override
+    public BookMeta pages(net.kyori.adventure.text.Component... pages) {
+        MetaBook.this.propertyHolder.unset(this.getPageProperty());
+        addPages(pages);
+        return this;
+    }
+
+    @Override
+    public void addPages(net.kyori.adventure.text.Component... pages) {
+        ListValue<Component> pageList = MetaBook.this.propertyHolder.getValue(this.getPageProperty());
+        for (net.kyori.adventure.text.Component page : pages) {
+            if (pageList.size() >= MAX_PAGES) {
+                return;
+            }
+
+            if (page == null) {
+                page = net.kyori.adventure.text.Component.empty();
+            }
+
+            pageList.add(page);
+        }
+    }
+
+    public PropertyKey<ListValue<Component>> getPageProperty() {
+        return PAGES_WRITTEN_STRING_WRAPPER;
+    }
+
+    static class CraftMetaBookBuilder implements BookMetaBuilder {
+        private net.kyori.adventure.text.Component title = null;
+        private net.kyori.adventure.text.Component author = null;
+        private final List<net.kyori.adventure.text.Component> pages = new java.util.ArrayList<>();
+
+        @Override
+        public BookMetaBuilder title(net.kyori.adventure.text.Component title) {
+            this.title = title;
+            return this;
+        }
+
+        @Override
+        public BookMetaBuilder author(net.kyori.adventure.text.Component author) {
+            this.author = author;
+            return this;
+        }
+
+        @Override
+        public BookMetaBuilder addPage(net.kyori.adventure.text.Component page) {
+            this.pages.add(page);
+            return this;
+        }
+
+        @Override
+        public BookMetaBuilder pages(net.kyori.adventure.text.Component... pages) {
+            java.util.Collections.addAll(this.pages, pages);
+            return this;
+        }
+
+        @Override
+        public BookMetaBuilder pages(java.util.Collection<net.kyori.adventure.text.Component> pages) {
+            this.pages.addAll(pages);
+            return this;
+        }
+
+        @Override
+        public BookMeta build() {
+            return this.build(title, author, pages);
+        }
+
+        protected BookMeta build(net.kyori.adventure.text.Component title, net.kyori.adventure.text.Component author, java.util.List<net.kyori.adventure.text.Component> pages) {
+            MetaBook metaBook = new MetaBook(new CompoundTag(), Material.WRITTEN_BOOK);
+            metaBook.propertyHolder.set(ItemProperties.TITLE, LegacyComponentSerializer.legacySection().serialize(title));
+            metaBook.propertyHolder.set(ItemProperties.AUTHOR, LegacyComponentSerializer.legacySection().serialize(author));
+            metaBook.propertyHolder.set(ItemProperties.PAGES, pages);
+
+            return metaBook;
+        }
+    }
+
+    @Override
+    public BookMetaBuilder toBuilder() {
+        return new MetaBook.CraftMetaBookBuilder();
+    }
+
+    @Override
+    public String getPage(final int page) {
+        Validate.isTrue(this.isValidPage(page), "Invalid page number");
+        // assert: pages != null
+        return this.convertDataToPlainPage(MetaBook.this.propertyHolder.getValue(PAGES_LEGACY).get(page - 1));
+    }
+
+    @Override
+    public void setPage(final int page, final String text) {
+        if (!this.isValidPage(page)) {
+            throw new IllegalArgumentException("Invalid page number " + page + "/" + this.getPageCount());
+        }
+        // assert: pages != null
+
+        String newText = this.validatePage(text);
+        MetaBook.this.propertyHolder.getValue(PAGES_LEGACY).insert(this.convertPlainPageToData(newText), page - 1);
+    }
+
+    @Override
+    public void setPages(final String... pages) {
+        this.setPages(Arrays.asList(pages));
+    }
+
+    @Override
+    public void addPage(final String... pages) {
+        for (String page : pages) {
+            page = this.validatePage(page);
+            this.internalAddPage(this.convertPlainPageToData(page));
+        }
+    }
+
+    String validatePage(String page) {
+        if (page == null) {
+            page = "";
+        } else if (page.length() > MAX_PAGE_LENGTH) {
+            page = page.substring(0, MAX_PAGE_LENGTH);
+        }
+        return page;
+    }
+
+    @Override
+    public int getPageCount() {
+        ListValue<String> pages = MetaBook.this.propertyHolder.getValue(PAGES_LEGACY);
+        return (pages == null) ? 0 : pages.size();
+    }
+
+    @Override
+    public List<String> getPages() {
+        List<String> pages = MetaBook.this.propertyHolder.getOrDefault(PAGES_LEGACY, List.of());
+
+        return pages.stream().map(this::convertDataToPlainPage).collect(ImmutableList.toImmutableList());
+    }
+
+    @Override
+    public void setPages(List<String> pages) {
+        MetaBook.this.propertyHolder.unset(PAGES_LEGACY);
+        if (pages.isEmpty()) {
+            return;
+        }
+
+        for (String page : pages) {
+            this.addPage(page);
+        }
+    }
+
+    protected String convertPlainPageToData(String page) {
+        // Writable books store their data as plain Strings, so we don't need to convert anything.
+        return page;
+    }
+
+    protected String convertDataToPlainPage(String pageData) {
+        // pageData is expected to already be a plain String.
+        return pageData;
+    }
+
+
+    // Legacy Spigot IMPL
+    private static final PropertyKey<ListValue<String>> PAGES_LEGACY = PropertyKey.ofList("pages", String.class);
+
+    private final BookMeta.Spigot spigot = new SpigotMeta();
+
+    private class SpigotMeta extends BookMeta.Spigot {
+
+        private String pageToJSON(String page) {
+            if (MetaBook.this instanceof MetaBookSigned) {
+                // Page data is already in JSON format:
+                return page;
+            } else {
+                // Convert from plain String to JSON (similar to conversion between writable books and written books):
+                net.minecraft.network.chat.Component component = CraftChatMessage.fromString(page, true, true)[0];
+                return CraftChatMessage.toJSON(component);
+            }
+        }
+
+        private String componentsToPage(BaseComponent[] components) {
+            // asserted: components != null
+            if (MetaBook.this instanceof MetaBookSigned) {
+                // Pages are in JSON format:
+                return ComponentSerializer.toString(components);
+            } else {
+                // Convert component to plain String:
+                return CraftChatMessage.fromJSONComponent(ComponentSerializer.toString(components));
+            }
+        }
+
+        @Override
+        public BaseComponent[] getPage(final int page) {
+            Validate.isTrue(MetaBook.this.isValidPage(page), "Invalid page number");
+            return ComponentSerializer.parse(this.pageToJSON(MetaBook.this.propertyHolder.get(PAGES_LEGACY).get(page - 1)));
+        }
+
+        @Override
+        public void setPage(final int page, final BaseComponent... text) {
+            if (!MetaBook.this.isValidPage(page)) {
+                throw new IllegalArgumentException("Invalid page number " + page + "/" + MetaBook.this.getPageCount());
+            }
+
+            BaseComponent[] newText = text == null ? new BaseComponent[0] : text;
+            MetaBook.this.propertyHolder.get(PAGES_LEGACY).set(page - 1, this.componentsToPage(newText));
+        }
+
+        @Override
+        public void setPages(final BaseComponent[]... pages) {
+            this.setPages(Arrays.asList(pages));
+        }
+
+        @Override
+        public void addPage(final BaseComponent[]... pages) {
+            for (BaseComponent[] page : pages) {
+                if (page == null) {
+                    page = new BaseComponent[0];
+                }
+
+                MetaBook.this.internalAddPage(this.componentsToPage(page));
+            }
+        }
+
+        @Override
+        public List<BaseComponent[]> getPages() {
+            ListValue<String> pages = MetaBook.this.propertyHolder.getValue(PAGES_LEGACY);
+            if (pages == null || pages.isEmpty()) {
+                return List.of();
+            }
+
+            return new AbstractList<BaseComponent[]>() {
+
+                @Override
+                public BaseComponent[] get(int index) {
+                    return ComponentSerializer.parse(MetaBook.SpigotMeta.this.pageToJSON(pages.get(index)));
+                }
+
+                @Override
+                public int size() {
+                    return pages.size();
+                }
+            };
+        }
+
+        @Override
+        public void setPages(List<BaseComponent[]> pages) {
+            MetaBook.this.propertyHolder.unset(PAGES_LEGACY);
+            if (pages.isEmpty()) {
+                return;
+            }
+
+            for (BaseComponent[] page : pages) {
+                this.addPage(page);
+            }
+        }
+    }
+
+    // Utilities
+    private boolean isValidPage(int page) {
+        return page > 0 && page <= this.getPageCount();
+    }
+
+    private void internalAddPage(String page) {
+        // asserted: page != null
+        ListValue<String> pages = MetaBook.this.propertyHolder.getValue(PAGES_LEGACY);
+        if (pages != null && pages.size() >= MAX_PAGES) {
+            return;
+        } else if (pages == null) {
+            pages = MetaBook.this.propertyHolder.create(PAGES_LEGACY);
+        }
+
+        pages.add(page);
+    }
+
+    @Override
+    public BookMeta.Spigot spigot() {
+        return this.spigot;
+    }
+
+    @Override
+    public @NotNull MetaBook clone() {
+        return (MetaBook) super.clone();
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.propertyHolder.unset(ItemProperties.TITLE);
+        this.propertyHolder.unset(ItemProperties.TITLE_FILTERED);
+        this.propertyHolder.unset(ItemProperties.AUTHOR);
+        this.propertyHolder.unset(ItemProperties.PAGES);
+        this.propertyHolder.unset(ItemProperties.PAGES_FILTERED);
+        this.propertyHolder.unset(ItemProperties.GENERATION);
+        this.propertyHolder.unset(ItemProperties.RESOLVED);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaBookSigned.java b/src/main/java/io/papermc/paper/item/meta/MetaBookSigned.java
new file mode 100644
index 0000000000000000000000000000000000000000..f47d69abf71f487e1945e556a81777a6c7053a38
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaBookSigned.java
@@ -0,0 +1,41 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.value.ListValue;
+import net.kyori.adventure.text.Component;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
+import org.bukkit.inventory.meta.BookMeta;
+import org.jetbrains.annotations.NotNull;
+
+public class MetaBookSigned extends MetaBook implements BookMeta {
+
+    public MetaBookSigned(CompoundTag compoundTag, Material material) {
+        super(compoundTag, material);
+    }
+
+    @Override
+    protected String convertPlainPageToData(String page) {
+        return CraftChatMessage.fromStringToJSON(page, true);
+    }
+
+    @Override
+    protected String convertDataToPlainPage(String pageData) {
+        return CraftChatMessage.fromJSONComponent(pageData);
+    }
+
+    @Override
+    public PropertyKey<ListValue<Component>> getPageProperty() {
+        return ItemProperties.PAGES;
+    }
+
+    @Override
+    public @NotNull MetaBookSigned clone() {
+        return (MetaBookSigned) super.clone();
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaBundle.java b/src/main/java/io/papermc/paper/item/meta/MetaBundle.java
new file mode 100644
index 0000000000000000000000000000000000000000..735ee3a4be50406d9b468d2cbf191329df685aef
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaBundle.java
@@ -0,0 +1,62 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.value.ListValue;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.Material;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.BundleMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+public class MetaBundle extends PaperMeta implements BundleMeta {
+
+    public MetaBundle(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.itemHolder(compoundTag), material);
+    }
+
+    @Override
+    boolean isEmpty() {
+        return super.isEmpty() && this.isBundleEmpty();
+    }
+
+    boolean isBundleEmpty() {
+        return !(this.hasItems());
+    }
+
+    @Override
+    public boolean hasItems() {
+        ListValue<ItemStack> items = this.propertyHolder.getValue(ItemProperties.ITEMS);
+        return items != null && !items.isEmpty();
+    }
+
+    @Override
+    public @NotNull List<ItemStack> getItems() {
+        return this.propertyHolder.getValue(ItemProperties.ITEMS).getValue();
+    }
+
+    @Override
+    public void setItems(@Nullable List<ItemStack> items) {
+        this.propertyHolder.set(ItemProperties.ITEMS, items);
+    }
+
+    @Override
+    public void addItem(@NotNull ItemStack item) {
+        ListValue<ItemStack> items = this.propertyHolder.getOrCreate(ItemProperties.ITEMS);
+        items.add(item);
+    }
+
+    @Override
+    public @NotNull MetaBundle clone() {
+        return (MetaBundle) super.clone();
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.propertyHolder.unset(ItemProperties.ITEMS);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaCompass.java b/src/main/java/io/papermc/paper/item/meta/MetaCompass.java
new file mode 100644
index 0000000000000000000000000000000000000000..41775f608e4f03097b5d2a325d7b9ccdbfb3bfb1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaCompass.java
@@ -0,0 +1,85 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.math.Position;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.Material;
+import org.bukkit.NamespacedKey;
+import org.bukkit.World;
+import org.bukkit.inventory.meta.CompassMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class MetaCompass extends PaperMeta implements CompassMeta {
+
+    public MetaCompass(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.itemHolder(compoundTag), material);
+    }
+
+    @Override
+    boolean isEmpty() {
+        return super.isEmpty() && this.isCompassEmpty();
+    }
+
+    boolean isCompassEmpty() {
+        return !(this.hasLodestone() || this.hasLodestoneTracked());
+    }
+
+    boolean hasLodestoneTracked() {
+        return this.propertyHolder.hasProperty(ItemProperties.LODESTONE_TRACKED);
+    }
+
+    @Override
+    public boolean hasLodestone() {
+        return this.propertyHolder.hasProperty(ItemProperties.LODESTONE_DIMENSION);
+    }
+
+    @Override
+    public @Nullable Location getLodestone() {
+        NamespacedKey dimension = this.propertyHolder.get(ItemProperties.LODESTONE_DIMENSION);
+        if (dimension == null) {
+            return null;
+        }
+
+        World world = Bukkit.getWorld(dimension);
+
+        Position position = this.propertyHolder.get(ItemProperties.LODESTONE_POS);
+        if (position == null) {
+            return null;
+        }
+
+        return position.toLocation(world);
+    }
+
+    @Override
+    public void setLodestone(@Nullable Location lodestone) {
+        this.propertyHolder.set(ItemProperties.LODESTONE_POS, lodestone);
+        this.propertyHolder.set(ItemProperties.LODESTONE_DIMENSION, lodestone.getWorld().getKey());
+    }
+
+    @Override
+    public boolean isLodestoneTracked() {
+        return this.propertyHolder.getOrDefault(ItemProperties.LODESTONE_TRACKED, false);
+    }
+
+    @Override
+    public void setLodestoneTracked(boolean tracked) {
+        this.propertyHolder.set(ItemProperties.LODESTONE_TRACKED, tracked);
+    }
+
+    @Override
+    public @NotNull MetaCompass clone() {
+        return (MetaCompass) super.clone();
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.propertyHolder.unset(ItemProperties.LODESTONE_DIMENSION);
+        this.propertyHolder.unset(ItemProperties.LODESTONE_POS);
+        this.propertyHolder.unset(ItemProperties.LODESTONE_TRACKED);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaCrossbow.java b/src/main/java/io/papermc/paper/item/meta/MetaCrossbow.java
new file mode 100644
index 0000000000000000000000000000000000000000..b9c9df0f66e6e029a3056a2ef0bef422871ca0a1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaCrossbow.java
@@ -0,0 +1,79 @@
+package io.papermc.paper.item.meta;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.value.ListValue;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.world.item.ArrowItem;
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.CrossbowMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+public class MetaCrossbow extends PaperMeta implements CrossbowMeta {
+
+    public MetaCrossbow(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.itemHolder(compoundTag), material);
+    }
+
+    @Override
+    boolean isEmpty() {
+        return super.isEmpty() && this.isCrossbowEmpty();
+    }
+
+    boolean isCrossbowEmpty() {
+        return !(this.hasChargedProjectiles());
+    }
+
+    @Override
+    public boolean hasChargedProjectiles() {
+        ListValue<ItemStack> effects = this.propertyHolder.getValue(ItemProperties.CHARGED_PROJECTILES);
+        return effects != null && !effects.isEmpty();
+    }
+
+    @Override
+    public @NotNull List<ItemStack> getChargedProjectiles() {
+        return this.propertyHolder.getOrDefault(ItemProperties.CHARGED_PROJECTILES, List.of());
+    }
+
+    @Override
+    public void setChargedProjectiles(@Nullable List<ItemStack> projectiles) {
+        this.propertyHolder.unset(ItemProperties.CHARGED_PROJECTILES);
+        this.propertyHolder.set(ItemProperties.CHARGED, false);
+
+        if (projectiles == null) {
+            return;
+        }
+
+        for (ItemStack i : projectiles) {
+            this.addChargedProjectile(i);
+        }
+    }
+
+    @Override
+    public void addChargedProjectile(@NotNull ItemStack item) {
+        Preconditions.checkArgument(item != null, "item");
+        Preconditions.checkArgument(item.getType() == Material.FIREWORK_ROCKET || CraftMagicNumbers.getItem(item.getType()) instanceof ArrowItem, "Item %s is not an arrow or firework rocket", item);
+
+        this.propertyHolder.set(ItemProperties.CHARGED, true);
+        this.propertyHolder.getOrCreate(ItemProperties.CHARGED_PROJECTILES).add(item);
+    }
+
+    @Override
+    public @NotNull MetaCrossbow clone() {
+        return (MetaCrossbow) super.clone();
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.propertyHolder.unset(ItemProperties.CHARGED);
+        this.propertyHolder.unset(ItemProperties.CHARGED_PROJECTILES);
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaEnchantmentStorage.java b/src/main/java/io/papermc/paper/item/meta/MetaEnchantmentStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..d6a96505bbf3e3bde0184e3d0ef1db6e8d372153
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaEnchantmentStorage.java
@@ -0,0 +1,106 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.value.MapValue;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.Material;
+import org.bukkit.enchantments.Enchantment;
+import org.bukkit.inventory.meta.EnchantmentStorageMeta;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Map;
+
+public class MetaEnchantmentStorage extends PaperMeta implements EnchantmentStorageMeta {
+
+    public MetaEnchantmentStorage(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.itemHolder(compoundTag), material);
+    }
+
+    @Override
+    boolean isEmpty() {
+        return super.isEmpty() && this.isEnchantedEmpty();
+    }
+
+    boolean isEnchantedEmpty() {
+        return !this.hasStoredEnchants();
+    }
+
+    @Override
+    public boolean hasStoredEnchant(Enchantment ench) {
+        MapValue<Enchantment, Integer> mapValue = this.propertyHolder.getValue(ItemProperties.STORED_ENCHANTMENTS);
+        if (mapValue == null) {
+            return false;
+        }
+
+        return mapValue.has(ench);
+    }
+
+    @Override
+    public int getStoredEnchantLevel(Enchantment ench) {
+        MapValue<Enchantment, Integer> mapValue = this.propertyHolder.getValue(ItemProperties.STORED_ENCHANTMENTS);
+        if (mapValue == null) {
+            return 0;
+        }
+
+        return mapValue.getEntry(ench);
+    }
+
+    @Override
+    public Map<Enchantment, Integer> getStoredEnchants() {
+        return this.propertyHolder.getOrCreate(ItemProperties.STORED_ENCHANTMENTS).getValue();
+    }
+
+    @Override
+    public boolean addStoredEnchant(Enchantment ench, int level, boolean ignoreRestrictions) {
+        if (ignoreRestrictions || level >= ench.getStartLevel() && level <= ench.getMaxLevel()) {
+            MapValue<Enchantment, Integer> enchantmentMap = this.propertyHolder.getOrCreate(ItemProperties.STORED_ENCHANTMENTS);
+
+            Integer old = enchantmentMap.put(ench, level);
+            return old == null || old != level;
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean removeStoredEnchant(Enchantment ench) {
+        MapValue<Enchantment, Integer> enchantmentMap = this.propertyHolder.getValue(ItemProperties.STORED_ENCHANTMENTS);
+        if (enchantmentMap == null) {
+            return false;
+        }
+
+        return enchantmentMap.removeEntry(ench);
+    }
+
+    @Override
+    public boolean hasStoredEnchants() {
+        return this.propertyHolder.hasProperty(ItemProperties.STORED_ENCHANTMENTS) && !this.propertyHolder.getValue(ItemProperties.STORED_ENCHANTMENTS).isEmpty();
+    }
+
+    @Override
+    public boolean hasConflictingStoredEnchant(Enchantment ench) {
+        if (!hasStoredEnchants()) {
+            return false;
+        }
+
+        for (Map.Entry<Enchantment, Integer> enchant : this.propertyHolder.getOrDefault(ItemProperties.STORED_ENCHANTMENTS, Map.of()).entrySet()) {
+            if (enchant.getKey().conflictsWith(ench)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public @NotNull MetaEnchantmentStorage clone() {
+        return (MetaEnchantmentStorage) super.clone();
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.propertyHolder.unset(ItemProperties.STORED_ENCHANTMENTS);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaFirework.java b/src/main/java/io/papermc/paper/item/meta/MetaFirework.java
new file mode 100644
index 0000000000000000000000000000000000000000..7825ff86fdd51e4eacd59e88b001c68ec30aff0d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaFirework.java
@@ -0,0 +1,112 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.value.ListValue;
+import net.minecraft.nbt.CompoundTag;
+import org.apache.commons.lang.Validate;
+import org.bukkit.FireworkEffect;
+import org.bukkit.Material;
+import org.bukkit.inventory.meta.FireworkMeta;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class MetaFirework extends PaperMeta implements FireworkMeta {
+
+    public MetaFirework(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.itemHolder(compoundTag), material);
+    }
+
+    @Override
+    boolean isEmpty() {
+        return super.isEmpty() && this.isFireworkEmpty();
+    }
+
+    boolean isFireworkEmpty() {
+        return !(this.hasEffects() || this.hasPower());
+    }
+
+    boolean hasPower() {
+        return this.getPower() != 0;
+    }
+
+    @Override
+    public boolean hasEffects() {
+        ListValue<FireworkEffect> effects = this.propertyHolder.getValue(ItemProperties.EXPLOSIONS);
+        return effects != null && !effects.isEmpty();
+    }
+
+    @Override
+    public void addEffect(FireworkEffect effect) {
+        this.addEffects(List.of(effect));
+    }
+
+    @Override
+    public void addEffects(FireworkEffect... effects) {
+        if (effects.length == 0) {
+            return;
+        }
+
+        this.addEffects(List.of(effects));
+    }
+
+    @Override
+    public void addEffects(Iterable<FireworkEffect> effects) {
+        ListValue<FireworkEffect> explosions = this.propertyHolder.getOrCreate(ItemProperties.EXPLOSIONS);
+        for (FireworkEffect fireworkEffect : effects) {
+            explosions.add(fireworkEffect);
+        }
+    }
+
+    @Override
+    public List<FireworkEffect> getEffects() {
+        return this.propertyHolder.getValue(ItemProperties.EXPLOSIONS).getValue();
+    }
+
+    @Override
+    public int getEffectsSize() {
+        ListValue<FireworkEffect> effects = this.propertyHolder.getValue(ItemProperties.EXPLOSIONS);
+        return effects == null ? 0 : effects.size();
+    }
+
+    @Override
+    public void removeEffect(int index) {
+        ListValue<FireworkEffect> effects = this.propertyHolder.getValue(ItemProperties.EXPLOSIONS);
+        if (effects == null) {
+            throw new IndexOutOfBoundsException("Index: " + index + ", Size: 0");
+        } else {
+            effects.remove(index);
+        }
+    }
+
+    @Override
+    public void clearEffects() {
+        this.propertyHolder.unset(ItemProperties.EXPLOSIONS);
+    }
+
+    @Override
+    public int getPower() {
+        return this.propertyHolder.getOrDefault(ItemProperties.FLIGHT, (byte) 0);
+    }
+
+    @Override
+    public void setPower(int power) {
+        Validate.isTrue(power >= 0, "Power cannot be less than zero: ", power);
+        Validate.isTrue(power < 0x80, "Power cannot be more than 127: ", power);
+        this.propertyHolder.set(ItemProperties.FLIGHT, (byte) power);
+    }
+
+
+    @Override
+    public @NotNull MetaFirework clone() {
+        return (MetaFirework) super.clone();
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.propertyHolder.unset(ItemProperties.FLIGHT);
+        this.propertyHolder.unset(ItemProperties.EXPLOSIONS);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaFireworkEffect.java b/src/main/java/io/papermc/paper/item/meta/MetaFireworkEffect.java
new file mode 100644
index 0000000000000000000000000000000000000000..f6b5de66a42648f7c8d7e46deeb4549ec258e0fd
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaFireworkEffect.java
@@ -0,0 +1,52 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.FireworkEffect;
+import org.bukkit.Material;
+import org.bukkit.inventory.meta.FireworkEffectMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class MetaFireworkEffect extends PaperMeta implements FireworkEffectMeta {
+
+    public MetaFireworkEffect(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.itemHolder(compoundTag), material);
+    }
+
+    @Override
+    boolean isEmpty() {
+        return super.isEmpty() && !this.hasChargeMeta();
+    }
+
+    boolean hasChargeMeta() {
+        return this.hasEffect();
+    }
+
+    @Override
+    public void setEffect(@Nullable FireworkEffect effect) {
+        this.propertyHolder.set(ItemProperties.EXPLOSION, effect);
+    }
+
+    @Override
+    public boolean hasEffect() {
+        return this.propertyHolder.hasProperty(ItemProperties.EXPLOSION);
+    }
+
+    @Override
+    public @Nullable FireworkEffect getEffect() {
+        return this.propertyHolder.get(ItemProperties.EXPLOSION);
+    }
+
+    @Override
+    public @NotNull MetaFireworkEffect clone() {
+        return (MetaFireworkEffect) super.clone();
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.propertyHolder.unset(ItemProperties.EXPLOSION);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaKnowledgeBook.java b/src/main/java/io/papermc/paper/item/meta/MetaKnowledgeBook.java
new file mode 100644
index 0000000000000000000000000000000000000000..f4d3370fdedb05dc0f0935046e0666e92b2a74d3
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaKnowledgeBook.java
@@ -0,0 +1,69 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.value.ListValue;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.Material;
+import org.bukkit.NamespacedKey;
+import org.bukkit.inventory.meta.KnowledgeBookMeta;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class MetaKnowledgeBook extends PaperMeta implements KnowledgeBookMeta {
+
+    static final int MAX_RECIPES = Short.MAX_VALUE;
+
+    public MetaKnowledgeBook(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.itemHolder(compoundTag), material);
+    }
+
+    @Override
+    boolean isEmpty() {
+        return super.isEmpty() && this.isBookEmpty();
+    }
+
+    boolean isBookEmpty() {
+        return !(this.hasRecipes());
+    }
+
+    @Override
+    public boolean hasRecipes() {
+        ListValue<NamespacedKey> effects = this.propertyHolder.getValue(ItemProperties.RECIPES);
+        return effects != null && !effects.isEmpty();
+    }
+
+    @Override
+    public @NotNull List<NamespacedKey> getRecipes() {
+        return this.propertyHolder.getOrDefault(ItemProperties.RECIPES, List.of());
+    }
+
+    @Override
+    public void setRecipes(@NotNull List<NamespacedKey> recipes) {
+        this.propertyHolder.set(ItemProperties.RECIPES, recipes);
+    }
+
+    @Override
+    public void addRecipe(@NotNull NamespacedKey... recipes) {
+        ListValue<NamespacedKey> keys = this.propertyHolder.getOrCreate(ItemProperties.RECIPES);
+        for (NamespacedKey key : recipes) {
+            if (keys.size() > MAX_RECIPES) {
+                break;
+            }
+
+            keys.add(key);
+        }
+    }
+
+    @Override
+    public @NotNull KnowledgeBookMeta clone() {
+        return (KnowledgeBookMeta) super.clone();
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.propertyHolder.unset(ItemProperties.RECIPES);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaLeatherArmor.java b/src/main/java/io/papermc/paper/item/meta/MetaLeatherArmor.java
new file mode 100644
index 0000000000000000000000000000000000000000..ee5cf99c84329b58b373805b6be7f8bcc3bb0e1a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaLeatherArmor.java
@@ -0,0 +1,59 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.Color;
+import org.bukkit.Material;
+import org.bukkit.inventory.meta.LeatherArmorMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class MetaLeatherArmor extends PaperMeta implements LeatherArmorMeta {
+
+    private static final Color DEFAULT_LEATHER_COLOR = Color.fromRGB(0xA06540);
+
+    public MetaLeatherArmor(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.itemHolder(compoundTag), material);
+    }
+
+    @Override
+    boolean isEmpty() {
+        return super.isEmpty() && this.isLeatherArmorEmpty();
+    }
+
+    boolean isLeatherArmorEmpty() {
+        return !(this.hasColor());
+    }
+
+    boolean hasColor() {
+        Color color = this.getColor();
+        if (color == null) {
+            return false;
+        }
+
+        // LEGACY
+        return !DEFAULT_LEATHER_COLOR.equals(color);
+    }
+
+    @Override
+    public @Nullable Color getColor() {
+        return this.getFromPropertyPath(ItemProperties.DISPLAY, ItemProperties.COLOR);
+    }
+
+    @Override
+    public void setColor(@Nullable Color color) {
+        this.setFromPropertyPath(ItemProperties.DISPLAY, ItemProperties.COLOR, color);
+    }
+
+    @Override
+    public @NotNull MetaLeatherArmor clone() {
+        return (MetaLeatherArmor) super.clone();
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.unsetInPropertyPath(ItemProperties.DISPLAY, ItemProperties.COLOR);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaMap.java b/src/main/java/io/papermc/paper/item/meta/MetaMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..d155053c30076c1524fbde5980ba0cc65f4c28fd
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaMap.java
@@ -0,0 +1,121 @@
+package io.papermc.paper.item.meta;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.Bukkit;
+import org.bukkit.Color;
+import org.bukkit.Material;
+import org.bukkit.inventory.meta.MapMeta;
+import org.bukkit.map.MapView;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class MetaMap extends PaperMeta implements MapMeta {
+
+    public MetaMap(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.itemHolder(compoundTag), material);
+    }
+
+    @Override
+    boolean isEmpty() {
+        return super.isEmpty() && this.isMapEmpty();
+    }
+
+    boolean isMapEmpty() {
+        return !(this.hasMapId() || this.hasScaling() | this.hasLocationName() || this.hasColor());
+    }
+
+    @Override
+    public boolean hasMapId() {
+        return this.propertyHolder.hasProperty(ItemProperties.MAP_ID);
+    }
+
+    @Override
+    public int getMapId() {
+        Integer mapId = this.propertyHolder.get(ItemProperties.MAP_ID);
+        Preconditions.checkState(mapId != null, "Item does not have map associated - check hasMapView() first!");
+
+        return mapId.intValue();
+    }
+
+    @Override
+    public void setMapId(int id) {
+        this.propertyHolder.set(ItemProperties.MAP_ID, id);
+    }
+
+    @Override
+    public boolean hasMapView() {
+        return this.hasMapId();
+    }
+
+    @Override
+    public MapView getMapView() {
+        return Bukkit.getMap(this.getMapId());
+    }
+
+    @Override
+    public void setMapView(MapView map) {
+        this.propertyHolder.set(ItemProperties.MAP_ID, (map != null) ? map.getId() : null);
+    }
+
+    @Override
+    public boolean isScaling() {
+        return this.propertyHolder.getOrDefault(ItemProperties.MAP_SCALE_DIRECTION, (byte) 0) > 0;
+    }
+
+    @Override
+    public void setScaling(boolean value) {
+        this.propertyHolder.set(ItemProperties.MAP_SCALE_DIRECTION, (byte) (value ? 1 : 0));
+    }
+
+    boolean hasScaling() {
+        return this.isScaling();
+    }
+
+    // isn't wrapped in a display tag....
+    // Stupid legacy!
+    @Override
+    public boolean hasLocationName() {
+        return this.propertyHolder.hasProperty(ItemProperties.LOC_NAME);
+    }
+
+    @Override
+    public @Nullable String getLocationName() {
+        return this.propertyHolder.get(ItemProperties.LOC_NAME);
+    }
+
+    @Override
+    public void setLocationName(@Nullable String name) {
+        this.propertyHolder.set(ItemProperties.LOC_NAME, name);
+    }
+
+    @Override
+    public boolean hasColor() {
+        return this.hasInPropertyPath(ItemProperties.DISPLAY, ItemProperties.MAP_COLOR);
+    }
+
+    @Override
+    public @Nullable Color getColor() {
+        return this.getFromPropertyPath(ItemProperties.DISPLAY, ItemProperties.MAP_COLOR);
+    }
+
+    @Override
+    public void setColor(@Nullable Color color) {
+        this.setFromPropertyPath(ItemProperties.DISPLAY, ItemProperties.MAP_COLOR, color);
+    }
+
+    @Override
+    public @NotNull MetaMap clone() {
+        return (MetaMap) super.clone();
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.propertyHolder.unset(ItemProperties.MAP_ID);
+        this.unsetInPropertyPath(ItemProperties.DISPLAY, ItemProperties.MAP_COLOR);
+        this.propertyHolder.unset(ItemProperties.MAP_SCALE_DIRECTION);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaPlayerHead.java b/src/main/java/io/papermc/paper/item/meta/MetaPlayerHead.java
new file mode 100644
index 0000000000000000000000000000000000000000..dc02284dd45816642f383545ca97fe8a4264200f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaPlayerHead.java
@@ -0,0 +1,163 @@
+package io.papermc.paper.item.meta;
+
+import com.destroystokyo.paper.profile.PlayerProfile;
+import com.mojang.authlib.GameProfile;
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.inventory.item.properties.PlayerHeadPartial;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.Bukkit;
+import org.bukkit.Material;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.craftbukkit.profile.CraftPlayerProfile;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.meta.SkullMeta;
+import org.jetbrains.annotations.NotNull;
+
+// Ignores the STRING "SkullOwner" property, as that is temporary
+public class MetaPlayerHead extends PaperMeta implements SkullMeta {
+
+    static final int MAX_OWNER_LENGTH = 16;
+
+    public MetaPlayerHead(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.itemHolder(compoundTag), material);
+    }
+
+    @Override
+    boolean isEmpty() {
+        return super.isEmpty() && this.isSkullEmpty();
+    }
+
+    boolean isSkullEmpty() {
+        return !this.propertyHolder.hasProperty(ItemProperties.SKULL_OWNER);
+    }
+
+    @Override
+    public boolean hasOwner() {
+        PlayerHeadPartial partial = this.propertyHolder.get(ItemProperties.SKULL_OWNER);
+        if (partial == null) {
+            return false;
+        }
+        if (partial.profile() == null && partial.playerName() == null) {
+            return false;
+        }
+
+        if (partial.profile() != null && partial.profile().getName() != null) {
+            return true;
+        }
+
+        return false;
+    }
+
+    @Override
+    public String getOwner() {
+        PlayerHeadPartial partial = this.propertyHolder.get(ItemProperties.SKULL_OWNER);
+        if (partial == null) {
+            return null;
+        }
+        if (partial.profile() != null && partial.profile().getName() != null) {
+            return partial.profile().getName();
+        }
+
+        return null;
+    }
+
+    // Paper start
+    @Override
+    public void setPlayerProfile(@org.jetbrains.annotations.Nullable com.destroystokyo.paper.profile.PlayerProfile profile) {
+        setProfile(profile);
+    }
+
+    @org.jetbrains.annotations.Nullable
+    @Override
+    public com.destroystokyo.paper.profile.PlayerProfile getPlayerProfile() {
+        PlayerHeadPartial partial = this.propertyHolder.get(ItemProperties.SKULL_OWNER);
+
+        return partial != null ? partial.profile() : null;
+    }
+    // Paper end
+
+    @Override
+    public OfflinePlayer getOwningPlayer() {
+        if (this.hasOwner()) {
+            PlayerHeadPartial partial = this.propertyHolder.get(ItemProperties.SKULL_OWNER);
+            PlayerProfile profile = partial.profile();
+
+            if (profile.getId() != null) {
+                return Bukkit.getOfflinePlayer(profile.getId());
+            }
+
+            if (profile.getName() != null) {
+                return Bukkit.getOfflinePlayer(profile.getName());
+            }
+        }
+
+        return null;
+    }
+
+    @Override
+    public boolean setOwner(String name) {
+        if (name != null && name.length() > MAX_OWNER_LENGTH) {
+            return false;
+        }
+
+        if (name == null) {
+            this.setProfile(null);
+        } else {
+            this.setProfile(Bukkit.createProfile(name));
+        }
+
+        return true;
+    }
+
+    @Override
+    public boolean setOwningPlayer(OfflinePlayer owner) {
+        if (owner == null) {
+            this.setProfile(null);
+        } else if (owner instanceof Player player) {
+            this.setProfile(player.getPlayerProfile());
+        } else {
+            this.setProfile(Bukkit.createProfile(owner.getUniqueId(), owner.getName()));
+        }
+
+        return true;
+    }
+
+    @Override
+    @Deprecated // Paper
+    public org.bukkit.profile.PlayerProfile getOwnerProfile() {
+        if (!this.hasOwner()) {
+            return null;
+        }
+
+        return this.propertyHolder.get(ItemProperties.SKULL_OWNER_LEGACY_BUKKIT);
+    }
+
+    @Override
+    @Deprecated // Paper
+    public void setOwnerProfile(org.bukkit.profile.PlayerProfile profile) {
+        if (profile == null) {
+            this.setProfile(null);
+        } else {
+            GameProfile gameProfile = (((com.destroystokyo.paper.profile.SharedPlayerProfile) profile).buildGameProfile());
+            CraftPlayerProfile.validateSkullProfile(gameProfile);
+
+            this.setProfile(profile); // Paper
+        }
+    }
+
+    @Override
+    public @NotNull MetaPlayerHead clone() {
+        return (MetaPlayerHead) super.clone();
+    }
+
+    private void setProfile(org.bukkit.profile.PlayerProfile gameProfile) {
+        this.propertyHolder.set(ItemProperties.SKULL_OWNER_LEGACY_BUKKIT, gameProfile);
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.propertyHolder.unset(ItemProperties.SKULL_OWNER);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaPotion.java b/src/main/java/io/papermc/paper/item/meta/MetaPotion.java
new file mode 100644
index 0000000000000000000000000000000000000000..b603b5e23eb8cdfcd70adcf72c02907d3d6adc93
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaPotion.java
@@ -0,0 +1,168 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.value.ListValue;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.Color;
+import org.bukkit.Material;
+import org.bukkit.inventory.meta.PotionMeta;
+import org.bukkit.potion.PotionData;
+import org.bukkit.potion.PotionEffect;
+import org.bukkit.potion.PotionEffectType;
+import org.bukkit.potion.PotionType;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Iterator;
+import java.util.List;
+
+public class MetaPotion extends PaperMeta implements PotionMeta {
+
+    private static final PotionData DEFAULT_TYPE = new PotionData(PotionType.UNCRAFTABLE, false, false);
+
+    public MetaPotion(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.itemHolder(compoundTag), material);
+    }
+
+    @Override
+    boolean isEmpty() {
+        return super.isEmpty() && this.isPotionEmpty();
+    }
+
+    boolean isPotionEmpty() {
+        return (this.getBasePotionData().getType() == PotionType.UNCRAFTABLE) && !(this.hasCustomEffects() || this.hasColor());
+    }
+
+    @Override
+    public void setBasePotionData(@NotNull PotionData data) {
+         this.propertyHolder.set(ItemProperties.DEFAULT_POTION_TYPE, data);
+    }
+
+    @Override
+    public @NotNull PotionData getBasePotionData() {
+        return this.propertyHolder.getOrDefault(ItemProperties.DEFAULT_POTION_TYPE, DEFAULT_TYPE);
+    }
+
+    @Override
+    public boolean hasCustomEffects() {
+        ListValue<PotionEffect> effects = this.propertyHolder.getValue(ItemProperties.CUSTOM_POTION_EFFECTS);
+        return effects != null && !effects.isEmpty();
+    }
+
+    @Override
+    public @NotNull List<PotionEffect> getCustomEffects() {
+        return this.propertyHolder.getOrDefault(ItemProperties.CUSTOM_POTION_EFFECTS, List.of());
+    }
+
+    @Override
+    public boolean addCustomEffect(@NotNull PotionEffect effect, boolean overwrite) {
+        ListValue<PotionEffect> effects = this.propertyHolder.getOrCreate(ItemProperties.CUSTOM_POTION_EFFECTS);
+        int i = 0;
+        for (PotionEffect old : effects) {
+            if (old.getType() == effect.getType()) {
+                if (!overwrite) {
+                    return false;
+                } else if (old.getAmplifier() == effect.getAmplifier() && old.getDuration() == effect.getDuration() && old.isAmbient() == effect.isAmbient()) {
+                    return false;
+                }
+
+                break;
+            }
+            i++;
+        }
+
+        effects.insert(effect, i);
+        return true;
+    }
+
+    @Override
+    public boolean removeCustomEffect(@NotNull PotionEffectType type) {
+        ListValue<PotionEffect> effects = this.propertyHolder.getOrCreate(ItemProperties.CUSTOM_POTION_EFFECTS);
+        if (effects == null) {
+            return false;
+        }
+
+        boolean changed = false;
+        Iterator<PotionEffect> iterator = effects.iterator();
+        while (iterator.hasNext()) {
+            PotionEffect next = iterator.next();
+            if (next.getType() == type) {
+                iterator.remove();
+                changed = true;
+            }
+        }
+
+        return changed;
+    }
+
+    @Override
+    public boolean hasCustomEffect(@NotNull PotionEffectType type) {
+        ListValue<PotionEffect> effects = this.propertyHolder.getOrCreate(ItemProperties.CUSTOM_POTION_EFFECTS);
+        for (PotionEffect old : effects) {
+            if (old.getType() == type) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean clearCustomEffects() {
+        boolean changed = this.hasCustomEffects();
+        this.propertyHolder.unset(ItemProperties.CUSTOM_POTION_EFFECTS);
+        return changed;
+    }
+
+    @Override
+    public boolean setMainEffect(@NotNull PotionEffectType type) {
+        ListValue<PotionEffect> effects = this.propertyHolder.getOrCreate(ItemProperties.CUSTOM_POTION_EFFECTS);
+        PotionEffect found = null;
+        int i = 0;
+        for (PotionEffect old : effects) {
+            if (old.getType() == type) {
+                found = old;
+                break;
+            }
+            i++;
+        }
+
+        if (i == 0 || found == null) {
+            return false;
+        }
+
+        PotionEffect old = effects.get(0);
+        effects.insert(found, 0);
+        effects.insert(old, i);
+
+        return true;
+    }
+
+    @Override
+    public boolean hasColor() {
+        return this.hasInPropertyPath(ItemProperties.DISPLAY, ItemProperties.COLOR);
+    }
+
+    @Override
+    public @Nullable Color getColor() {
+        return this.getFromPropertyPath(ItemProperties.DISPLAY, ItemProperties.COLOR);
+    }
+
+    @Override
+    public void setColor(@Nullable Color color) {
+        this.setFromPropertyPath(ItemProperties.DISPLAY, ItemProperties.COLOR, color);
+    }
+
+    @Override
+    public @NotNull PotionMeta clone() {
+        return (PotionMeta) super.clone();
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.propertyHolder.unset(ItemProperties.DEFAULT_POTION_TYPE);
+        this.propertyHolder.unset(ItemProperties.CUSTOM_POTION_EFFECTS);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaRepairable.java b/src/main/java/io/papermc/paper/item/meta/MetaRepairable.java
new file mode 100644
index 0000000000000000000000000000000000000000..4ed03de780ba0337026624758f55ab96367b88ca
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaRepairable.java
@@ -0,0 +1,41 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.Material;
+import org.bukkit.inventory.meta.Repairable;
+import org.jetbrains.annotations.NotNull;
+
+public class MetaRepairable extends PaperMeta implements Repairable {
+
+    public MetaRepairable(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.itemHolder(compoundTag), material);
+    }
+
+    @Override
+    public boolean hasRepairCost() {
+        return this.propertyHolder.hasProperty(ItemProperties.REPAIR_COST);
+    }
+
+    @Override
+    public int getRepairCost() {
+        return this.propertyHolder.getOrDefault(ItemProperties.REPAIR_COST, 0);
+    }
+
+    @Override
+    public void setRepairCost(int cost) {
+        this.propertyHolder.set(ItemProperties.REPAIR_COST, cost);
+    }
+
+    @Override
+    public @NotNull MetaRepairable clone() {
+        return (MetaRepairable) super.clone();
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.propertyHolder.unset(ItemProperties.REPAIR_COST);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaSpawnEgg.java b/src/main/java/io/papermc/paper/item/meta/MetaSpawnEgg.java
new file mode 100644
index 0000000000000000000000000000000000000000..d96e9ddede0927812d5390f1c620eb35e344f2bd
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaSpawnEgg.java
@@ -0,0 +1,37 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.Material;
+import org.bukkit.entity.EntityType;
+import org.bukkit.inventory.meta.SpawnEggMeta;
+import org.jetbrains.annotations.NotNull;
+
+public class MetaSpawnEgg extends PaperMeta implements SpawnEggMeta {
+
+    public MetaSpawnEgg(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.itemHolder(compoundTag), material);
+    }
+
+    @Override
+    public EntityType getSpawnedType() {
+       throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setSpawnedType(EntityType type) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @NotNull MetaSpawnEgg clone() {
+        return (MetaSpawnEgg) super.clone();
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.propertyHolder.unset(ItemProperties.ENTITY_TAG);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaSuspiciousStew.java b/src/main/java/io/papermc/paper/item/meta/MetaSuspiciousStew.java
new file mode 100644
index 0000000000000000000000000000000000000000..ff6da5ca3a7a80d18149354ce50d92b52f67020e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaSuspiciousStew.java
@@ -0,0 +1,120 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.inventory.item.properties.StewEffect;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.value.ListValue;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.Material;
+import org.bukkit.inventory.meta.SuspiciousStewMeta;
+import org.bukkit.potion.PotionEffect;
+import org.bukkit.potion.PotionEffectType;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+public class MetaSuspiciousStew extends PaperMeta implements SuspiciousStewMeta {
+
+    public MetaSuspiciousStew(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.itemHolder(compoundTag), material);
+    }
+
+    @Override
+    boolean isEmpty() {
+        return super.isEmpty() && this.isStewEmpty();
+    }
+
+    boolean isStewEmpty() {
+        return !this.hasCustomEffects();
+    }
+
+    @Override
+    public boolean hasCustomEffects() {
+        ListValue<StewEffect> effects = this.propertyHolder.getValue(ItemProperties.STEW_EFFECTS);
+        return effects != null && !effects.isEmpty();
+    }
+
+    @Override
+    public @NotNull List<PotionEffect> getCustomEffects() {
+        List<PotionEffect> effects = new ArrayList<>();
+        for (StewEffect effect : this.propertyHolder.getOrDefault(ItemProperties.STEW_EFFECTS, List.of())) {
+            effects.add(new PotionEffect(effect.effect(), effect.duration(), 0));
+        }
+
+        return effects;
+    }
+
+    @Override
+    public boolean addCustomEffect(@NotNull PotionEffect effect, boolean overwrite) {
+        ListValue<StewEffect> effects = this.propertyHolder.getOrCreate(ItemProperties.STEW_EFFECTS);
+        int i = 0;
+        for (StewEffect old : effects) {
+            if (old.effect() == effect.getType()) {
+                if (!overwrite) {
+                    return false;
+                } if (old.duration() == effect.getDuration()) {
+                    return false;
+                }
+
+                break;
+            }
+            i++;
+        }
+
+        effects.insert(new StewEffect(effect.getType(), effect.getDuration()), i);
+
+        return true;
+    }
+
+    @Override
+    public boolean removeCustomEffect(@NotNull PotionEffectType type) {
+        ListValue<StewEffect> effects = this.propertyHolder.getValue(ItemProperties.STEW_EFFECTS);
+        if (effects == null) {
+            return false;
+        }
+
+        boolean changed = false;
+        Iterator<StewEffect> iterator = effects.iterator();
+        while (iterator.hasNext()) {
+            StewEffect next = iterator.next();
+            if (next.effect() == type) {
+                iterator.remove();
+                changed = true;
+            }
+        }
+
+        return changed;
+    }
+
+    @Override
+    public boolean hasCustomEffect(@NotNull PotionEffectType type) {
+        ListValue<StewEffect> effects = this.propertyHolder.getOrCreate(ItemProperties.STEW_EFFECTS);
+        for (StewEffect old : effects) {
+            if (old.effect() == type) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean clearCustomEffects() {
+        boolean changed = this.hasCustomEffects();
+        this.propertyHolder.unset(ItemProperties.STEW_EFFECTS);
+        return changed;
+    }
+
+    @Override
+    public @NotNull MetaSuspiciousStew clone() {
+        return (MetaSuspiciousStew) super.clone();
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.propertyHolder.unset(ItemProperties.STEW_EFFECTS);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaTropicalFishBucket.java b/src/main/java/io/papermc/paper/item/meta/MetaTropicalFishBucket.java
new file mode 100644
index 0000000000000000000000000000000000000000..1a393853082fdaa67b64f051dc033f704567ece9
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaTropicalFishBucket.java
@@ -0,0 +1,77 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.inventory.item.properties.TropicalFishVariant;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.DyeColor;
+import org.bukkit.Material;
+import org.bukkit.entity.TropicalFish;
+import org.bukkit.inventory.meta.TropicalFishBucketMeta;
+import org.jetbrains.annotations.NotNull;
+
+public class MetaTropicalFishBucket extends PaperMeta implements TropicalFishBucketMeta {
+
+    private static final TropicalFishVariant DEFAULT = new TropicalFishVariant(DyeColor.WHITE, DyeColor.WHITE, TropicalFish.Pattern.KOB);
+
+    public MetaTropicalFishBucket(CompoundTag compoundTag, Material material) {
+        super(NbtPropertyHolder.itemHolder(compoundTag), material);
+    }
+
+    @Override
+    public @NotNull DyeColor getPatternColor() {
+        TropicalFishVariant variant = this.propertyHolder.getOrDefault(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, DEFAULT);
+        return variant.patternColor();
+    }
+
+    @Override
+    public void setPatternColor(@NotNull DyeColor color) {
+        TropicalFishVariant variant = this.propertyHolder.getOrDefault(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, DEFAULT);
+        this.set(new TropicalFishVariant(color, variant.bodyColor(), variant.type()));
+    }
+
+    @Override
+    public @NotNull DyeColor getBodyColor() {
+        TropicalFishVariant variant = this.propertyHolder.getOrDefault(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, DEFAULT);
+        return variant.bodyColor();
+    }
+
+    @Override
+    public void setBodyColor(@NotNull DyeColor color) {
+        TropicalFishVariant variant = this.propertyHolder.getOrDefault(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, DEFAULT);
+        this.set(new TropicalFishVariant(variant.patternColor(), color, variant.type()));
+    }
+
+    @Override
+    public @NotNull TropicalFish.Pattern getPattern() {
+        TropicalFishVariant variant = this.propertyHolder.getOrDefault(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, DEFAULT);
+        return variant.type();
+    }
+
+    @Override
+    public void setPattern(TropicalFish.@NotNull Pattern pattern) {
+        TropicalFishVariant variant = this.propertyHolder.getOrDefault(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, DEFAULT);
+        this.set(new TropicalFishVariant(variant.patternColor(), variant.bodyColor(), pattern));
+    }
+
+    @Override
+    public boolean hasVariant() {
+        return this.propertyHolder.hasProperty(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT);
+    }
+
+    private void set(TropicalFishVariant variant) {
+        this.propertyHolder.set(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, variant);
+    }
+
+    @Override
+    public @NotNull TropicalFishBucketMeta clone() {
+        return (TropicalFishBucketMeta) super.clone();
+    }
+
+    @Override
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+        this.propertyHolder.unset(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT);
+        this.propertyHolder.unset(ItemProperties.ENTITY_TAG);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/PaperMeta.java b/src/main/java/io/papermc/paper/item/meta/PaperMeta.java
new file mode 100644
index 0000000000000000000000000000000000000000..091f171c6ceedc4e8cadac367d204107e2910d87
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/PaperMeta.java
@@ -0,0 +1,499 @@
+package io.papermc.paper.item.meta;
+
+import com.destroystokyo.paper.Namespaced;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.Multimap;
+import com.google.common.collect.SetMultimap;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.StoredPropertyHolder;
+import io.papermc.paper.property.value.MapValue;
+import io.papermc.paper.property.value.SetValue;
+import io.papermc.paper.property.value.Value;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
+import net.md_5.bungee.api.chat.BaseComponent;
+import org.bukkit.Material;
+import org.bukkit.attribute.Attribute;
+import org.bukkit.attribute.AttributeModifier;
+import org.bukkit.craftbukkit.Overridden;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
+import org.bukkit.enchantments.Enchantment;
+import org.bukkit.inventory.EquipmentSlot;
+import org.bukkit.inventory.ItemFlag;
+import org.bukkit.inventory.meta.ItemMeta;
+import org.bukkit.inventory.meta.tags.CustomItemTagContainer;
+import org.bukkit.persistence.PersistentDataContainer;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import static io.papermc.paper.inventory.item.properties.ItemProperties.ATTRIBUTES;
+import static io.papermc.paper.inventory.item.properties.ItemProperties.CUSTOM_MODEL_DATA;
+import static io.papermc.paper.inventory.item.properties.ItemProperties.DISPLAY;
+import static io.papermc.paper.inventory.item.properties.ItemProperties.DISPLAY_NAME;
+import static io.papermc.paper.inventory.item.properties.ItemProperties.ENCHANTMENTS;
+import static io.papermc.paper.inventory.item.properties.ItemProperties.HIDE_FLAGS;
+import static io.papermc.paper.inventory.item.properties.ItemProperties.LOC_NAME;
+import static io.papermc.paper.inventory.item.properties.ItemProperties.LORE;
+import static io.papermc.paper.inventory.item.properties.ItemProperties.UNBREAKABLE;
+
+public class PaperMeta implements ItemMeta {
+
+    protected final PropertyHolder.Mutable propertyHolder;
+    protected final Material material;
+
+    public PaperMeta(PropertyHolder.Mutable propertyHolder, Material material) {
+        this.propertyHolder = propertyHolder;
+        this.material = material;
+    }
+
+    @Override
+    public @NotNull Map<String, Object> serialize() {
+        return null;
+    }
+
+    protected boolean hasInPropertyPath(PropertyKey<StoredPropertyHolder> outer, PropertyKey<?> inner) {
+        PropertyHolder holder = this.propertyHolder.get(outer);
+        if (holder != null) {
+            return holder.hasProperty(inner);
+        }
+
+        return false;
+    }
+
+    protected <T, V extends Value<T>> T getFromPropertyPath(PropertyKey<StoredPropertyHolder> outer, PropertyKey<V> inner) {
+        PropertyHolder holder = this.propertyHolder.get(outer);
+        if (holder != null) {
+            return holder.get(inner);
+        }
+
+        return null;
+    }
+
+    protected <T, V extends Value<T>> void unsetInPropertyPath(PropertyKey<StoredPropertyHolder> outer, PropertyKey<V> inner) {
+        StoredPropertyHolder holder = this.propertyHolder.getValue(outer);
+        if (holder != null) {
+            holder.unset(inner);
+        }
+    }
+
+    protected <T, V extends Value<T>> void setFromPropertyPath(PropertyKey<StoredPropertyHolder> outer, PropertyKey<V> inner, T value) {
+        PropertyHolder.Mutable holder = this.propertyHolder.getOrCreate(outer);
+        holder.set(inner, value);
+    }
+
+    @Override
+    public boolean hasDisplayName() {
+        return this.hasInPropertyPath(DISPLAY, DISPLAY_NAME);
+    }
+
+    @Nullable
+    @Override
+    public Component displayName() {
+        return this.getFromPropertyPath(DISPLAY, DISPLAY_NAME);
+    }
+
+    @Override
+    public void displayName(@Nullable Component displayName) {
+        this.setFromPropertyPath(DISPLAY, DISPLAY_NAME, displayName);
+    }
+
+    @Override
+    public @NotNull String getDisplayName() {
+        Component displayName = this.displayName();
+        if (displayName == null) {
+            return "";
+        }
+        String gson = GsonComponentSerializer.gson().serialize(displayName);
+        return CraftChatMessage.fromJSONComponent(gson);
+    }
+
+    @Override
+    public void setDisplayName(@Nullable String name) {
+        // TODO: test null strings
+        this.displayName(GsonComponentSerializer.gson().deserialize(CraftChatMessage.fromStringOrNullToJSON(name)));
+    }
+
+    @NotNull
+    @Override
+    public BaseComponent[] getDisplayNameComponent() {
+        Component displayName = this.displayName();
+        if (displayName == null) {
+            return new BaseComponent[0];
+        }
+
+        return net.md_5.bungee.chat.ComponentSerializer.parse(GsonComponentSerializer.gson().serialize(displayName));
+    }
+
+    @Override
+    public void setDisplayNameComponent(@Nullable BaseComponent[] component) {
+        String gson = net.md_5.bungee.chat.ComponentSerializer.toString(component);
+        this.displayName(GsonComponentSerializer.gson().deserialize(gson));
+    }
+
+    @Override
+    public boolean hasLocalizedName() {
+        return this.hasInPropertyPath(DISPLAY, LOC_NAME);
+    }
+
+    @Override
+    public @NotNull String getLocalizedName() {
+        return this.getFromPropertyPath(DISPLAY, LOC_NAME);
+    }
+
+    @Override
+    public void setLocalizedName(@Nullable String name) {
+        this.setFromPropertyPath(DISPLAY, LOC_NAME, name);
+    }
+
+    @Override
+    public boolean hasLore() {
+        return this.hasInPropertyPath(DISPLAY, LORE);
+    }
+
+    @Override
+    public @Nullable List<Component> lore() {
+        return this.getFromPropertyPath(DISPLAY, LORE);
+    }
+
+    @Override
+    public void lore(@Nullable List<Component> lore) {
+        this.setFromPropertyPath(DISPLAY, LORE, lore);
+    }
+
+    @Override
+    public @Nullable List<String> getLore() {
+        return null;
+    }
+
+    @Override
+    public void setLore(@Nullable List<String> lore) {
+
+    }
+
+    @Override
+    public @Nullable List<BaseComponent[]> getLoreComponents() {
+        return null;
+    }
+
+    @Override
+    public void setLoreComponents(@Nullable List<BaseComponent[]> lore) {
+
+    }
+
+    @Override
+    public boolean hasCustomModelData() {
+        return this.propertyHolder.hasProperty(CUSTOM_MODEL_DATA);
+    }
+
+    @Override
+    public int getCustomModelData() {
+        return this.propertyHolder.getOrDefault(CUSTOM_MODEL_DATA, 0);
+    }
+
+    @Override
+    public void setCustomModelData(@Nullable Integer data) {
+        this.propertyHolder.set(CUSTOM_MODEL_DATA, data);
+    }
+
+    @Override
+    public boolean hasEnchants() {
+        // Legacy reasons?
+        // TODO: check
+        return this.propertyHolder.hasProperty(ENCHANTMENTS) && !this.propertyHolder.getValue(ENCHANTMENTS).isEmpty();
+    }
+
+    @Override
+    public boolean hasEnchant(@NotNull Enchantment ench) {
+        MapValue<Enchantment, Integer> mapValue = this.propertyHolder.getValue(ENCHANTMENTS);
+        if (mapValue == null) {
+            return false;
+        }
+
+        return mapValue.has(ench);
+    }
+
+    @Override
+    public int getEnchantLevel(@NotNull Enchantment ench) {
+        MapValue<Enchantment, Integer> mapValue = this.propertyHolder.getValue(ENCHANTMENTS);
+        if (mapValue == null) {
+            return 0;
+        }
+
+        return mapValue.getEntry(ench);
+    }
+
+    @Override
+    public @NotNull Map<Enchantment, Integer> getEnchants() {
+        return this.propertyHolder.getOrCreate(ENCHANTMENTS).getValue();
+    }
+
+    @Override
+    public boolean addEnchant(@NotNull Enchantment ench, int level, boolean ignoreLevelRestriction) {
+        if (ignoreLevelRestriction || level >= ench.getStartLevel() && level <= ench.getMaxLevel()) {
+            MapValue<Enchantment, Integer> enchantmentMap = this.propertyHolder.getOrCreate(ENCHANTMENTS);
+
+            Integer old = enchantmentMap.put(ench, level);
+            return old == null || old != level;
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean removeEnchant(@NotNull Enchantment ench) {
+        MapValue<Enchantment, Integer> enchantmentMap = this.propertyHolder.getValue(ENCHANTMENTS);
+        if (enchantmentMap == null) {
+            return false;
+        }
+
+        enchantmentMap.removeEntry(ench);
+        return true;
+    }
+
+    @Override
+    public boolean hasConflictingEnchant(@NotNull Enchantment ench) {
+        if (!hasEnchants()) {
+            return false;
+        }
+
+        for (Map.Entry<Enchantment, Integer> enchant : this.propertyHolder.getValue(ENCHANTMENTS)) {
+            if (enchant.getKey().conflictsWith(ench)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public void addItemFlags(@NotNull ItemFlag... itemFlags) {
+        SetValue<ItemFlag> flagSetValue = this.propertyHolder.getOrCreate(HIDE_FLAGS);
+        for (ItemFlag flag : itemFlags) {
+            flagSetValue.add(flag);
+        }
+    }
+
+    @Override
+    public void removeItemFlags(@NotNull ItemFlag... itemFlags) {
+        SetValue<ItemFlag> flagSetValue = this.propertyHolder.getValue(HIDE_FLAGS);
+        if (flagSetValue == null) {
+            return;
+        }
+
+        for (ItemFlag flag : itemFlags) {
+            flagSetValue.remove(flag);
+        }
+    }
+
+    @Override
+    public @NotNull Set<ItemFlag> getItemFlags() {
+        return this.propertyHolder.getOrDefault(HIDE_FLAGS, Set.of());
+    }
+
+    @Override
+    public boolean hasItemFlag(@NotNull ItemFlag flag) {
+        return this.propertyHolder.hasProperty(HIDE_FLAGS);
+    }
+
+    @Override
+    public boolean isUnbreakable() {
+        return this.propertyHolder.hasProperty(UNBREAKABLE) && this.propertyHolder.get(UNBREAKABLE);
+    }
+
+    @Override
+    public void setUnbreakable(boolean unbreakable) {
+        this.propertyHolder.set(UNBREAKABLE, unbreakable);
+    }
+
+    @Override
+    public boolean hasAttributeModifiers() {
+        return this.propertyHolder.hasProperty(ATTRIBUTES);
+    }
+
+    @Override
+    public @Nullable Multimap<Attribute, AttributeModifier> getAttributeModifiers() {
+        return this.propertyHolder.getOrDefault(ATTRIBUTES, LinkedHashMultimap.create());
+    }
+
+    @Override
+    public void setAttributeModifiers(@Nullable Multimap<Attribute, AttributeModifier> attributeModifiers) {
+        this.propertyHolder.set(ATTRIBUTES, attributeModifiers);
+    }
+
+    @Override
+    public @NotNull Multimap<Attribute, AttributeModifier> getAttributeModifiers(@NotNull EquipmentSlot slot) {
+        SetMultimap<Attribute, AttributeModifier> result = LinkedHashMultimap.create();
+        for (Map.Entry<Attribute, AttributeModifier> entry : this.propertyHolder.getOrCreate(ATTRIBUTES).getValue().entries()) {
+            if (entry.getValue().getSlot() == null || entry.getValue().getSlot() == slot) {
+                result.put(entry.getKey(), entry.getValue());
+            }
+        }
+
+        return result;
+    }
+
+    @Override
+    public @Nullable Collection<AttributeModifier> getAttributeModifiers(@NotNull Attribute attribute) {
+        Multimap<Attribute, AttributeModifier> attributes = this.propertyHolder.get(ATTRIBUTES);
+
+        return attributes != null && attributes.containsKey(attribute) ? ImmutableList.copyOf(attributes.get(attribute)) : null;
+    }
+
+    @Override
+    public boolean addAttributeModifier(@NotNull Attribute attribute, @NotNull AttributeModifier modifier) {
+        return false; // TODO
+//        MultiMapValue<Attribute, AttributeModifier> attributes = this.propertyHolder.getOrCreate(ATTRIBUTES);
+//        for (Map.Entry<Attribute, AttributeModifier> entry : attributes.entries()) {
+//            Preconditions.checkArgument(!entry.getValue().getUniqueId().equals(modifier.getUniqueId()), "Cannot register AttributeModifier. Modifier is already applied! %s", modifier);
+//        }
+//
+//        return attributes.put(attribute, modifier);
+    }
+
+    @Override
+    public boolean removeAttributeModifier(@NotNull Attribute attribute) {
+        return false; // TODO
+//        this.propertyHolder.getOrCreate(ATTRIBUTES).
+//        return !this.attributeModifiers.removeAll(attribute).isEmpty();
+    }
+
+    @Override
+    public boolean removeAttributeModifier(@NotNull EquipmentSlot slot) {
+        return false; // TODO
+//        int removed = 0;
+//        Iterator<Map.Entry<Attribute, AttributeModifier>> iter = this.attributeModifiers.entries().iterator();
+//
+//        while (iter.hasNext()) {
+//            Map.Entry<Attribute, AttributeModifier> entry = iter.next();
+//            // Explicitly match against null because (as of MC 1.13) AttributeModifiers without a -
+//            // set slot are active in any slot.
+//            if (entry.getValue().getSlot() == null || entry.getValue().getSlot() == slot) {
+//                iter.remove();
+//                ++removed;
+//            }
+//        }
+//        return removed > 0;
+    }
+
+    @Override
+    public boolean removeAttributeModifier(@NotNull Attribute attribute, @NotNull AttributeModifier modifier) {
+        return false; // TODO
+//        int removed = 0;
+//        Iterator<Map.Entry<Attribute, AttributeModifier>> iter = this.attributeModifiers.entries().iterator();
+//
+//        while (iter.hasNext()) {
+//            Map.Entry<Attribute, AttributeModifier> entry = iter.next();
+//            if (entry.getKey() == null || entry.getValue() == null) {
+//                iter.remove();
+//                ++removed;
+//                continue; // remove all null values while we are here
+//            }
+//
+//            if (entry.getKey() == attribute && entry.getValue().getUniqueId().equals(modifier.getUniqueId())) {
+//                iter.remove();
+//                ++removed;
+//            }
+//        }
+//        return removed > 0;
+    }
+
+    @Override
+    public @NotNull CustomItemTagContainer getCustomTagContainer() {
+        return null;
+    }
+
+    @Override
+    public void setVersion(int version) {
+        // TODO
+    }
+
+    @Override
+    public @NotNull ItemMeta clone() {
+        return new PaperMeta(propertyHolder, this.material);
+    }
+
+    @Override
+    public Set<Material> getCanDestroy() {
+        return null;
+    }
+
+    @Override
+    public void setCanDestroy(Set<Material> canDestroy) {
+
+    }
+
+    @Override
+    public Set<Material> getCanPlaceOn() {
+        return null;
+    }
+
+    @Override
+    public void setCanPlaceOn(Set<Material> canPlaceOn) {
+
+    }
+
+    @Override
+    public @NotNull Set<Namespaced> getDestroyableKeys() {
+        return null;
+    }
+
+    @Override
+    public void setDestroyableKeys(@NotNull Collection<Namespaced> canDestroy) {
+
+    }
+
+    @Override
+    public @NotNull Set<Namespaced> getPlaceableKeys() {
+        return null;
+    }
+
+    @Override
+    public @NotNull void setPlaceableKeys(@NotNull Collection<Namespaced> canPlaceOn) {
+
+    }
+
+    @Override
+    public boolean hasPlaceableKeys() {
+        return false;
+    }
+
+    @Override
+    public boolean hasDestroyableKeys() {
+        return false;
+    }
+
+    @Override
+    public @NotNull PersistentDataContainer getPersistentDataContainer() {
+        return null;
+    }
+
+    @Override
+    public @NotNull String getAsString() {
+        return this.toString();
+    }
+
+    @Overridden
+    boolean isEmpty() {
+        return false; // TODO:
+    }
+
+    void migrateFrom(PropertyHolder.Mutable mutable) {
+    }
+    // TODO
+
+    @Override
+    public String toString() {
+        return "PaperMeta{" +
+            "propertyHolder=" + propertyHolder +
+            '}';
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/PaperMetaProperties.java b/src/main/java/io/papermc/paper/item/meta/PaperMetaProperties.java
new file mode 100644
index 0000000000000000000000000000000000000000..b0d9ea37351ef74bdc467e45e36f537360dcb850
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/PaperMetaProperties.java
@@ -0,0 +1,16 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.value.ListValue;
+import io.papermc.paper.property.value.Value;
+import org.bukkit.DyeColor;
+import org.bukkit.block.banner.Pattern;
+
+class PaperMetaProperties {
+
+    // Banner Block Entity
+    static final PropertyKey<Value<DyeColor>> BASE = PropertyKey.of("Base", DyeColor.class);
+    static final PropertyKey<ListValue<Pattern>> PATTERNS = PropertyKey.ofList("Patterns", Pattern.class);
+
+
+}
diff --git a/src/main/java/io/papermc/paper/item/property/ItemPropertyRegistration.java b/src/main/java/io/papermc/paper/item/property/ItemPropertyRegistration.java
new file mode 100644
index 0000000000000000000000000000000000000000..da1e909b25669e7aa51d6ca489d4402ebaa7ff4f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/property/ItemPropertyRegistration.java
@@ -0,0 +1,89 @@
+package io.papermc.paper.item.property;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.nbt.primitives.BlockPositionNbtPrimitive;
+import io.papermc.paper.property.nbt.primitives.BooleanPrimitive;
+import io.papermc.paper.property.nbt.primitives.BytePrimitive;
+import io.papermc.paper.property.nbt.primitives.ColorNbtPrimitive;
+import io.papermc.paper.property.nbt.primitives.ComponentNbtPrimitive;
+import io.papermc.paper.property.nbt.primitives.IntegerPrimitive;
+import io.papermc.paper.property.nbt.primitives.ItemStackNbtPrimitive;
+import io.papermc.paper.property.nbt.primitives.NamespaceKeyNbtPrimitive;
+import io.papermc.paper.property.nbt.primitives.StringPrimitive;
+import io.papermc.paper.property.nbt.types.AttributeMap;
+import io.papermc.paper.property.nbt.types.AxolotlVariantNbt;
+import io.papermc.paper.property.nbt.types.CompoundTagNbt;
+import io.papermc.paper.property.nbt.types.EnchantmentsMap;
+import io.papermc.paper.property.nbt.types.ItemFlagBitset;
+import io.papermc.paper.property.nbt.types.StewEffectsListNbt;
+import io.papermc.paper.property.nbt.types.TropicalFishVariantNbt;
+import io.papermc.paper.property.nbt.types.WrappedListNbt;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.world.item.ItemStack;
+
+public class ItemPropertyRegistration {
+
+    public static void registerTypes(NbtPropertyHolder tag) {
+        tag.register(ItemProperties.ENCHANTMENTS, new EnchantmentsMap());
+        tag.register(ItemProperties.UNBREAKABLE, new BooleanPrimitive());
+        tag.register(ItemProperties.HIDE_FLAGS, new ItemFlagBitset());
+        tag.register(ItemProperties.REPAIR_COST, new IntegerPrimitive());
+        tag.register(ItemProperties.CUSTOM_MODEL_DATA, new IntegerPrimitive());
+        tag.register(ItemProperties.DAMAGE, new IntegerPrimitive());
+        tag.register(ItemProperties.ATTRIBUTES, new AttributeMap());
+        tag.register(ItemProperties.BLOCK_STATE, new CompoundTagNbt());
+        tag.register(ItemProperties.ENTITY_TAG, new CompoundTagNbt());
+
+        tag.register(ItemProperties.DISPLAY, new CompoundTagNbt());
+        tag.register(ItemProperties.DISPLAY_NAME, new ComponentNbtPrimitive());
+        tag.register(ItemProperties.COLOR, new ColorNbtPrimitive());
+        tag.register(ItemProperties.MAP_COLOR, new ColorNbtPrimitive());
+
+        tag.register(ItemProperties.PUBLIC_BUKKIT_VALUES, new CompoundTagNbt());
+        tag.register(ItemProperties.LOC_NAME, new StringPrimitive());
+
+        tag.register(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, new TropicalFishVariantNbt());
+
+        tag.register(ItemProperties.STEW_EFFECTS, new StewEffectsListNbt());
+
+        // TODO: Skull
+
+        // TODO: Potion
+
+        tag.register(ItemProperties.MAP_ID, new IntegerPrimitive());
+        tag.register(ItemProperties.MAP_SCALE_DIRECTION, new BytePrimitive());
+        tag.register(ItemProperties.MAP_TO_LOCK, new BooleanPrimitive());
+
+        tag.register(ItemProperties.RECIPES, new WrappedListNbt<>(new NamespaceKeyNbtPrimitive()));
+
+        tag.register(ItemProperties.FLIGHT, new BytePrimitive());
+
+        // TODO: Firework effect
+
+        tag.register(ItemProperties.STORED_ENCHANTMENTS, new EnchantmentsMap());
+
+        tag.register(ItemProperties.CHARGED, new BooleanPrimitive());
+        tag.register(ItemProperties.CHARGED_PROJECTILES, new WrappedListNbt<>(new ItemStackNbtPrimitive()));
+
+        tag.register(ItemProperties.LODESTONE_POS, new BlockPositionNbtPrimitive());
+        tag.register(ItemProperties.LODESTONE_DIMENSION, new NamespaceKeyNbtPrimitive());
+        tag.register(ItemProperties.LODESTONE_TRACKED, new BooleanPrimitive());
+
+        tag.register(ItemProperties.ITEMS, new WrappedListNbt<>(new ItemStackNbtPrimitive()));
+
+        tag.register(ItemProperties.TITLE, new StringPrimitive());
+        tag.register(ItemProperties.TITLE_FILTERED, new StringPrimitive());
+        tag.register(ItemProperties.AUTHOR, new StringPrimitive());
+        tag.register(ItemProperties.PAGES, new WrappedListNbt<>(new ComponentNbtPrimitive()));
+        tag.register(ItemProperties.PAGES_FILTERED, new WrappedListNbt<>(new ComponentNbtPrimitive()));
+        tag.register(ItemProperties.GENERATION, new IntegerPrimitive());
+        tag.register(ItemProperties.RESOLVED, new BooleanPrimitive());
+
+        tag.register(ItemProperties.PAGES_WRITTEN, new WrappedListNbt<>(new StringPrimitive()));
+        tag.register(ItemProperties.BLOCK_ENTITY_TAG, new CompoundTagNbt());
+        tag.register(ItemProperties.VARIANT, new AxolotlVariantNbt());
+    }
+
+
+}
diff --git a/src/main/java/io/papermc/paper/property/AbstractMutablePropertyHolder.java b/src/main/java/io/papermc/paper/property/AbstractMutablePropertyHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..4463883d296ab049b65d4bf433b29af64114dd85
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/AbstractMutablePropertyHolder.java
@@ -0,0 +1,68 @@
+package io.papermc.paper.property;
+
+import io.papermc.paper.property.value.Value;
+import io.papermc.paper.property.value.provider.ValueProvider;
+import org.bukkit.util.Consumer;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.BiConsumer;
+
+
+public abstract class AbstractMutablePropertyHolder implements PropertyHolder.Mutable {
+
+    private final Map<PropertyKey<?>, Value<?>> values = new HashMap<>();
+    private final Map<PropertyKey<?>, ValueProvider<?, ?>> valueProviders = new HashMap<>();
+
+    public AbstractMutablePropertyHolder() {
+        registerProviders(this.valueProviders::put);
+    }
+
+    @Override
+    public <T> @Nullable T get(PropertyKey<? extends Value<T>> property) {
+        Value<T> value = this.getValue(property);
+        return value == null ? null : value.getValue();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <E, V extends Value<E>> @Nullable V getValue(PropertyKey<V> property) {
+        return (V) this.values.get(property);
+    }
+
+    @Override
+    public boolean hasProperty(PropertyKey<?> propertyKey) {
+        return this.values.containsKey(propertyKey);
+    }
+
+    @Override
+    public void set(Value<?> value) {
+        this.values.put(value.getKey(), value);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <T> void set(PropertyKey<? extends Value<T>> key, T value) {
+        ValueProvider provider = this.valueProviders.get(key);
+
+        this.values.put(key, provider.wrapValue(value));
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <V, T extends Value<V>> T getOrCreate(PropertyKey<T> key) {
+        Value<?> provider = this.values.get(key);
+        if (provider == null) {
+            T value = (T) this.valueProviders.get(key).createNew();
+            this.values.put(key, value);
+
+            return value;
+        }
+
+        return (T) provider;
+    }
+
+    public abstract void registerProviders(BiConsumer<PropertyKey<?>, ValueProvider<?, ?>> providerConsumer);
+
+}
diff --git a/src/main/java/io/papermc/paper/property/MutablePropertyHolderImpl.java b/src/main/java/io/papermc/paper/property/MutablePropertyHolderImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..930371c9416b27b609896ced9862bd9497650d45
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/MutablePropertyHolderImpl.java
@@ -0,0 +1,58 @@
+package io.papermc.paper.property;
+
+import io.papermc.paper.property.value.Value;
+import org.jetbrains.annotations.Nullable;
+
+public class MutablePropertyHolderImpl implements PropertyHolder.Mutable {
+
+    @Override
+    public void set(Value<?> value) {
+
+    }
+
+    @Override
+    public <T> void unset(PropertyKey<? extends Value<T>> key) {
+
+    }
+
+
+    @Override
+    public <T> void set(PropertyKey<? extends Value<T>> key, T value) {
+
+    }
+
+    @Override
+    public <V, T extends Value<V>> T create(PropertyKey<T> key) {
+        return null;
+    }
+
+    @Override
+    public <V, T extends Value<V>> T getOrCreate(PropertyKey<T> key) {
+        return null;
+    }
+
+    @Override
+    public <T> @Nullable T get(PropertyKey<? extends Value<T>> property) {
+        return null;
+    }
+
+    @Override
+    public <T> @Nullable T getOrDefault(PropertyKey<? extends Value<T>> property, T value) {
+        return null;
+    }
+
+    @Override
+    public <E, V extends Value<E>> @Nullable V getValue(PropertyKey<V> property) {
+        return null;
+    }
+
+    @Override
+    public <V, T extends Value<V>> @Nullable T getValueOrDefault(PropertyKey<T> key, T value) {
+        return null;
+    }
+
+    @Override
+    public boolean hasProperty(PropertyKey<?> propertyKey) {
+        return false;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/SimpleValuePlatformAdapter.java b/src/main/java/io/papermc/paper/property/SimpleValuePlatformAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..77743a1c320a81a25f8657f8a2b0076f83f4436b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/SimpleValuePlatformAdapter.java
@@ -0,0 +1,12 @@
+package io.papermc.paper.property;
+
+import io.papermc.paper.property.adapter.TypeAdapter;
+import io.papermc.paper.property.value.Value;
+
+public interface SimpleValuePlatformAdapter<T, PLATFORMTYPE> extends TypeAdapter<Value<T>, PLATFORMTYPE> {
+
+
+    PLATFORMTYPE fromValue(T data);
+
+
+}
diff --git a/src/main/java/io/papermc/paper/property/adapter/TypeAdapter.java b/src/main/java/io/papermc/paper/property/adapter/TypeAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..6f19ef7ac64677b08769c35cd805acb5edff69a7
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/adapter/TypeAdapter.java
@@ -0,0 +1,10 @@
+package io.papermc.paper.property.adapter;
+
+public interface TypeAdapter<PLATFORM_TYPE, RUNTIME_TYPE> {
+
+    PLATFORM_TYPE toPlatform(RUNTIME_TYPE runtimeType);
+
+    RUNTIME_TYPE toRuntime(PLATFORM_TYPE platformType);
+
+
+}
diff --git a/src/main/java/io/papermc/paper/property/adapter/ValueTypeAdapter.java b/src/main/java/io/papermc/paper/property/adapter/ValueTypeAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..1f2997ecc251fb88960c08455c79048bd27065c7
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/adapter/ValueTypeAdapter.java
@@ -0,0 +1,14 @@
+package io.papermc.paper.property.adapter;
+
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.value.Value;
+
+public interface ValueTypeAdapter<RUNTIME_TYPE, RUNTIME extends Value<RUNTIME_TYPE>, HOLDER extends PropertyHolder> {
+
+    RUNTIME getValue(HOLDER holder, PropertyKey<RUNTIME> propertyKey);
+
+    void writeDirect(HOLDER holder, PropertyKey<?> propertyKey, RUNTIME_TYPE direct);
+
+    RUNTIME getNewValue(HOLDER holder, PropertyKey<RUNTIME> propertyKey);
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/NbtPlatformAdapter.java b/src/main/java/io/papermc/paper/property/nbt/NbtPlatformAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..2ea63c535ec899c05bc4ed9c759486354df83b4f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/NbtPlatformAdapter.java
@@ -0,0 +1,11 @@
+package io.papermc.paper.property.nbt;
+
+import io.papermc.paper.property.adapter.TypeAdapter;
+import io.papermc.paper.property.adapter.ValueTypeAdapter;
+import io.papermc.paper.property.value.Value;
+import net.minecraft.nbt.Tag;
+
+public interface NbtPlatformAdapter<TYPE, RUNTIME extends Value<TYPE>> extends ValueTypeAdapter<TYPE, RUNTIME, NbtPropertyHolder> {
+    int getTagType();
+
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/NbtPropertyHolder.java b/src/main/java/io/papermc/paper/property/nbt/NbtPropertyHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..eefb98d17f91e04650c5109981464a460f779ac9
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/NbtPropertyHolder.java
@@ -0,0 +1,141 @@
+package io.papermc.paper.property.nbt;
+
+import io.papermc.paper.item.property.ItemPropertyRegistration;
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.value.Value;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.util.Consumer;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class NbtPropertyHolder implements PropertyHolder.Mutable {
+
+    private final Map<PropertyKey<?>, NbtPlatformAdapter<?, ?>> adapters = new HashMap<>();
+    private boolean locked = false;
+    private final CompoundTag compoundTag;
+
+    // TODO cleanup.
+    // Properly pass a context object in places
+    public static NbtPropertyHolder simpleBlob(CompoundTag compoundTag) {
+        NbtPropertyHolder holder = new NbtPropertyHolder(compoundTag);
+        holder.lockRegistration();
+        return holder;
+    }
+
+    public static NbtPropertyHolder configuredBlob(CompoundTag compoundTag, Consumer<NbtPropertyHolder> registrationPoint) {
+        NbtPropertyHolder holder = new NbtPropertyHolder(compoundTag);
+        registrationPoint.accept(holder);
+        holder.lockRegistration();
+        return holder;
+    }
+
+    public static NbtPropertyHolder itemHolder(CompoundTag compoundTag) {
+        NbtPropertyHolder holder = new NbtPropertyHolder(compoundTag);
+        ItemPropertyRegistration.registerTypes(holder);
+        holder.lockRegistration();
+        return holder;
+    }
+
+    public static NbtPropertyHolder configuredItemHolder(CompoundTag compoundTag, Consumer<NbtPropertyHolder> registrationPoint) {
+        NbtPropertyHolder holder = new NbtPropertyHolder(compoundTag);
+        ItemPropertyRegistration.registerTypes(holder);
+        registrationPoint.accept(holder);
+        holder.lockRegistration();
+        return holder;
+    }
+
+    NbtPropertyHolder(CompoundTag compoundTag) {
+        this.compoundTag = compoundTag;
+    }
+
+    public <V, T extends Value<V>> NbtPropertyHolder register(PropertyKey<T> key, NbtPlatformAdapter<V, T> adapter) {
+        if (locked) {
+            throw new IllegalStateException("Cannot dynamically register property types");
+        }
+
+        this.adapters.put(key, adapter);
+        return this;
+    }
+
+    public void lockRegistration() {
+        this.locked = true;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public void set(Value value) {
+        this.set(value.getKey(), value.getValue());
+    }
+
+    @Override
+    public <T> void unset(PropertyKey<? extends Value<T>> key) {
+        this.compoundTag.remove(key.getKey());
+    }
+
+    @Override
+    public <T> void set(PropertyKey<? extends Value<T>> key, T value) {
+        NbtPlatformAdapter adapter = this.adapters.get(key);
+        adapter.writeDirect(this, key, value);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <V, T extends Value<V>> T create(PropertyKey<T> key) {
+        NbtPlatformAdapter adapter = this.adapters.get(key);
+        return (T) adapter.getNewValue(this, key);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <V, T extends Value<V>> T getOrCreate(PropertyKey<T> key) {
+        NbtPlatformAdapter adapter = this.adapters.get(key);
+
+        if (!this.compoundTag.contains(key.getKey(), adapter.getTagType())) {
+            return (T) adapter.getNewValue(this, key);
+        }
+
+        return (T) adapter.getValue(this, key);
+    }
+
+    @Override
+    public <T> @Nullable T get(PropertyKey<? extends Value<T>> property) {
+        Value<T> value = this.getValue(property);
+        return value == null ? null : value.getValue();
+    }
+
+    @Override
+    public <T> @Nullable T getOrDefault(PropertyKey<? extends Value<T>> property, T def) {
+        Value<T> value = this.getValue(property);
+        return value == null ? def : value.getValue();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <E, V extends Value<E>> @Nullable V getValue(PropertyKey<V> property) {
+        NbtPlatformAdapter adapter = this.adapters.get(property);
+        if (adapter == null) {
+            throw new UnsupportedOperationException("No adapter for: " + property);
+        }
+
+        return (V) adapter.getValue(this, property);
+    }
+
+    @Override
+    public <V, T extends Value<V>> @Nullable T getValueOrDefault(PropertyKey<T> key, T value) {
+        T val = this.getValue(key);
+        return val == null ? value : val;
+    }
+
+    @Override
+    public boolean hasProperty(PropertyKey<?> propertyKey) {
+        return this.compoundTag.contains(propertyKey.getKey());
+    }
+
+
+    public CompoundTag getCompoundTag() {
+        return compoundTag;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/AbstractListNbtPlatformAdapter.java b/src/main/java/io/papermc/paper/property/nbt/primitives/AbstractListNbtPlatformAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..52df14016394c5849ae40636f7fe189ca1308d38
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/AbstractListNbtPlatformAdapter.java
@@ -0,0 +1,113 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.nbt.NbtPlatformAdapter;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.value.ListValue;
+import io.papermc.paper.property.value.Value;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.Tag;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+public abstract class AbstractListNbtPlatformAdapter<T> implements NbtPlatformAdapter<List<T>, ListValue<T>> {
+
+    @Override
+    public ListValue<T> getValue(NbtPropertyHolder holder, PropertyKey<ListValue<T>> propertyKey) {
+        ListTag tag = holder.getCompoundTag().getList(propertyKey.getKey(), Tag.TAG_COMPOUND);
+
+        return new ListValue<>() {
+
+            @NotNull
+            @Override
+            public Iterator<T> iterator() {
+                Iterator<Tag> iterator = tag.iterator();
+                return new Iterator<>() {
+                    @Override
+                    public boolean hasNext() {
+                        return iterator.hasNext();
+                    }
+
+                    @Override
+                    public T next() {
+                        CompoundTag compoundTag = (CompoundTag) iterator.next();
+
+                        return AbstractListNbtPlatformAdapter.this.getType(NbtPropertyHolder.itemHolder(compoundTag), propertyKey);
+                    }
+                };
+            }
+
+            @Override
+            public List<T> getValue() {
+                List<T> list = new ArrayList<>();
+                for (Tag compound : tag) {
+                    CompoundTag compoundTag = (CompoundTag) compound;
+                    list.add(AbstractListNbtPlatformAdapter.this.getType(NbtPropertyHolder.itemHolder(compoundTag), propertyKey));
+                }
+
+                return list;
+            }
+
+            @Override
+            public PropertyKey<? extends Value<List<T>>> getKey() {
+                return propertyKey;
+            }
+
+            @Override
+            public T get(int index) {
+                return AbstractListNbtPlatformAdapter.this.getType(NbtPropertyHolder.itemHolder((CompoundTag) tag.get(index)), propertyKey);
+            }
+
+            @Override
+            public int size() {
+                return tag.size();
+            }
+
+            @Override
+            public void add(T value) {
+                this.insert(value, this.size());
+            }
+
+            @Override
+            public void insert(T value, int index) {
+                NbtPropertyHolder propertyHolder = NbtPropertyHolder.itemHolder(new CompoundTag());
+                AbstractListNbtPlatformAdapter.this.write(value, propertyHolder, propertyKey);
+                tag.add(index, propertyHolder.getCompoundTag());
+            }
+
+            @Override
+            public T remove(int index) {
+                return AbstractListNbtPlatformAdapter.this.getType(NbtPropertyHolder.itemHolder((CompoundTag) tag.remove(index)), propertyKey);
+            }
+        };
+    }
+
+    @Override
+    public ListValue<T> getNewValue(NbtPropertyHolder holder, PropertyKey<ListValue<T>> propertyKey) {
+        holder.getCompoundTag().put(propertyKey.getKey(), new ListTag());
+        return this.getValue(holder, propertyKey);
+    }
+
+    @Override
+    public void writeDirect(NbtPropertyHolder holder, PropertyKey<?> propertyKey, List<T> direct) {
+        for (T value : direct) {
+            NbtPropertyHolder propertyHolder = NbtPropertyHolder.itemHolder(new CompoundTag());
+            AbstractListNbtPlatformAdapter.this.write(value, propertyHolder, propertyKey);
+
+            holder.getCompoundTag().put(propertyKey.getKey(), propertyHolder.getCompoundTag());
+        }
+    }
+
+    public abstract T getType(NbtPropertyHolder propertyHolder, PropertyKey<?> propertyKey);
+
+    public abstract void write(T type, NbtPropertyHolder propertyHolder, PropertyKey<?> propertyKey);
+
+    @Override
+    public int getTagType() {
+        return Tag.TAG_LIST;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/BlockPositionNbtPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/BlockPositionNbtPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..7eed7ce505090bb1f455976aec256c0f051612f4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/BlockPositionNbtPrimitive.java
@@ -0,0 +1,26 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import io.papermc.paper.math.Position;
+import net.minecraft.core.BlockPos;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtUtils;
+import net.minecraft.nbt.Tag;
+
+public class BlockPositionNbtPrimitive extends SinglePrimitiveNbtPlatformAdapter<Position> {
+
+    @Override
+    public int getTagType() {
+        return Tag.TAG_COMPOUND;
+    }
+
+    @Override
+    public Position getType(Tag tag) {
+        BlockPos pos = NbtUtils.readBlockPos((CompoundTag) tag);
+        return Position.block(pos.getX(), pos.getY(), pos.getZ());
+    }
+
+    @Override
+    public Tag write(Position type) {
+        return NbtUtils.writeBlockPos(new BlockPos(type.blockZ(), type.blockY(), type.blockZ()));
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/BooleanPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/BooleanPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..1b192a7cb4196ad94c8ebbe4590280c103b8de84
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/BooleanPrimitive.java
@@ -0,0 +1,24 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import net.minecraft.nbt.ByteTag;
+import net.minecraft.nbt.IntTag;
+import net.minecraft.nbt.Tag;
+
+public class BooleanPrimitive extends SinglePrimitiveNbtPlatformAdapter<Boolean> {
+
+    @Override
+    public int getTagType() {
+        return IntTag.TAG_BYTE;
+    }
+
+    @Override
+    public Boolean getType(Tag tag) {
+        return ((ByteTag) tag).getAsByte() != 0;
+    }
+
+    @Override
+    public Tag write(Boolean type) {
+        return ByteTag.valueOf(type);
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/BytePrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/BytePrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..70d6603f2d28d93e4b7ae87079199e3160c1d849
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/BytePrimitive.java
@@ -0,0 +1,24 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import net.minecraft.nbt.ByteTag;
+import net.minecraft.nbt.IntTag;
+import net.minecraft.nbt.Tag;
+
+public class BytePrimitive extends SinglePrimitiveNbtPlatformAdapter<Byte> {
+
+    @Override
+    public int getTagType() {
+        return IntTag.TAG_BYTE;
+    }
+
+    @Override
+    public Byte getType(Tag tag) {
+        return ((ByteTag) tag).getAsByte();
+    }
+
+    @Override
+    public Tag write(Byte type) {
+        return ByteTag.valueOf(type);
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/ColorNbtPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/ColorNbtPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..65a9fb79a91ade533128d36ef8ac88bbbba27415
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/ColorNbtPrimitive.java
@@ -0,0 +1,20 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import org.bukkit.Color;
+
+public class ColorNbtPrimitive extends NbtPrimitiveWrapper<Color, Integer> {
+
+    public ColorNbtPrimitive() {
+        super(new IntegerPrimitive());
+    }
+
+    @Override
+    public Color fromPrimitive(Integer primitive) {
+        return Color.fromRGB(primitive);
+    }
+
+    @Override
+    public Integer toPrimitive(Color type) {
+        return type.asRGB();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/ComponentNbtPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/ComponentNbtPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..fd501ae1b53eacfd1a83d5c8268709333f247b47
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/ComponentNbtPrimitive.java
@@ -0,0 +1,21 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
+
+public class ComponentNbtPrimitive extends NbtPrimitiveWrapper<Component, String> {
+
+    public ComponentNbtPrimitive() {
+        super(new StringPrimitive());
+    }
+
+    @Override
+    public Component fromPrimitive(String primitive) {
+        return GsonComponentSerializer.gson().deserialize(primitive);
+    }
+
+    @Override
+    public String toPrimitive(Component type) {
+        return GsonComponentSerializer.gson().serialize(type);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/IntegerPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/IntegerPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..ca3d8e62c6cf7d16fa6af95a2e37a04550e2f0f2
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/IntegerPrimitive.java
@@ -0,0 +1,23 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import net.minecraft.nbt.IntTag;
+import net.minecraft.nbt.Tag;
+
+public class IntegerPrimitive extends SinglePrimitiveNbtPlatformAdapter<Integer> {
+
+    @Override
+    public int getTagType() {
+        return IntTag.TAG_INT;
+    }
+
+    @Override
+    public Integer getType(Tag tag) {
+        return ((IntTag) tag).getAsInt();
+    }
+
+    @Override
+    public Tag write(Integer type) {
+        return IntTag.valueOf(type);
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/ItemStackNbtPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/ItemStackNbtPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..a2f422db63ca15889d66c70072dd7da87a4a2f83
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/ItemStackNbtPrimitive.java
@@ -0,0 +1,24 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.Tag;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.inventory.ItemStack;
+
+public class ItemStackNbtPrimitive extends SinglePrimitiveNbtPlatformAdapter<ItemStack> {
+
+    @Override
+    public int getTagType() {
+        return Tag.TAG_COMPOUND;
+    }
+
+    @Override
+    public ItemStack getType(Tag tag) {
+        return CraftItemStack.asCraftMirror(net.minecraft.world.item.ItemStack.of((CompoundTag) tag));
+    }
+
+    @Override
+    public Tag write(ItemStack type) {
+        return (type instanceof CraftItemStack ? ((CraftItemStack) type).handle : CraftItemStack.asNMSCopy(type)).save(new CompoundTag());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/NamespaceKeyNbtPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/NamespaceKeyNbtPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..c1fe17fd099b09655c36ee1d42385764cfd38816
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/NamespaceKeyNbtPrimitive.java
@@ -0,0 +1,20 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import org.bukkit.NamespacedKey;
+
+public class NamespaceKeyNbtPrimitive extends NbtPrimitiveWrapper<NamespacedKey, String> {
+
+    public NamespaceKeyNbtPrimitive() {
+        super(new StringPrimitive());
+    }
+
+    @Override
+    public NamespacedKey fromPrimitive(String primitive) {
+        return NamespacedKey.fromString(primitive);
+    }
+
+    @Override
+    public String toPrimitive(NamespacedKey type) {
+        return type.toString();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/NbtPrimitiveWrapper.java b/src/main/java/io/papermc/paper/property/nbt/primitives/NbtPrimitiveWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..a5303d8b0de8bd18422e56b60facbd32f7a35319
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/NbtPrimitiveWrapper.java
@@ -0,0 +1,32 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import net.minecraft.nbt.Tag;
+
+public abstract class NbtPrimitiveWrapper<T, P> extends SinglePrimitiveNbtPlatformAdapter<T> {
+
+    private final SinglePrimitiveNbtPlatformAdapter<P> primitive;
+
+    public NbtPrimitiveWrapper(SinglePrimitiveNbtPlatformAdapter<P> primitive) {
+        this.primitive = primitive;
+    }
+
+    @Override
+    public int getTagType() {
+        return this.primitive.getTagType();
+    }
+
+    @Override
+    public T getType(Tag tag) {
+        return this.fromPrimitive(this.primitive.getType(tag));
+    }
+
+    @Override
+    public Tag write(T type) {
+        return this.primitive.write(this.toPrimitive(type));
+    }
+
+    public abstract T fromPrimitive(P primitive);
+
+    public abstract P toPrimitive(T type);
+
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/SinglePrimitiveNbtPlatformAdapter.java b/src/main/java/io/papermc/paper/property/nbt/primitives/SinglePrimitiveNbtPlatformAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..135f5947a422d5ea28b967f6398c347288bab149
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/SinglePrimitiveNbtPlatformAdapter.java
@@ -0,0 +1,59 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.nbt.NbtPlatformAdapter;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.value.Value;
+import net.minecraft.nbt.Tag;
+import org.jetbrains.annotations.Nullable;
+
+public abstract class SinglePrimitiveNbtPlatformAdapter<T> implements NbtPlatformAdapter<T, Value<T>> {
+
+    @Override
+    public Value<T> getValue(NbtPropertyHolder holder, PropertyKey<Value<T>> propertyKey) {
+        return new Value<>() {
+            @Override
+            public T getValue() {
+                return SinglePrimitiveNbtPlatformAdapter.this.getDirect(holder, propertyKey);
+            }
+
+            @Override
+            public PropertyKey<? extends Value<T>> getKey() {
+                return propertyKey;
+            }
+        };
+    }
+
+    @Override
+    public Value<T> getNewValue(NbtPropertyHolder holder, PropertyKey<Value<T>> propertyKey) {
+        return new Value<>() {
+            @Override
+            public @Nullable T getValue() {
+                return null;
+            }
+
+            @Override
+            public PropertyKey<? extends Value<T>> getKey() {
+                return propertyKey;
+            }
+        };
+    }
+
+    public T getDirect(NbtPropertyHolder holder, PropertyKey<?> propertyKey) {
+        Tag tag = holder.getCompoundTag().get(propertyKey.getKey());
+        if (tag != null && tag.getId() == SinglePrimitiveNbtPlatformAdapter.this.getTagType()) {
+            return SinglePrimitiveNbtPlatformAdapter.this.getType(tag);
+        }
+
+        return null;
+    }
+
+    @Override
+    public void writeDirect(NbtPropertyHolder holder, PropertyKey<?> propertyKey, T direct) {
+        holder.getCompoundTag().put(propertyKey.getKey(), this.write(direct));
+    }
+
+    public abstract T getType(Tag tag);
+
+    public abstract Tag write(T type);
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/StringPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/StringPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..9e4dfed6ac406391ac3205b0e9028ff1607a7f54
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/StringPrimitive.java
@@ -0,0 +1,24 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import net.minecraft.nbt.IntTag;
+import net.minecraft.nbt.StringTag;
+import net.minecraft.nbt.Tag;
+
+public class StringPrimitive extends SinglePrimitiveNbtPlatformAdapter<String> {
+
+    @Override
+    public int getTagType() {
+        return IntTag.TAG_STRING;
+    }
+
+    @Override
+    public String getType(Tag tag) {
+        return ((StringTag) tag).getAsString();
+    }
+
+    @Override
+    public Tag write(String type) {
+        return StringTag.valueOf(type);
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/AttributeMap.java b/src/main/java/io/papermc/paper/property/nbt/types/AttributeMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..4ba49fcf5099684f9f280b7f0703a4ca3d03ff30
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/AttributeMap.java
@@ -0,0 +1,92 @@
+package io.papermc.paper.property.nbt.types;
+
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.Multimap;
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.nbt.NbtPlatformAdapter;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.nbt.primitives.StringPrimitive;
+import io.papermc.paper.property.value.MultiMapValue;
+import io.papermc.paper.property.value.Value;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.resources.ResourceLocation;
+import org.bukkit.Registry;
+import org.bukkit.attribute.Attribute;
+import org.bukkit.attribute.AttributeModifier;
+import org.bukkit.craftbukkit.CraftEquipmentSlot;
+import org.bukkit.craftbukkit.attribute.CraftAttributeInstance;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+
+import java.util.Optional;
+
+public class AttributeMap implements NbtPlatformAdapter<Multimap<Attribute, AttributeModifier>, MultiMapValue<Attribute, AttributeModifier>> {
+
+    private static final PropertyKey<Value<String>> ATTRIBUTE_SLOT = PropertyKey.of("Slot", String.class);
+    private static final PropertyKey<Value<String>> ATTRIBUTE_NAME = PropertyKey.of("AttributeName", String.class);
+    private static final StringPrimitive PRIMITIVE = new StringPrimitive();
+
+    @Override
+    public MultiMapValue<Attribute, AttributeModifier> getValue(NbtPropertyHolder holder, PropertyKey<MultiMapValue<Attribute, AttributeModifier>> propertyKey) {
+        ListTag attributes = holder.getCompoundTag().getList(propertyKey.getKey(), Tag.TAG_COMPOUND);
+
+        Multimap<Attribute, AttributeModifier> attributeMap = HashMultimap.create();
+        for (Tag tag : attributes) {
+            CompoundTag compoundTag = (CompoundTag) tag;
+            ResourceLocation attributeName = ResourceLocation.tryParse(PRIMITIVE.getValue(holder, ATTRIBUTE_NAME).getValue());
+
+            Optional<net.minecraft.world.entity.ai.attributes.Attribute> optional = BuiltInRegistries.ATTRIBUTE.getOptional(attributeName);
+            if (optional.isPresent()) {
+                net.minecraft.world.entity.ai.attributes.AttributeModifier modifier = net.minecraft.world.entity.ai.attributes.AttributeModifier.load(compoundTag);
+                attributeMap.put(Registry.ATTRIBUTE.get(CraftNamespacedKey.fromMinecraft(attributeName)), CraftAttributeInstance.convert(modifier));
+            }
+        }
+
+        return new MultiMapValue<>() {
+            @Override
+            public Multimap<Attribute, AttributeModifier> getValue() {
+                return attributeMap;
+            }
+
+            @Override
+            public PropertyKey<? extends Value<Multimap<Attribute, AttributeModifier>>> getKey() {
+                return propertyKey;
+            }
+        };
+    }
+
+    @Override
+    public void writeDirect(NbtPropertyHolder holder, PropertyKey<?> propertyKey, Multimap<Attribute, AttributeModifier> direct) {
+        ListTag attributes = new ListTag();
+        for (AttributeModifier attributeModifier : direct.values()) {
+            net.minecraft.world.entity.ai.attributes.AttributeModifier nmsModifier = CraftAttributeInstance.convert(attributeModifier);
+
+            NbtPropertyHolder attributeHolder = NbtPropertyHolder.configuredBlob(nmsModifier.save(), (nbtPropertyHolder) -> {
+                nbtPropertyHolder.register(ATTRIBUTE_NAME, new StringPrimitive());
+                nbtPropertyHolder.register(ATTRIBUTE_SLOT, new StringPrimitive());
+            });
+
+            attributeHolder.set(ATTRIBUTE_NAME, attributeModifier.getName());
+            if (attributeModifier.getSlot() != null) {
+                attributeHolder.set(ATTRIBUTE_SLOT, CraftEquipmentSlot.getNMS(attributeModifier.getSlot()).name());
+            }
+
+            attributes.add(attributeHolder.getCompoundTag());
+        }
+
+        holder.getCompoundTag().put(propertyKey.getKey(), attributes);
+    }
+
+    @Override
+    public MultiMapValue<Attribute, AttributeModifier> getNewValue(NbtPropertyHolder holder, PropertyKey<MultiMapValue<Attribute, AttributeModifier>> propertyKey) {
+        holder.getCompoundTag().put(propertyKey.getKey(), new ListTag());
+        return this.getValue(holder, propertyKey);
+    }
+
+    @Override
+    public int getTagType() {
+        return Tag.TAG_COMPOUND;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/AxolotlVariantNbt.java b/src/main/java/io/papermc/paper/property/nbt/types/AxolotlVariantNbt.java
new file mode 100644
index 0000000000000000000000000000000000000000..97bedb86cfaeb5cd1f0ea655b04c91a8ec4c0656
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/AxolotlVariantNbt.java
@@ -0,0 +1,22 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.property.nbt.primitives.IntegerPrimitive;
+import io.papermc.paper.property.nbt.primitives.NbtPrimitiveWrapper;
+import org.bukkit.entity.Axolotl;
+
+public class AxolotlVariantNbt extends NbtPrimitiveWrapper<Axolotl.Variant, Integer> {
+
+    public AxolotlVariantNbt() {
+        super(new IntegerPrimitive());
+    }
+
+    @Override
+    public Axolotl.Variant fromPrimitive(Integer primitive) {
+        return Axolotl.Variant.values()[primitive];
+    }
+
+    @Override
+    public Integer toPrimitive(Axolotl.Variant type) {
+        return type.ordinal();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/CompoundTagNbt.java b/src/main/java/io/papermc/paper/property/nbt/types/CompoundTagNbt.java
new file mode 100644
index 0000000000000000000000000000000000000000..c135b512f558370df3b1120c17758d706947c0f9
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/CompoundTagNbt.java
@@ -0,0 +1,105 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.property.PropertyHolder;
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.StoredPropertyHolder;
+import io.papermc.paper.property.nbt.NbtPlatformAdapter;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.value.Value;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.Tag;
+import org.jetbrains.annotations.Nullable;
+
+public class CompoundTagNbt implements NbtPlatformAdapter<PropertyHolder, StoredPropertyHolder> {
+    @Override
+    public StoredPropertyHolder getValue(NbtPropertyHolder holder, PropertyKey<StoredPropertyHolder> propertyKey) {
+        if (!holder.getCompoundTag().contains(propertyKey.getKey(), Tag.TAG_COMPOUND)) {
+            return null;
+        }
+
+        CompoundTag compoundTag = holder.getCompoundTag().getCompound(propertyKey.getKey());
+        NbtPropertyHolder wrappedholder = NbtPropertyHolder.simpleBlob(compoundTag);
+        return new StoredPropertyHolder() {
+            @Override
+            public void set(Value<?> value) {
+                wrappedholder.set(value);
+            }
+
+            @Override
+            public <T> void unset(PropertyKey<? extends Value<T>> key) {
+                wrappedholder.unset(key);
+            }
+
+            @Override
+            public <T> void set(PropertyKey<? extends Value<T>> key, T value) {
+                wrappedholder.set(key, value);
+            }
+
+            @Override
+            public <V, T extends Value<V>> T create(PropertyKey<T> key) {
+                return wrappedholder.create(key);
+            }
+
+            @Override
+            public <V, T extends Value<V>> T getOrCreate(PropertyKey<T> key) {
+                return wrappedholder.getOrCreate(key);
+            }
+
+            @Override
+            public <T> @Nullable T get(PropertyKey<? extends Value<T>> property) {
+                return wrappedholder.get(property);
+            }
+
+            @Override
+            public <T> @Nullable T getOrDefault(PropertyKey<? extends Value<T>> property, T value) {
+                return wrappedholder.getOrDefault(property, value);
+            }
+
+            @Override
+            public <E, V extends Value<E>> @Nullable V getValue(PropertyKey<V> property) {
+                return wrappedholder.getValue(property);
+            }
+
+            @Override
+            public <V, T extends Value<V>> @Nullable T getValueOrDefault(PropertyKey<T> key, T value) {
+                return wrappedholder.getValueOrDefault(key, value);
+            }
+
+            @Override
+            public boolean hasProperty(PropertyKey<?> propertyKey) {
+                return wrappedholder.hasProperty(propertyKey);
+            }
+
+            @Override
+            public PropertyHolder getValue() {
+                return wrappedholder;
+            }
+
+            @Override
+            public PropertyKey<? extends Value<PropertyHolder>> getKey() {
+                return propertyKey;
+            }
+        };
+    }
+
+    @Override
+    public void writeDirect(NbtPropertyHolder holder, PropertyKey<?> propertyKey, PropertyHolder direct) {
+        if (direct instanceof NbtPropertyHolder nbtPropertyHolder) {
+            holder.getCompoundTag().put(propertyKey.getKey(), nbtPropertyHolder.getCompoundTag().copy());
+        } else {
+            throw new UnsupportedOperationException(); // TODO ?
+        }
+    }
+
+    @Override
+    public StoredPropertyHolder getNewValue(NbtPropertyHolder holder, PropertyKey<StoredPropertyHolder> propertyKey) {
+        holder.getCompoundTag().put(propertyKey.getKey(), new CompoundTag());
+        return this.getValue(holder, propertyKey);
+    }
+
+    @Override
+    public int getTagType() {
+        return Tag.TAG_COMPOUND;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/EnchantmentsMap.java b/src/main/java/io/papermc/paper/property/nbt/types/EnchantmentsMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..a207c148ad83edc679c31aa1247281cde52cae39
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/EnchantmentsMap.java
@@ -0,0 +1,133 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.nbt.NbtPlatformAdapter;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.value.MapValue;
+import io.papermc.paper.property.value.Value;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
+import org.bukkit.craftbukkit.enchantments.CraftEnchantment;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.bukkit.enchantments.Enchantment;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+public class EnchantmentsMap implements NbtPlatformAdapter<Map<Enchantment, Integer>, MapValue<Enchantment, Integer>> {
+
+    @Override
+    public MapValue<Enchantment, Integer> getValue(NbtPropertyHolder holder, PropertyKey<MapValue<Enchantment, Integer>> propertyKey) {
+        ListTag tag = holder.getCompoundTag().getList(propertyKey.getKey(), Tag.TAG_COMPOUND);
+
+        Map<net.minecraft.world.item.enchantment.Enchantment, Integer> enchantments = EnchantmentHelper.deserializeEnchantments(tag);
+
+        return new MapValue<>() {
+            @Override
+            public Integer getEntry(Enchantment key) {
+                return enchantments.get(CraftEnchantment.getRaw(key));
+            }
+
+            @Override
+            public boolean has(Enchantment key) {
+                return enchantments.containsKey(CraftEnchantment.getRaw(key));
+            }
+
+            @Override
+            public Integer put(Enchantment key, Integer value) {
+                Integer result = enchantments.put(CraftEnchantment.getRaw(key), value);
+                EnchantmentsMap.this.setEnchantments(enchantments, propertyKey, holder);
+                return result;
+            }
+
+            @Override
+            public boolean removeEntry(Enchantment key) {
+                boolean result = enchantments.remove(CraftEnchantment.getRaw(key)) != null;
+                EnchantmentsMap.this.setEnchantments(enchantments, propertyKey, holder);
+                return result;
+            }
+
+            @Override
+            public int size() {
+                return enchantments.size();
+            }
+
+            @Override
+            public Map<Enchantment, Integer> getValue() {
+                Map<Enchantment, Integer> bukkitEnchantmentMap = new LinkedHashMap<>();
+                for (Map.Entry<net.minecraft.world.item.enchantment.Enchantment, Integer> nmsEnchantment : EnchantmentHelper.deserializeEnchantments(tag).entrySet()) {
+                    bukkitEnchantmentMap.put(Enchantment.getByKey(CraftNamespacedKey.fromMinecraft(BuiltInRegistries.ENCHANTMENT.getKey(nmsEnchantment.getKey()))), nmsEnchantment.getValue());
+                }
+
+                return bukkitEnchantmentMap;
+            }
+
+            @Override
+            public PropertyKey<? extends Value<Map<Enchantment, Integer>>> getKey() {
+                return propertyKey;
+            }
+
+            @NotNull
+            @Override
+            public Iterator<Map.Entry<Enchantment, Integer>> iterator() {
+                Iterator<Tag> iterator = tag.iterator();
+                return new Iterator<>() {
+                    @Override
+                    public boolean hasNext() {
+                        return iterator.hasNext();
+                    }
+
+                    @Override
+                    public Map.Entry<Enchantment, Integer> next() {
+                        CompoundTag compoundTag = (CompoundTag) iterator.next();
+                        Enchantment enchantment = Enchantment.getByKey(CraftNamespacedKey.fromMinecraft(EnchantmentHelper.getEnchantmentId(compoundTag)));
+                        int level = EnchantmentHelper.getEnchantmentLevel(compoundTag);
+
+                        return Map.entry(enchantment, level);
+                    }
+                };
+            }
+        };
+    }
+
+    @Override
+    public void writeDirect(NbtPropertyHolder holder, PropertyKey<?> propertyKey, Map<Enchantment, Integer> direct) {
+        Map<net.minecraft.world.item.enchantment.Enchantment, Integer> nmsEnchantmentMap = new LinkedHashMap<>();
+        for (Map.Entry<Enchantment, Integer> bukkit : direct.entrySet()) {
+            nmsEnchantmentMap.put(CraftEnchantment.getRaw(bukkit.getKey()), bukkit.getValue());
+        }
+
+        this.setEnchantments(nmsEnchantmentMap, propertyKey, holder);
+    }
+
+    @Override
+    public MapValue<Enchantment, Integer> getNewValue(NbtPropertyHolder holder, PropertyKey<MapValue<Enchantment, Integer>> propertyKey) {
+        holder.getCompoundTag().put(propertyKey.getKey(), new ListTag());
+        return this.getValue(holder, propertyKey);
+    }
+
+    @Override
+    public int getTagType() {
+        return Tag.TAG_LIST;
+    }
+
+    // See EnchantmentHelper
+    private void setEnchantments(Map<net.minecraft.world.item.enchantment.Enchantment, Integer> enchantments, PropertyKey<?> key, NbtPropertyHolder nbtPropertyHolder) {
+        ListTag listTag = new ListTag();
+
+        for (Map.Entry<net.minecraft.world.item.enchantment.Enchantment, Integer> entry : enchantments.entrySet()) {
+            net.minecraft.world.item.enchantment.Enchantment enchantment = entry.getKey();
+            if (enchantment != null) {
+                int i = entry.getValue();
+                listTag.add(EnchantmentHelper.storeEnchantment(EnchantmentHelper.getEnchantmentId(enchantment), i));
+            }
+        }
+
+        nbtPropertyHolder.getCompoundTag().put(key.getKey(), listTag);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/ItemFlagBitset.java b/src/main/java/io/papermc/paper/property/nbt/types/ItemFlagBitset.java
new file mode 100644
index 0000000000000000000000000000000000000000..2e1a83abff08068f42be71761ae87026af174db6
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/ItemFlagBitset.java
@@ -0,0 +1,94 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.nbt.NbtPlatformAdapter;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.nbt.primitives.IntegerPrimitive;
+import io.papermc.paper.property.value.SetValue;
+import io.papermc.paper.property.value.Value;
+import net.minecraft.nbt.IntTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.Tag;
+import org.bukkit.inventory.ItemFlag;
+
+import java.util.EnumSet;
+import java.util.Objects;
+import java.util.Set;
+
+public class ItemFlagBitset implements NbtPlatformAdapter<Set<ItemFlag>, SetValue<ItemFlag>> {
+
+    private static final IntegerPrimitive PRIMITIVE = new IntegerPrimitive();
+
+    @Override
+    public SetValue<ItemFlag> getValue(NbtPropertyHolder holder, PropertyKey<SetValue<ItemFlag>> propertyKey) {
+        return new SetValue<>() {
+            @Override
+            public boolean contains(ItemFlag value) {
+                int flags = Objects.requireNonNullElse(PRIMITIVE.getDirect(holder, propertyKey), 0);
+                return this.contains(value, flags);
+            }
+
+            @Override
+            public void add(ItemFlag value) {
+                int flags = Objects.requireNonNullElse(PRIMITIVE.getDirect(holder, propertyKey), 0);
+                flags |= ItemFlagBitset.this.getBitModifier(value);
+                PRIMITIVE.writeDirect(holder, propertyKey, flags);
+            }
+
+            @Override
+            public void remove(ItemFlag value) {
+                int flags = Objects.requireNonNullElse(PRIMITIVE.getDirect(holder, propertyKey), 0);
+                flags &= ~ItemFlagBitset.this.getBitModifier(value);
+                PRIMITIVE.writeDirect(holder, propertyKey, flags);
+            }
+
+            @Override
+            public Set<ItemFlag> getValue() {
+                int flags = Objects.requireNonNullElse(PRIMITIVE.getDirect(holder, propertyKey), 0);
+                Set<ItemFlag> currentFlags = EnumSet.noneOf(ItemFlag.class);
+
+                for (ItemFlag f : ItemFlag.values()) {
+                    if (this.contains(f, flags)) {
+                        currentFlags.add(f);
+                    }
+                }
+
+                return currentFlags;
+            }
+
+            @Override
+            public PropertyKey<? extends Value<Set<ItemFlag>>> getKey() {
+                return propertyKey;
+            }
+
+            private boolean contains(ItemFlag itemFlag, int flags) {
+                int bitModifier = ItemFlagBitset.this.getBitModifier(itemFlag);
+                return (flags & bitModifier) == bitModifier;
+            }
+        };
+    }
+
+    @Override
+    public void writeDirect(NbtPropertyHolder holder, PropertyKey<?> propertyKey, Set<ItemFlag> direct) {
+        int flags = 0;
+        for (ItemFlag itemFlag : direct) {
+            flags |= this.getBitModifier(itemFlag);
+        }
+        PRIMITIVE.writeDirect(holder, propertyKey, flags);
+    }
+
+    private byte getBitModifier(ItemFlag hideFlag) {
+        return (byte) (1 << hideFlag.ordinal());
+    }
+
+    @Override
+    public SetValue<ItemFlag> getNewValue(NbtPropertyHolder holder, PropertyKey<SetValue<ItemFlag>> propertyKey) {
+        holder.getCompoundTag().put(propertyKey.getKey(), IntTag.valueOf(0));
+        return this.getValue(holder, propertyKey);
+    }
+
+    @Override
+    public int getTagType() {
+        return Tag.TAG_INT;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/StewEffectsListNbt.java b/src/main/java/io/papermc/paper/property/nbt/types/StewEffectsListNbt.java
new file mode 100644
index 0000000000000000000000000000000000000000..0c28d3ef6905a878bf42f15f65eb601465e8c9bd
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/StewEffectsListNbt.java
@@ -0,0 +1,35 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.inventory.item.properties.StewEffect;
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.nbt.primitives.AbstractListNbtPlatformAdapter;
+import io.papermc.paper.property.nbt.primitives.IntegerPrimitive;
+import io.papermc.paper.property.value.Value;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.world.effect.MobEffect;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.bukkit.potion.PotionEffectType;
+
+public class StewEffectsListNbt extends AbstractListNbtPlatformAdapter<StewEffect> {
+
+    private static final PropertyKey<Value<Integer>> EFFECT = PropertyKey.of("EffectId", Integer.class);
+    private static final PropertyKey<Value<Integer>> EFFECT_DURATION = PropertyKey.of("EffectDuration", Integer.class);
+
+    private static final IntegerPrimitive PRIMITIVE = new IntegerPrimitive();
+
+    @Override
+    public StewEffect getType(NbtPropertyHolder propertyHolder, PropertyKey<?> propertyKey) {
+        int duration = PRIMITIVE.getDirect(propertyHolder, EFFECT_DURATION);
+        MobEffect mobEffect = MobEffect.byId(PRIMITIVE.getDirect(propertyHolder, EFFECT));
+        PotionEffectType type = PotionEffectType.getByKey(CraftNamespacedKey.fromMinecraft(BuiltInRegistries.MOB_EFFECT.getKey(mobEffect)));
+
+        return new StewEffect(type, duration);
+    }
+
+    @Override
+    public void write(StewEffect type, NbtPropertyHolder propertyHolder, PropertyKey<?> propertyKey) {
+        PRIMITIVE.writeDirect(propertyHolder, EFFECT, BuiltInRegistries.MOB_EFFECT.getId(BuiltInRegistries.MOB_EFFECT.get(CraftNamespacedKey.toMinecraft(type.effect().getKey()))));
+        PRIMITIVE.writeDirect(propertyHolder, EFFECT_DURATION, type.duration());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/TropicalFishVariantNbt.java b/src/main/java/io/papermc/paper/property/nbt/types/TropicalFishVariantNbt.java
new file mode 100644
index 0000000000000000000000000000000000000000..afb1d3dfa407195900708489aab4b5bf5b1c2c96
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/TropicalFishVariantNbt.java
@@ -0,0 +1,24 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.inventory.item.properties.TropicalFishVariant;
+import io.papermc.paper.property.nbt.primitives.IntegerPrimitive;
+import io.papermc.paper.property.nbt.primitives.NbtPrimitiveWrapper;
+import org.bukkit.Color;
+import org.bukkit.craftbukkit.entity.CraftTropicalFish;
+
+public class TropicalFishVariantNbt extends NbtPrimitiveWrapper<TropicalFishVariant, Integer> {
+
+    public TropicalFishVariantNbt() {
+        super(new IntegerPrimitive());
+    }
+
+    @Override
+    public TropicalFishVariant fromPrimitive(Integer primitive) {
+        return new TropicalFishVariant(CraftTropicalFish.getPatternColor(primitive), CraftTropicalFish.getBodyColor(primitive), CraftTropicalFish.getPattern(primitive));
+    }
+
+    @Override
+    public Integer toPrimitive(TropicalFishVariant type) {
+        return CraftTropicalFish.getData(type.patternColor(), type.bodyColor(), type.type());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/WrappedListNbt.java b/src/main/java/io/papermc/paper/property/nbt/types/WrappedListNbt.java
new file mode 100644
index 0000000000000000000000000000000000000000..396eba746dea092b2e338e2b5b4db060da9321c8
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/WrappedListNbt.java
@@ -0,0 +1,35 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.nbt.NbtPlatformAdapter;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.nbt.primitives.AbstractListNbtPlatformAdapter;
+import io.papermc.paper.property.nbt.primitives.NbtPrimitiveWrapper;
+import io.papermc.paper.property.nbt.primitives.SinglePrimitiveNbtPlatformAdapter;
+import io.papermc.paper.property.value.Value;
+import net.minecraft.nbt.Tag;
+import net.minecraft.nbt.TagType;
+
+public class WrappedListNbt<T> extends AbstractListNbtPlatformAdapter<T> {
+
+    private final SinglePrimitiveNbtPlatformAdapter<T> wrapper;
+
+    public WrappedListNbt(SinglePrimitiveNbtPlatformAdapter<T> wrapper) {
+        this.wrapper = wrapper;
+    }
+
+    @Override
+    public T getType(NbtPropertyHolder propertyHolder, PropertyKey<?> propertyKey) {
+        return wrapper.getDirect(propertyHolder, propertyKey);
+    }
+
+    @Override
+    public void write(T type, NbtPropertyHolder propertyHolder, PropertyKey<?> propertyKey) {
+        wrapper.writeDirect(propertyHolder, propertyKey, type);
+    }
+
+    @Override
+    public int getTagType() {
+        return Tag.TAG_LIST;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/value/ValueImpl.java b/src/main/java/io/papermc/paper/property/value/ValueImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..4c385cfbc0402bf3119d30b3f0f1bc4b40eeae8a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/value/ValueImpl.java
@@ -0,0 +1,32 @@
+package io.papermc.paper.property.value;
+
+import io.papermc.paper.property.PropertyKey;
+
+public abstract class ValueImpl<V, T extends Value<V>> implements Value<V> {
+
+    protected final PropertyKey<T> key;
+    protected V value;
+
+    protected ValueImpl(PropertyKey<T> key, V value) {
+        this.key = key;
+        this.value = value;
+    }
+
+    @Override
+    public PropertyKey<T> getKey() {
+        return this.key;
+    }
+
+    @Override
+    public V getValue() {
+        return this.value;
+    }
+
+    @Override
+    public String toString() {
+        return "ValueImpl{" +
+            "key=" + key +
+            ", value=" + value +
+            '}';
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/value/provider/ValueProvider.java b/src/main/java/io/papermc/paper/property/value/provider/ValueProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..d3a511b306bf29c3dd6afa73fedbf480a1eb2ae1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/value/provider/ValueProvider.java
@@ -0,0 +1,13 @@
+package io.papermc.paper.property.value.provider;
+
+import io.papermc.paper.property.value.Value;
+
+public interface ValueProvider<T, V extends Value<T>> {
+
+    V createNew();
+
+    V wrapValue(T data);
+
+
+
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index 17336102d37a5ab05c3b3c93fcf46961d0ffa7e2..9b25c8f572062f0c7adbc9ec119e7360a10f1942 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -620,6 +620,21 @@ public final class CraftMagicNumbers implements UnsafeValues {
         net.minecraft.core.Holder<net.minecraft.world.level.biome.Biome> biomeBase = cra.getHandle().registryAccess().registryOrThrow(net.minecraft.core.registries.Registries.BIOME).getHolderOrThrow(net.minecraft.resources.ResourceKey.create(net.minecraft.core.registries.Registries.BIOME, org.bukkit.craftbukkit.util.CraftNamespacedKey.toMinecraft(biomeKey)));
         cra.setBiome(x, y, z, biomeBase);
     }
+
+    @Override
+    public io.papermc.paper.property.PropertyHolder.Mutable getPropertyHolder(ItemStack itemStack) {
+        if (itemStack instanceof org.bukkit.craftbukkit.inventory.CraftItemStack craftItemStack) {
+            return io.papermc.paper.property.nbt.NbtPropertyHolder.itemHolder(craftItemStack.handle.getOrCreateTag());
+        }
+
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ItemStack newItem(Material material, int count) {
+        return CraftItemStack.asCraftCopy(new ItemStack(material, count));
+    }
+
     // Paper end
 
     /**
