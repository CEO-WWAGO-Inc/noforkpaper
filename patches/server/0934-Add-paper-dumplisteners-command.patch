From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Warrior <50800980+Warriorrrr@users.noreply.github.com>
Date: Tue, 25 Oct 2022 21:15:37 +0200
Subject: [PATCH] Add /paper dumplisteners command

Co-authored-by: TwoLeggedCat <80929284+TwoLeggedCat@users.noreply.github.com>

diff --git a/src/main/java/io/papermc/paper/command/PaperCommand.java b/src/main/java/io/papermc/paper/command/PaperCommand.java
index 724592234e2a178a518f6ab7d09c3180780371a7..92154550b41b2e1d03deb1271b71bb3baa735e0a 100644
--- a/src/main/java/io/papermc/paper/command/PaperCommand.java
+++ b/src/main/java/io/papermc/paper/command/PaperCommand.java
@@ -2,6 +2,7 @@ package io.papermc.paper.command;
 
 import io.papermc.paper.command.subcommands.ChunkDebugCommand;
 import io.papermc.paper.command.subcommands.DumpItemCommand;
+import io.papermc.paper.command.subcommands.DumpListenersCommand;
 import io.papermc.paper.command.subcommands.EntityCommand;
 import io.papermc.paper.command.subcommands.FixLightCommand;
 import io.papermc.paper.command.subcommands.HeapDumpCommand;
@@ -50,6 +51,7 @@ public final class PaperCommand extends Command {
         commands.put(Set.of("syncloadinfo"), new SyncLoadInfoCommand());
         commands.put(Set.of("dumpitem"), new DumpItemCommand());
         commands.put(Set.of("mobcaps", "playermobcaps"), new MobcapsCommand());
+        commands.put(Set.of("dumplisteners"), new DumpListenersCommand());
 
         return commands.entrySet().stream()
             .flatMap(entry -> entry.getKey().stream().map(s -> Map.entry(s, entry.getValue())))
diff --git a/src/main/java/io/papermc/paper/command/subcommands/DumpListenersCommand.java b/src/main/java/io/papermc/paper/command/subcommands/DumpListenersCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..8a5733dbda6c1a602385e9f565a1217f62553ca2
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/subcommands/DumpListenersCommand.java
@@ -0,0 +1,111 @@
+package io.papermc.paper.command.subcommands;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.reflect.ClassPath;
+import io.papermc.paper.command.PaperSubcommand;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.bukkit.event.HandlerList;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.io.IOException;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+import java.util.stream.Stream;
+
+@DefaultQualifier(NonNull.class)
+public class DumpListenersCommand implements PaperSubcommand {
+    private static final Set<String> CLASS_CACHE = new HashSet<>();
+
+    @Override
+    public boolean execute(CommandSender sender, String subCommand, String[] args) {
+        this.doDumpListeners(sender, args);
+        return true;
+    }
+
+    public void doDumpListeners(CommandSender sender, String[] args) {
+        if (args.length == 0) {
+            sender.sendMessage(Component.text("Usage: /paper dumplisteners [className]", NamedTextColor.RED));
+            return;
+        }
+
+        try {
+            HandlerList handlers = (HandlerList) Class.forName(args[0]).getMethod("getHandlerList").invoke(null);
+
+            if (handlers.getRegisteredListeners().length == 0) {
+                sender.sendMessage(Component.text(args[0] + " does not have any registered listeners."));
+                return;
+            }
+
+            Component listeners = Stream.of(handlers.getRegisteredListeners())
+                .map(listener ->
+                    Component.text(listener.getPlugin().getName(), NamedTextColor.GREEN).append(Component.space())
+                        .append(Component.text("(" + listener.getListener().getClass().getName() + ")", NamedTextColor.GRAY).hoverEvent(Component.text("Priority: " + listener.getPriority().name() + " (" + listener.getPriority().getSlot() + ")", NamedTextColor.GRAY))))
+                .collect(Component.toComponent(Component.newline()));
+
+            sender.sendMessage(Component.text("Listeners for " + args[0] + ":").append(Component.newline())
+                .append(listeners).append(Component.newline())
+                .append(Component.text("Total listeners: " + handlers.getRegisteredListeners().length)));
+
+        } catch (ClassNotFoundException e) {
+            sender.sendMessage(Component.text("Unable to find a class named '" + args[0] + "'. Make sure to use the fully qualified name.", NamedTextColor.RED));
+        } catch (NoSuchMethodException e) {
+            sender.sendMessage(Component.text("Class '" + args[0] + "' does not have a valid getHandlerList method.", NamedTextColor.RED));
+        } catch (ReflectiveOperationException e) {
+            sender.sendMessage(Component.text("Something went wrong, see the console for more details.", NamedTextColor.RED));
+            MinecraftServer.LOGGER.warn("Error occurred while dumping listeners for class " + args[0], e);
+        }
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String subCommand, String[] args) {
+        return switch (args.length) {
+            case 0 -> ImmutableList.copyOf(CLASS_CACHE);
+            case 1 -> {
+                if (CLASS_CACHE.isEmpty()) {
+                    populateCache();
+                    yield Collections.emptyList();
+                }
+
+                yield CLASS_CACHE.stream().filter(clazz -> clazz.toLowerCase(Locale.ROOT).contains(args[0].toLowerCase(Locale.ROOT))).toList();
+            }
+
+            default -> Collections.emptyList();
+        };
+    }
+
+    public static void clearClassCache() {
+        CLASS_CACHE.clear();
+    }
+
+    @SuppressWarnings("UnstableApiUsage")
+    private static void populateCache() {
+        clearClassCache();
+
+        CompletableFuture.runAsync(() -> {
+            ClassPath classPath;
+            try {
+                classPath = ClassPath.from(Bukkit.class.getClassLoader());
+            } catch (IOException e) {
+                MinecraftServer.LOGGER.info("Failed get bukkit classpath", e);
+                return;
+            }
+
+            for (ClassPath.ClassInfo classInfo : classPath.getAllClasses()) {
+                try {
+                    Class<?> clazz = classInfo.load();
+                    clazz.getMethod("getHandlerList");
+                    CLASS_CACHE.add(clazz.getName());
+                } catch (NoSuchMethodException | NoClassDefFoundError ignored) {}
+            }
+        });
+    }
+}
