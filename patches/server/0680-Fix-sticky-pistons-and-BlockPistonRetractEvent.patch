From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Potrebic <jake.m.potrebic@gmail.com>
Date: Wed, 22 Dec 2021 09:51:48 -0800
Subject: [PATCH] Fix sticky pistons and BlockPistonRetractEvent

There is an explicit check in the handling code for empty pistons that
prevents sticky pistons from firing the event. However when we look back
at the history we see that this check was originally added so that ONLY
sticky pistons would fire the retract event. I'm not sure why.
https://hub.spigotmc.org/stash/projects/SPIGOT/repos/craftbukkit/commits/1092acbddf07edfa4100bc6824504ac75088e913

Over the course of several updates, the meaning of that field appears to
have changed from "is NOT sticky" to "is sticky". So now its having the
opposite effect. Only normal pistons fire the retraction event. And like
all things in CB, it's just been carried around since.

If we are to believe the history, the correct fix for this issue is to
flip it so it only fires for sticky pistons, but that puts us in a
bind. It's already firing for non-sticky pistons, changing it now would
likely result in breakage. Furthermore, there is little documentation as
to WHY that was ever intended to be the case.

Instead we opt to remove the check entirely so that the event fires for
all piston types.

Also fixes some issues with cancelling the event for sticky pistons. It
required separate logic for restoring the pre-cancelled state of the piston
head being extended as the sticky event is delayed from the non-sticky event
due to the need to collect all the blocks that might be moved.

Co-authored-by: Zach Brown <zach@zachbr.io>
Co-authored-by: Madeline Miller <mnmiller1@me.com>

diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
index 0dbdcd443fe8a299119ea5ba3acb1a0412856184..b9becbcc13569596fb18eb3c30a64e1df6f3fe8f 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
@@ -159,15 +159,15 @@ public class PistonBaseBlock extends DirectionalBlock {
             }
 
             // CraftBukkit start
-            if (!this.isSticky) {
-                org.bukkit.block.Block block = world.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ());
-                BlockPistonRetractEvent event = new BlockPistonRetractEvent(block, ImmutableList.<org.bukkit.block.Block>of(), CraftBlock.notchToBlockFace(enumdirection));
-                world.getCraftServer().getPluginManager().callEvent(event);
-
-                if (event.isCancelled()) {
-                    return;
-                }
-            }
+            // if (!this.isSticky) { // Paper - Fix sticky pistons and BlockPistonRetractEvent; Move further down
+            //     org.bukkit.block.Block block = world.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ());
+            //     BlockPistonRetractEvent event = new BlockPistonRetractEvent(block, ImmutableList.<org.bukkit.block.Block>of(), CraftBlock.notchToBlockFace(enumdirection));
+            //     world.getCraftServer().getPluginManager().callEvent(event);
+            //
+            //     if (event.isCancelled()) {
+            //         return;
+            //     }
+            // }
             // PAIL: checkME - what happened to setTypeAndData?
             // CraftBukkit end
             world.blockEvent(pos, this, b0, enumdirection.get3DDataValue());
@@ -228,7 +228,7 @@ public class PistonBaseBlock extends DirectionalBlock {
         }
 
         if (type == 0) {
-            if (!this.moveBlocks(world, pos, enumdirection, true)) {
+            if (this.moveBlocks(world, state, pos, enumdirection, true) != MoveBlocksResult.SUCCESS) { // Paper - tristate return value
                 return false;
             }
 
@@ -244,14 +244,21 @@ public class PistonBaseBlock extends DirectionalBlock {
 
             BlockState iblockdata2 = (BlockState) ((BlockState) Blocks.MOVING_PISTON.defaultBlockState().setValue(MovingPistonBlock.FACING, enumdirection)).setValue(MovingPistonBlock.TYPE, this.isSticky ? PistonType.STICKY : PistonType.DEFAULT);
 
+            // Paper start - Fix sticky pistons and BlockPistonRetractEvent; Move empty piston retract call to fix multiple event fires
+            if (!this.isSticky) {
+                if (!new BlockPistonRetractEvent(CraftBlock.at(world, pos), java.util.Collections.emptyList(), CraftBlock.notchToBlockFace(enumdirection)).callEvent()) {
+                    return false;
+                }
+            }
+            // Paper end - Fix sticky pistons and BlockPistonRetractEvent
             world.setBlock(pos, iblockdata2, 20);
             world.setBlockEntity(MovingPistonBlock.newMovingBlockEntity(pos, iblockdata2, (BlockState) this.defaultBlockState().setValue(PistonBaseBlock.FACING, Direction.from3DDataValue(data & 7)), enumdirection, false, true));
             world.blockUpdated(pos, iblockdata2.getBlock());
-            iblockdata2.updateNeighbourShapes(world, pos, 2);
+            if (!this.isSticky) iblockdata1.updateNeighbourShapes(world, pos, 2); // Paper - move sticky update down until after piston event
             if (this.isSticky) {
                 BlockPos blockposition1 = pos.offset(enumdirection.getStepX() * 2, enumdirection.getStepY() * 2, enumdirection.getStepZ() * 2);
                 BlockState iblockdata3 = world.getBlockState(blockposition1);
-                boolean flag1 = false;
+                boolean isWorkingMovingPiston = false; // Paper - OBFHELPER
 
                 if (iblockdata3.is(Blocks.MOVING_PISTON)) {
                     BlockEntity tileentity1 = world.getBlockEntity(blockposition1);
@@ -261,15 +268,31 @@ public class PistonBaseBlock extends DirectionalBlock {
 
                         if (tileentitypiston.getDirection() == enumdirection && tileentitypiston.isExtending()) {
                             tileentitypiston.finalTick();
-                            flag1 = true;
+                            isWorkingMovingPiston = true; // Paper - OBFHELPER
                         }
                     }
                 }
 
-                if (!flag1) {
+                if (isWorkingMovingPiston) iblockdata1.updateNeighbourShapes(world, pos, 2); // Paper - move this from right after creating the moving piston block entity to after the event call
+                if (!isWorkingMovingPiston) { // Paper - OBFHELPER
                     if (type == 1 && !iblockdata3.isAir() && PistonBaseBlock.isPushable(iblockdata3, world, blockposition1, enumdirection.getOpposite(), false, enumdirection) && (iblockdata3.getPistonPushReaction() == PushReaction.NORMAL || iblockdata3.is(Blocks.PISTON) || iblockdata3.is(Blocks.STICKY_PISTON))) {
-                        this.moveBlocks(world, pos, enumdirection, false);
+                        // Paper start - check return value
+                        if (this.moveBlocks(world, state, pos, enumdirection, false) == MoveBlocksResult.CANCEL) {
+                            return false;
+                        }
+                        iblockdata1.updateNeighbourShapes(world, pos, 2); // move this from right after creating the moving piston block entity to after the event call
+                        // Paper end
                     } else {
+                        // Paper start - Fix sticky pistons and BlockPistonRetractEvent; fire BlockPistonRetractEvent for sticky pistons retracting un-pushable block or air
+                        if (type == TRIGGER_CONTRACT) {
+                            if (!new BlockPistonRetractEvent(CraftBlock.at(world, pos), java.util.Collections.emptyList(), CraftBlock.notchToBlockFace(enumdirection)).callEvent()) {
+                                world.removeBlockEntity(pos);
+                                world.setBlock(pos, state, Block.UPDATE_KNOWN_SHAPE | 1024);
+                                return false;
+                            }
+                        }
+                        iblockdata1.updateNeighbourShapes(world, pos, 2); // move this from right after creating the moving piston block entity to after the event call
+                        // Paper end - Fix sticky pistons and BlockPistonRetractEvent
                         world.removeBlock(pos.relative(enumdirection), false);
                     }
                 }
@@ -320,18 +343,33 @@ public class PistonBaseBlock extends DirectionalBlock {
             return false;
         }
     }
+    private enum MoveBlocksResult { FAIL, CANCEL, SUCCESS } // Paper
 
-    private boolean moveBlocks(Level world, BlockPos pos, Direction dir, boolean retract) {
+    private MoveBlocksResult moveBlocks(Level world, BlockState oldState, BlockPos pos, Direction dir, boolean retract) { // Paper - the "retract" param is incorrectly named, it should be "extend"
         BlockPos blockposition1 = pos.relative(dir);
 
-        if (!retract && world.getBlockState(blockposition1).is(Blocks.PISTON_HEAD)) {
+        // Paper start
+        final BlockState pistonHead = world.getBlockState(blockposition1);
+        if (!retract && pistonHead.is(Blocks.PISTON_HEAD)) {
+            // Paper end
             world.setBlock(blockposition1, Blocks.AIR.defaultBlockState(), 20);
         }
 
         PistonStructureResolver pistonextendschecker = new PistonStructureResolver(world, pos, dir, retract);
 
+        Direction enumdirection1 = retract ? dir : dir.getOpposite(); // Paper - moved from below
         if (!pistonextendschecker.resolve()) {
-            return false;
+            // Paper start - fire event if piston retracts without moving blocks
+            if (!retract) {
+                if (!new BlockPistonRetractEvent(CraftBlock.at(world, pos), java.util.Collections.emptyList(), CraftBlock.notchToBlockFace(enumdirection1)).callEvent()) {
+                    world.removeBlockEntity(pos);
+                    world.setBlock(pos, oldState, Block.UPDATE_KNOWN_SHAPE | 1024);
+                    world.setBlock(blockposition1, pistonHead, Block.UPDATE_KNOWN_SHAPE | 1024);
+                    return MoveBlocksResult.CANCEL;
+                }
+            }
+            return MoveBlocksResult.FAIL;
+            // Paper end
         } else {
             Map<BlockPos, BlockState> map = Maps.newHashMap();
             List<BlockPos> list = pistonextendschecker.getToPush();
@@ -348,7 +386,7 @@ public class PistonBaseBlock extends DirectionalBlock {
 
             List<BlockPos> list2 = pistonextendschecker.getToDestroy();
             BlockState[] aiblockdata = new BlockState[list.size() + list2.size()];
-            Direction enumdirection1 = retract ? dir : dir.getOpposite();
+            // Paper - moved up
             int i = 0;
             // CraftBukkit start
             final org.bukkit.block.Block bblock = world.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ());
@@ -376,11 +414,18 @@ public class PistonBaseBlock extends DirectionalBlock {
             if (retract) {
                 event = new BlockPistonExtendEvent(bblock, blocks, CraftBlock.notchToBlockFace(enumdirection1));
             } else {
-                event = new BlockPistonRetractEvent(bblock, blocks, CraftBlock.notchToBlockFace(enumdirection1));
+                event = new BlockPistonRetractEvent(bblock, blocks, CraftBlock.notchToBlockFace(enumdirection1.getOpposite())); // Paper - use consistent direction
             }
             world.getCraftServer().getPluginManager().callEvent(event);
 
             if (event.isCancelled()) {
+                // Paper start
+                if (!retract) {
+                    world.removeBlockEntity(pos);
+                    world.setBlock(pos, oldState, Block.UPDATE_KNOWN_SHAPE | 1024);
+                    world.setBlock(blockposition1, pistonHead, Block.UPDATE_KNOWN_SHAPE | 1024);
+                }
+                // Paper end
                 for (BlockPos b : broken) {
                     world.sendBlockUpdated(b, Blocks.AIR.defaultBlockState(), world.getBlockState(b), 3);
                 }
@@ -389,7 +434,7 @@ public class PistonBaseBlock extends DirectionalBlock {
                     b = b.relative(enumdirection1);
                     world.sendBlockUpdated(b, Blocks.AIR.defaultBlockState(), world.getBlockState(b), 3);
                 }
-                return false;
+                return MoveBlocksResult.CANCEL; // Paper
             }
             // CraftBukkit end
 
@@ -489,7 +534,7 @@ public class PistonBaseBlock extends DirectionalBlock {
                 world.updateNeighborsAt(blockposition1, Blocks.PISTON_HEAD);
             }
 
-            return true;
+            return MoveBlocksResult.SUCCESS; // Paper
         }
     }
 
