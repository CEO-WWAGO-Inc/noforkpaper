From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Thu, 28 May 2015 23:00:19 -0400
Subject: [PATCH] Handle Item Meta Inconsistencies

First, Enchantment order would blow away seeing 2 items as the same,
however the Client forces enchantment list in a certain order, as well
as does the /enchant command. Anvils can insert it into forced order,
causing 2 same items to be considered different.

This change makes unhandled NBT Tags and Enchantments use a sorted tree map,
so they will always be in a consistent order.

Additionally, the old enchantment API was never updated when ItemMeta
was added, resulting in 2 different ways to modify an items enchantments.

For consistency, the old API methods now forward to use the
ItemMeta API equivalents, and should deprecate the old API's.

diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index e937186aaf819a77c80beeb9e08413a1f781c13a..0e19f49ca2496b1c42d27289bcea15d26993ca85 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -151,6 +151,23 @@ public final class ItemStack {
         return this.getItem().getTooltipImage(this);
     }
 
+    // Paper start
+    private static final java.util.Comparator<? super CompoundTag> enchantSorter = java.util.Comparator.comparing(o -> o.getString("id"));
+    private void processEnchantOrder(@Nullable CompoundTag tag) {
+        if (tag == null || !tag.contains("Enchantments", 9)) {
+            return;
+        }
+        ListTag list = tag.getList("Enchantments", 10);
+        if (list.size() < 2) {
+            return;
+        }
+        try {
+            //noinspection unchecked
+            list.sort((java.util.Comparator<? super net.minecraft.nbt.Tag>) enchantSorter); // Paper
+        } catch (Exception ignored) {}
+    }
+    // Paper end
+
     public ItemStack(ItemLike item) {
         this(item, 1);
     }
@@ -202,6 +219,7 @@ public final class ItemStack {
             // CraftBukkit start - make defensive copy as this data may be coming from the save thread
             this.tag = nbttagcompound.getCompound("tag").copy();
             // CraftBukkit end
+            this.processEnchantOrder(this.tag); // Paper
             this.getItem().verifyTagAfterLoad(this.tag);
         }
 
@@ -772,6 +790,7 @@ public final class ItemStack {
 
     public void setTag(@Nullable CompoundTag nbt) {
         this.tag = nbt;
+        this.processEnchantOrder(this.tag); // Paper
         if (this.getItem().canBeDepleted()) {
             this.setDamageValue(this.getDamageValue());
         }
@@ -1061,6 +1080,7 @@ public final class ItemStack {
         ListTag nbttaglist = this.tag.getList("Enchantments", 10);
 
         nbttaglist.add(EnchantmentHelper.storeEnchantment(EnchantmentHelper.getEnchantmentId(enchantment), (byte) level));
+        processEnchantOrder(this.tag); // Paper
     }
 
     public boolean isEnchanted() {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
index 4b79b96579efbc4dd9a10e7183ed08b73b488794..301b81ffd2fceee1fd28f9352c6d3cffc0a4672e 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
@@ -126,10 +126,43 @@ public final class CraftItemStack extends ItemStack {
         } else if (this.handle == null) {
             this.handle = new net.minecraft.world.item.ItemStack(CraftMagicNumbers.getItem(type), 1);
         } else {
-            this.handle.setItem(CraftMagicNumbers.getItem(type));
-            if (this.hasItemMeta()) {
-                // This will create the appropriate item meta, which will contain all the data we intend to keep
-                CraftItemStack.setItemMeta(this.handle, CraftItemStack.getItemMeta(this.handle));
+            // Paper start
+            Item item = CraftMagicNumbers.getItem(type);
+            Material oldType = getType();
+            this.handle.setItem(item);
+
+            // Adjust size
+            if(this.handle.getCount() > item.getMaxStackSize()) {
+                this.handle.setCount(item.getMaxStackSize());
+            }
+
+            if(this.handle.hasTag()) {
+                // Strip damage
+                if(this.handle.isDamageableItem() && !item.canBeDepleted()) {
+                    this.handle.getTag().remove(CraftMetaItem.DAMAGE.NBT);
+                    this.handle.getTag().remove(CraftMetaItem.UNBREAKABLE.NBT);
+                }
+
+                this.handle.getTag().remove(CraftMetaItem.CUSTOM_MODEL_DATA.NBT);
+
+                // Strip invalid enchantments
+                EnchantmentMap map = CraftMetaItem.buildEnchantments(this.handle.getTag(), CraftMetaItem.ENCHANTMENTS);
+                if(map != null) {
+                    for (Enchantment enchant : getEnchantments().keySet()) {
+                        if (((CraftEnchantment) enchant).getHandle().category.canEnchant(item)) continue;
+                        map.remove(enchant);
+                    }
+                    CraftMetaItem.applyEnchantments(map, this.handle.getTag(), CraftMetaItem.ENCHANTMENTS);
+                }
+
+                // Strip invalid tags
+                CraftMetaItem.stripInvalidTags(oldType, type, this.handle.getTag());
+                // Paper end
+            }
+
+            // Adjust damage
+            if(item.canBeDepleted()) {
+                this.handle.getOrCreateTag().putInt(CraftMetaItem.DAMAGE.NBT, 0);
             }
         }
         setData(null);
@@ -178,28 +211,13 @@ public final class CraftItemStack extends ItemStack {
     public void addUnsafeEnchantment(Enchantment ench, int level) {
         Validate.notNull(ench, "Cannot add null enchantment");
 
-        if (!CraftItemStack.makeTag(this.handle)) {
-            return;
-        }
-        ListTag list = CraftItemStack.getEnchantmentList(this.handle);
-        if (list == null) {
-            list = new ListTag();
-            this.handle.getTag().put(ENCHANTMENTS.NBT, list);
-        }
-        int size = list.size();
-
-        for (int i = 0; i < size; i++) {
-            CompoundTag tag = (CompoundTag) list.get(i);
-            String id = tag.getString(ENCHANTMENTS_ID.NBT);
-            if (ench.getKey().equals(NamespacedKey.fromString(id))) {
-                tag.putShort(ENCHANTMENTS_LVL.NBT, (short) level);
-                return;
-            }
-        }
-        CompoundTag tag = new CompoundTag();
-        tag.putString(ENCHANTMENTS_ID.NBT, ench.getKey().toString());
-        tag.putShort(ENCHANTMENTS_LVL.NBT, (short) level);
-        list.add(tag);
+        // Paper start - replace entire method
+        if(!this.handle.hasTag()) return;
+        EnchantmentMap map = CraftMetaItem.buildEnchantments(this.handle.getTag(), CraftMetaItem.ENCHANTMENTS);
+        if(map == null) map = new EnchantmentMap();
+        map.put(ench, level);
+        CraftMetaItem.applyEnchantments(map, this.handle.getTag(), CraftMetaItem.ENCHANTMENTS);
+        // Paper end
     }
 
     static boolean makeTag(net.minecraft.world.item.ItemStack item) {
@@ -232,50 +250,29 @@ public final class CraftItemStack extends ItemStack {
     public int removeEnchantment(Enchantment ench) {
         Validate.notNull(ench, "Cannot remove null enchantment");
 
-        ListTag list = CraftItemStack.getEnchantmentList(this.handle), listCopy;
-        if (list == null) {
-            return 0;
-        }
-        int index = Integer.MIN_VALUE;
-        int level = Integer.MIN_VALUE;
-        int size = list.size();
-
-        for (int i = 0; i < size; i++) {
-            CompoundTag enchantment = (CompoundTag) list.get(i);
-            String id = enchantment.getString(ENCHANTMENTS_ID.NBT);
-            if (ench.getKey().equals(NamespacedKey.fromString(id))) {
-                index = i;
-                level = 0xffff & enchantment.getShort(ENCHANTMENTS_LVL.NBT);
-                break;
-            }
-        }
-
-        if (index == Integer.MIN_VALUE) {
-            return 0;
-        }
-        if (size == 1) {
-            this.handle.getTag().remove(ENCHANTMENTS.NBT);
-            if (this.handle.getTag().isEmpty()) {
-                this.handle.setTag(null);
-            }
-            return level;
-        }
+        // Paper start - replace entire method
+        if(!this.handle.hasTag()) return 0;
+        EnchantmentMap map = CraftMetaItem.buildEnchantments(this.handle.getTag(), CraftMetaItem.ENCHANTMENTS);
+        if(map == null) return 0;
 
-        // This is workaround for not having an index removal
-        listCopy = new ListTag();
-        for (int i = 0; i < size; i++) {
-            if (i != index) {
-                listCopy.add(list.get(i));
-            }
+        Integer previousLevel;
+        if((previousLevel = map.remove(ench)) != null && map.isEmpty()) {
+            map = null;
         }
-        this.handle.getTag().put(ENCHANTMENTS.NBT, listCopy);
+        CraftMetaItem.applyEnchantments(map, this.handle.getTag(), CraftMetaItem.ENCHANTMENTS);
 
-        return level;
+        return previousLevel == null ? 0 : previousLevel;
+        // Paper end
     }
 
     @Override
     public Map<Enchantment, Integer> getEnchantments() {
-        return CraftItemStack.getEnchantments(this.handle);
+        // Paper start - replace entire method
+        if(!this.handle.hasTag()) return ImmutableMap.of();
+        EnchantmentMap map = CraftMetaItem.buildEnchantments(this.handle.getTag(), CraftMetaItem.ENCHANTMENTS);
+        if(map == null) return ImmutableMap.of();
+        return com.google.common.collect.ImmutableSortedMap.copyOfSorted(map);
+        // Paper end
     }
 
     static Map<Enchantment, Integer> getEnchantments(net.minecraft.world.item.ItemStack item) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBlockState.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBlockState.java
index 3a8ff15d1c6ba21ce8bed030e84a9f85b702d72a..94b4638f296c5086198ae3e3866b8935e59c0a49 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBlockState.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBlockState.java
@@ -23,9 +23,23 @@ public class CraftMetaBlockState extends CraftMetaItem implements BlockStateMeta
     @ItemMetaKey.Specific(ItemMetaKey.Specific.To.NBT)
     static final ItemMetaKey BLOCK_ENTITY_TAG = new ItemMetaKey("BlockEntityTag");
 
-    final Material material;
+    Material material; // Paper
     CompoundTag blockEntityTag;
 
+    // Paper start
+    CraftMetaBlockState(CraftMetaItem meta) {
+        super(meta);
+
+        if (!(meta instanceof CraftMetaBlockState)) {
+            return;
+        }
+
+        CraftMetaBlockState state = (CraftMetaBlockState) meta;
+        this.material = state.material;
+        this.blockEntityTag = state.blockEntityTag.copy();
+    }
+    // Paper end
+
     CraftMetaBlockState(CraftMetaItem meta, Material material) {
         super(meta);
         this.material = material;
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
index 0a5f063bc74e1dae67167537437ebd7e4ddf113a..d3334ffb931842afe3a906bbdedd80bec60afbc8 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
@@ -6,6 +6,7 @@ import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.ImmutableSortedMap; // Paper
 import com.google.common.collect.Lists;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.SetMultimap;
@@ -23,6 +24,7 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Base64;
 import java.util.Collection;
+import java.util.Comparator; // Paper
 import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -33,6 +35,7 @@ import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.Objects;
 import java.util.Set;
+import java.util.TreeMap; // Paper
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.annotation.Nonnull;
@@ -272,7 +275,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     private List<String> lore; // null and empty are two different states internally
     private Integer customModelData;
     private CompoundTag blockData;
-    private Map<Enchantment, Integer> enchantments;
+    private EnchantmentMap enchantments; // Paper
     private Multimap<Attribute, AttributeModifier> attributeModifiers;
     private int repairCost;
     private int hideFlag;
@@ -283,7 +286,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     private static final CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new CraftPersistentDataTypeRegistry();
 
     private CompoundTag internalTag;
-    final Map<String, Tag> unhandledTags = new HashMap<String, Tag>(); // Visible for testing only
+    final Map<String, Tag> unhandledTags = new TreeMap<String, Tag>(); // Visible for testing only // Paper
     private CraftPersistentDataContainer persistentDataContainer = new CraftPersistentDataContainer(CraftMetaItem.DATA_TYPE_REGISTRY);
 
     private int version = CraftMagicNumbers.INSTANCE.getDataVersion(); // Internal use only
@@ -304,7 +307,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         this.blockData = meta.blockData;
 
         if (meta.enchantments != null) { // Spigot
-            this.enchantments = new LinkedHashMap<Enchantment, Integer>(meta.enchantments);
+            this.enchantments = new EnchantmentMap(meta.enchantments); // Paper
         }
 
         if (meta.hasAttributeModifiers()) {
@@ -387,13 +390,13 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         }
     }
 
-    static Map<Enchantment, Integer> buildEnchantments(CompoundTag tag, ItemMetaKey key) {
+    static EnchantmentMap buildEnchantments(CompoundTag tag, ItemMetaKey key) { // Paper
         if (!tag.contains(key.NBT)) {
             return null;
         }
 
         ListTag ench = tag.getList(key.NBT, CraftMagicNumbers.NBT.TAG_COMPOUND);
-        Map<Enchantment, Integer> enchantments = new LinkedHashMap<Enchantment, Integer>(ench.size());
+        EnchantmentMap enchantments = new EnchantmentMap(); // Paper
 
         for (int i = 0; i < ench.size(); i++) {
             String id = ((CompoundTag) ench.get(i)).getString(ENCHANTMENTS_ID.NBT);
@@ -546,13 +549,13 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         }
     }
 
-    static Map<Enchantment, Integer> buildEnchantments(Map<String, Object> map, ItemMetaKey key) {
+    static EnchantmentMap buildEnchantments(Map<String, Object> map, ItemMetaKey key) { // Paper
         Map<?, ?> ench = SerializableMeta.getObject(Map.class, map, key.BUKKIT, true);
         if (ench == null) {
             return null;
         }
 
-        Map<Enchantment, Integer> enchantments = new LinkedHashMap<Enchantment, Integer>(ench.size());
+        EnchantmentMap enchantments = new EnchantmentMap(); // Paper
         for (Map.Entry<?, ?> entry : ench.entrySet()) {
             // Doctor older enchants
             String enchantKey = entry.getKey().toString();
@@ -676,6 +679,11 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
 
     static void applyEnchantments(Map<Enchantment, Integer> enchantments, CompoundTag tag, ItemMetaKey key) {
         if (enchantments == null /*|| enchantments.size() == 0*/) { // Spigot - remove size check
+            // Paper start
+            if(key == CraftMetaItem.ENCHANTMENTS) {
+                tag.remove(key.NBT); // Paper delete the key when the list is empty because setItemMeta redraw the whole tag from scratch but other enchantment related methods in CraftItemStack doesn't use meta anymore
+            }
+            // Paper end
             return;
         }
 
@@ -828,14 +836,14 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
 
     @Override
     public Map<Enchantment, Integer> getEnchants() {
-        return this.hasEnchants() ? ImmutableMap.copyOf(enchantments) : ImmutableMap.<Enchantment, Integer>of();
+        return this.hasEnchants() ? ImmutableSortedMap.copyOfSorted(this.enchantments) : ImmutableMap.<Enchantment, Integer>of(); // Paper
     }
 
     @Override
     public boolean addEnchant(Enchantment ench, int level, boolean ignoreRestrictions) {
         Validate.notNull(ench, "Enchantment cannot be null");
         if (this.enchantments == null) {
-            this.enchantments = new LinkedHashMap<Enchantment, Integer>(4);
+            this.enchantments = new EnchantmentMap(); // Paper
         }
 
         if (ignoreRestrictions || level >= ench.getStartLevel() && level <= ench.getMaxLevel()) {
@@ -1223,7 +1231,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
             clone.customModelData = this.customModelData;
             clone.blockData = this.blockData;
             if (this.enchantments != null) {
-                clone.enchantments = new LinkedHashMap<Enchantment, Integer>(this.enchantments);
+                clone.enchantments = new EnchantmentMap(this.enchantments); // Paper
             }
             if (this.hasAttributeModifiers()) {
                 clone.attributeModifiers = LinkedHashMultimap.create(this.attributeModifiers);
@@ -1404,6 +1412,127 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         this.version = version;
     }
 
+    // Paper start
+    private static final CraftMetaArmorStand armorStandMeta = new CraftMetaArmorStand((CraftMetaItem) null);
+    private static final CraftMetaAxolotlBucket axolotlBucketMeta = new CraftMetaAxolotlBucket((CraftMetaItem) null);
+    private static final CraftMetaBanner bannerMeta = new CraftMetaBanner((CraftMetaItem) null);
+    private static final CraftMetaBlockState blockStateMeta = new CraftMetaBlockState((CraftMetaItem) null);
+    private static final CraftMetaBook bookMeta = new CraftMetaBook((CraftMetaItem) null);
+    private static final CraftMetaBundle bundleMeta = new CraftMetaBundle((CraftMetaItem) null);
+    private static final CraftMetaCharge chargeMeta = new CraftMetaCharge((CraftMetaItem) null);
+    private static final CraftMetaCompass compassMeta = new CraftMetaCompass((CraftMetaItem) null);
+    private static final CraftMetaCrossbow crossbowMeta = new CraftMetaCrossbow((CraftMetaItem) null);
+    private static final CraftMetaEnchantedBook enchantedBookMeta = new CraftMetaEnchantedBook((CraftMetaItem) null);
+    private static final CraftMetaEntityTag entityTagMeta = new CraftMetaEntityTag((CraftMetaItem) null);
+    private static final CraftMetaFirework fireworkMeta = new CraftMetaFirework((CraftMetaItem) null);
+    private static final CraftMetaKnowledgeBook recipeMeta = new CraftMetaKnowledgeBook((CraftMetaItem) null);
+    private static final CraftMetaLeatherArmor leatherArmorMeta = new CraftMetaLeatherArmor((CraftMetaItem) null);
+    private static final CraftMetaMap mapMeta = new CraftMetaMap((CraftMetaItem) null);
+    private static final CraftMetaPotion potionMeta = new CraftMetaPotion((CraftMetaItem) null);
+    private static final CraftMetaSkull skullMeta = new CraftMetaSkull((CraftMetaItem) null);
+    private static final CraftMetaSpawnEgg spawnEggMeta = new CraftMetaSpawnEgg((CraftMetaItem) null);
+    private static final CraftMetaSuspiciousStew stewMeta = new CraftMetaSuspiciousStew((CraftMetaItem) null);
+    private static final CraftMetaTropicalFishBucket fishBucketMeta = new CraftMetaTropicalFishBucket((CraftMetaItem) null);
+
+    public static void stripInvalidTags(Material mat, Material newMat, CompoundTag tag) {
+        if(bundleMeta.applicableTo(mat) && !bundleMeta.applicableTo(newMat)) {
+            tag.remove(bundleMeta.ITEMS.NBT);
+            return;
+        }
+        if(fishBucketMeta.applicableTo(mat) && !fishBucketMeta.applicableTo(newMat)) {
+            tag.remove(fishBucketMeta.VARIANT.NBT);
+            tag.remove(fishBucketMeta.ENTITY_TAG.NBT);
+            return;
+        }
+        if(axolotlBucketMeta.applicableTo(mat) && !axolotlBucketMeta.applicableTo(newMat)) {
+            tag.remove(axolotlBucketMeta.VARIANT.NBT);
+            tag.remove(axolotlBucketMeta.ENTITY_TAG.NBT);
+            return;
+        }
+        if(armorStandMeta.applicableTo(mat) && !armorStandMeta.applicableTo(newMat)) {
+            tag.remove(armorStandMeta.ENTITY_TAG.NBT);
+            return;
+        }
+        if(entityTagMeta.applicableTo(mat) && !entityTagMeta.applicableTo(newMat)) {
+            tag.remove(entityTagMeta.ENTITY_TAG.NBT);
+            return;
+        }
+        if(spawnEggMeta.applicableTo(mat) && !spawnEggMeta.applicableTo(newMat)) {
+            tag.remove(spawnEggMeta.ENTITY_TAG.NBT);
+            return;
+        }
+        if(bannerMeta.applicableTo(mat) && !bannerMeta.applicableTo(newMat)) {
+            tag.remove(bannerMeta.BASE.NBT);
+            tag.remove(bannerMeta.PATTERNS.NBT);
+            return;
+        }
+        if(blockStateMeta.applicableTo(mat) && !blockStateMeta.applicableTo(newMat)) {
+            tag.remove(blockStateMeta.BLOCK_ENTITY_TAG.NBT);
+            return;
+        }
+        if(bookMeta.applicableTo(mat) && !bookMeta.applicableTo(newMat)) {
+            tag.remove(bookMeta.BOOK_TITLE.NBT);
+            tag.remove(bookMeta.BOOK_AUTHOR.NBT);
+            tag.remove(bookMeta.BOOK_PAGES.NBT);
+            tag.remove(bookMeta.RESOLVED.NBT);
+            tag.remove(bookMeta.GENERATION.NBT);
+            return;
+        }
+        if(chargeMeta.applicableTo(mat) && !chargeMeta.applicableTo(newMat)) {
+            tag.remove(chargeMeta.EXPLOSION.NBT);
+            return;
+        }
+        if(compassMeta.applicableTo(mat) && !compassMeta.applicableTo(newMat)) {
+            tag.remove(compassMeta.LODESTONE_DIMENSION.NBT);
+            tag.remove(compassMeta.LODESTONE_POS.NBT);
+            tag.remove(compassMeta.LODESTONE_POS_WORLD.NBT);
+            tag.remove(compassMeta.LODESTONE_TRACKED.NBT);
+            return;
+        }
+        if(crossbowMeta.applicableTo(mat) && !crossbowMeta.applicableTo(newMat)) {
+            tag.remove(crossbowMeta.CHARGED.NBT);
+            tag.remove(crossbowMeta.CHARGED_PROJECTILES.NBT);
+            return;
+        }
+        if(enchantedBookMeta.applicableTo(mat) && !enchantedBookMeta.applicableTo(newMat)) {
+            tag.remove(enchantedBookMeta.STORED_ENCHANTMENTS.NBT);
+            return;
+        }
+        if(fireworkMeta.applicableTo(mat) && !fireworkMeta.applicableTo(newMat)) {
+            tag.remove(fireworkMeta.FIREWORKS.NBT);
+            return;
+        }
+        if(recipeMeta.applicableTo(mat) && !recipeMeta.applicableTo(newMat)) {
+            tag.remove(recipeMeta.BOOK_RECIPES.NBT);
+            return;
+        }
+        if(leatherArmorMeta.applicableTo(mat) && !leatherArmorMeta.applicableTo(newMat)) {
+            tag.remove(leatherArmorMeta.DISPLAY.NBT);
+            return;
+        }
+        if(mapMeta.applicableTo(mat) && !mapMeta.applicableTo(newMat)) {
+            tag.remove(mapMeta.MAP_SCALING.NBT);
+            tag.remove(mapMeta.DISPLAY.NBT);
+            tag.remove(mapMeta.MAP_ID.NBT);
+            return;
+        }
+        if(potionMeta.applicableTo(mat) && !potionMeta.applicableTo(newMat)) {
+            tag.remove(potionMeta.DEFAULT_POTION.NBT);
+            tag.remove(potionMeta.POTION_COLOR.NBT);
+            tag.remove(potionMeta.POTION_EFFECTS.NBT);
+            return;
+        }
+        if(skullMeta.applicableTo(mat) && !skullMeta.applicableTo(newMat)) {
+            tag.remove(skullMeta.SKULL_OWNER.NBT);
+            return;
+        }
+        if(stewMeta.applicableTo(mat) && !stewMeta.applicableTo(newMat)) {
+            tag.remove(stewMeta.EFFECTS.NBT);
+            return;
+        }
+    }
+    // Paper end
+
     public static Set<String> getHandledTags() {
         synchronized (CraftMetaItem.HANDLED_TAGS) {
             if (CraftMetaItem.HANDLED_TAGS.isEmpty()) {
@@ -1458,4 +1587,22 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
             return CraftMetaItem.HANDLED_TAGS;
         }
     }
+
+    // Paper start
+    public static class EnchantmentMap extends TreeMap<Enchantment, Integer> {
+        private EnchantmentMap(Map<Enchantment, Integer> enchantments) {
+            this();
+            putAll(enchantments);
+        }
+
+        protected EnchantmentMap() {
+            super(Comparator.comparing(o -> o.getKey().toString()));
+        }
+
+        public EnchantmentMap clone() {
+            return (EnchantmentMap) super.clone();
+        }
+    }
+    // Paper end
+
 }
