From de9891edbb2d499223c574e843feb2e6287921fa Mon Sep 17 00:00:00 2001
From: Techcable <Techcable@outlook.com>
Date: Fri, 4 Mar 2016 20:54:31 -0700
Subject: [PATCH] Use arrays instead of map in the DataWatcher

The ids never exceed 16, so there is no memory benefit for using maps.
Arrays are much, much faster, and require no locking.

diff --git a/src/main/java/net/minecraft/server/DataWatcher.java b/src/main/java/net/minecraft/server/DataWatcher.java
index 26bec1c..9e2fca5 100644
--- a/src/main/java/net/minecraft/server/DataWatcher.java
+++ b/src/main/java/net/minecraft/server/DataWatcher.java
@@ -5,20 +5,138 @@ import com.google.common.collect.Maps;
 import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.EncoderException;
 import java.io.IOException;
+import java.util.AbstractSet;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Set;
 import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 import org.apache.commons.lang3.ObjectUtils;
+import org.apache.commons.lang3.tuple.Pair;
+// Paper start
+import java.util.AbstractMap;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.atomic.AtomicReferenceArray;
+import java.util.concurrent.locks.Lock;
+// Paper end
 
 public class DataWatcher {
 
     private static final Map<Class<? extends Entity>, Integer> a = Maps.newHashMap();
     private final Entity b;
-    private final Map<Integer, DataWatcher.Item<?>> c = Maps.newHashMap();
-    private final ReadWriteLock d = new ReentrantReadWriteLock();
+    // Paper start - start Map -> array start
+    private final AtomicReferenceArray<DataWatcher.Item> data = new AtomicReferenceArray<>(16);
+    private final Map<Integer, DataWatcher.Item<?>> c = new AbstractMap<Integer, Item<?>>() {
+        private int size;
+        @Override
+        public int size() {
+            return size;
+        }
+
+        @Override
+        public boolean containsKey(Object key) {
+            return data.get((Integer) key) != null;
+        }
+
+        @Override
+        public Item<?> get(Object key) {
+            return data.get((Integer) key);
+        }
+
+        @Override
+        public Item<?> put(final Integer key, final Item<?> value) {
+            if (value == null) throw new NullPointerException("Null value");
+            Item<?> previous = data.getAndSet(key, value);
+            if (previous == null) size++;
+            return previous;
+        }
+
+        @Override
+        public Item<?> remove(Object key) {
+            Item<?> previous = data.getAndSet((Integer) key, null);
+            if (previous != null) size--;
+            return previous;
+        }
+        @Override
+        public Set<Entry<Integer, Item<?>>> entrySet() {
+            return new AbstractSet<Entry<Integer, Item<?>>>() {
+                @Override
+                public Iterator<Entry<Integer, Item<?>>> iterator() {
+                    return new Iterator<Entry<Integer, Item<?>>>() {
+                        int index = 0;
+
+                        @Override
+                        public boolean hasNext() {
+                            while (index < data.length()) {
+                                if (data.get(index) == null) {
+                                    index++;
+                                } else {
+                                    return true;
+                                }
+                            }
+                            return false;
+                        }
+
+                        @Override
+                        public Entry<Integer, Item<?>> next() {
+                            if (!hasNext()) throw new NoSuchElementException();
+                            int i = index++;
+                            return Pair.of(i, data.get(i));
+                        }
+                    };
+                }
+
+                @Override
+                public int size() {
+                    return size();
+                }
+            };
+        }
+    };
+    // Paper end
+    // Paper start - no lock
+    private static Lock NO_OP_LOCK = new Lock() {
+        @Override
+        public void lock() {}
+
+        @Override
+        public void lockInterruptibly() throws InterruptedException {}
+
+        @Override
+        public boolean tryLock() {
+            return true;
+        }
+
+        @Override
+        public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
+            return true;
+        }
+
+        @Override
+        public void unlock() {}
+
+        @Override
+        public Condition newCondition() {
+            throw new UnsupportedOperationException();
+        }
+    };
+    private static final ReadWriteLock d = new ReadWriteLock() {
+        @Override
+        public Lock readLock() {
+            return NO_OP_LOCK;
+        }
+
+        @Override
+        public Lock writeLock() {
+            return NO_OP_LOCK;
+        }
+    };
+    // Paper end
     private boolean e = true;
     private boolean f;
 
-- 
2.7.1

