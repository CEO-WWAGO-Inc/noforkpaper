From 23eabf124cb55d3a749de70a39ca49830d700527 Mon Sep 17 00:00:00 2001
From: kickash32 <kickash32@gmail.com>
Date: Mon, 19 Aug 2019 01:27:58 +0500
Subject: [PATCH] implement optional per player mob spawns


diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index 9d9260ad0..fd3dbea62 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -613,4 +613,9 @@ public class PaperWorldConfig {
             }
         }
     }
+
+    public boolean perPlayerMobSpawns = false;
+    private void perPlayerMobSpawns() {
+        perPlayerMobSpawns = getBoolean("per-player-mob-spawns", false);
+    }
 }
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 81d386b4c..7769ced82 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -654,7 +654,26 @@ public class ChunkProviderServer extends IChunkProvider {
             this.world.timings.countNaturalMobs.startTiming(); // Paper - timings
             int l = this.chunkMapDistance.b();
             EnumCreatureType[] aenumcreaturetype = EnumCreatureType.values();
-            Object2IntMap<EnumCreatureType> object2intmap = this.world.l();
+            // Paper start - per player mob spawning
+            int[] worldMobCount;
+            if (this.playerChunkMap.playerMobDistanceMap != null) {
+                // update distance map
+                for (EntityPlayer player : this.world.players) {
+                    if (!player.affectsSpawning || player.isSpectator()) {
+                        this.playerChunkMap.playerMobDistanceMap.remove(player);
+                    } else {
+                        this.playerChunkMap.playerMobDistanceMap.update(player, MCUtil.getChunkCoordinate(player.locX()), MCUtil.getChunkCoordinate(player.locZ()), this.playerChunkMap.viewDistance);
+                    }
+                }
+                // re-set mob counts
+                for (EntityPlayer player : this.world.players) {
+                    Arrays.fill(player.mobCounts, 0);
+                }
+                worldMobCount = this.world.countMobs(true);
+            } else {
+                worldMobCount = this.world.countMobs(false);
+            }
+            // Paper end
 
             this.world.timings.countNaturalMobs.stopTiming(); // Paper - timings
             this.world.getMethodProfiler().exit();
@@ -719,8 +738,32 @@ public class ChunkProviderServer extends IChunkProvider {
                                 if (enumcreaturetype != EnumCreatureType.MISC && (!enumcreaturetype.c() || this.allowAnimals) && (enumcreaturetype.c() || this.allowMonsters) && (!enumcreaturetype.d() || flag2)) {
                                     int k1 = limit * l / ChunkProviderServer.b; // CraftBukkit - use per-world limits
 
-                                    if (object2intmap.getInt(enumcreaturetype) <= k1) {
-                                        SpawnerCreature.a(enumcreaturetype, this.world, chunk, blockposition);
+                                    // Paper start - only allow spawns upto the limit per chunk and update count afterwards
+                                    int currEntityCount = worldMobCount[enumcreaturetype.ordinal()];
+                                    int difference = k1 - currEntityCount;
+
+                                    if (this.playerChunkMap.playerMobDistanceMap != null) {
+                                        int minDiff = Integer.MAX_VALUE;
+                                        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> players = this.playerChunkMap.playerMobDistanceMap.getObjectsInRange(chunk.getPos());
+                                        if (players != null) {
+                                            Object[] backingSet = players.getBackingSet();
+                                            for (int index = 0, len = backingSet.length; index < len; ++index) {
+                                                Object temp = backingSet[index];
+                                                if (!(temp instanceof EntityPlayer)) {
+                                                    continue;
+                                                }
+                                                EntityPlayer entityplayer = (EntityPlayer)temp;
+                                                minDiff = Math.min(limit - this.playerChunkMap.getMobCountNear(entityplayer, enumcreaturetype), minDiff);
+                                            }
+                                        }
+                                        difference = (minDiff == Integer.MAX_VALUE) ? 0 : minDiff;
+                                    }
+
+                                    if (difference > 0) {
+                                        int spawnCount = SpawnerCreature.spawnMobs(enumcreaturetype, this.world, chunk, blockposition, difference,
+                                            this.world.paperConfig.perPlayerMobSpawns ? this.playerChunkMap::updatePlayerMobTypeMap : null);
+                                        worldMobCount[enumcreaturetype.ordinal()] += spawnCount;
+                                        // Paper end
                                     }
                                 }
                             }
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 77ad4774e..0546b2827 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -80,6 +80,10 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public boolean queueHealthUpdatePacket = false;
     public net.minecraft.server.PacketPlayOutUpdateHealth queuedHealthUpdatePacket;
     // Paper end
+    // Paper start - mob spawning rework
+    public static final int ENUMCREATURETYPE_TOTAL_ENUMS = EnumCreatureType.values().length;
+    public final int[] mobCounts = new int[ENUMCREATURETYPE_TOTAL_ENUMS]; // Paper
+    // Paper end
 
     // CraftBukkit start
     public String displayName;
@@ -1769,6 +1773,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
 
     }
 
+    public SectionPosition getPlayerMapSection() { return this.K(); } // Paper - OBFHELPER
     public SectionPosition K() {
         return this.cs;
     }
diff --git a/src/main/java/net/minecraft/server/EntityTypes.java b/src/main/java/net/minecraft/server/EntityTypes.java
index 79f854966..4100e367a 100644
--- a/src/main/java/net/minecraft/server/EntityTypes.java
+++ b/src/main/java/net/minecraft/server/EntityTypes.java
@@ -254,6 +254,7 @@ public class EntityTypes<T extends Entity> {
         return this.bf;
     }
 
+    public EnumCreatureType getEnumCreatureType() { return this.e(); } // Paper - OBFHELPER
     public EnumCreatureType e() {
         return this.bb;
     }
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 85b21012e..cf32abf12 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -78,7 +78,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     private final PlayerMap playerMap;
     public final Int2ObjectMap<PlayerChunkMap.EntityTracker> trackedEntities;
     private final Queue<Runnable> z;
-    private int viewDistance;
+    int viewDistance; // Paper - private -> package private
 
     // CraftBukkit start - recursion-safe executor for Chunk loadCallback() and unloadCallback()
     public final CallbackExecutor callbackExecutor = new CallbackExecutor();
@@ -108,6 +108,10 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     // Paper start - distance maps
     private final com.destroystokyo.paper.util.misc.PooledLinkedHashSets<EntityPlayer> pooledLinkedPlayerHashSets = new com.destroystokyo.paper.util.misc.PooledLinkedHashSets<>();
 
+    // Paper start - per player mob spawning
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobDistanceMap; // Paper // Note: This map is mostly managed in ChunkProviderServer#tickChunks
+    // Paper end - per player mob spawning
+
     void addPlayerToDistanceMaps(EntityPlayer player) {
         this.updateMaps(player);
 
@@ -116,6 +120,9 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     void removePlayerFromDistanceMaps(EntityPlayer player) {
+        // Paper start - per player mob spawning
+        this.playerMobDistanceMap.remove(player);
+        // Paper end - per player mob spawning
 
 
 
@@ -165,6 +172,35 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         this.l = supplier;
         this.m = new VillagePlace(new File(this.w, "poi"), datafixer, this.world); // Paper
         this.setViewDistance(i);
+        // Paper start - per player mob spawning
+        this.playerMobDistanceMap = this.world.paperConfig.perPlayerMobSpawns ? new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets) : null;
+        // Paper end
+    }
+
+    public void updatePlayerMobTypeMap(Entity entity) {
+        if (!this.world.paperConfig.perPlayerMobSpawns) {
+            return;
+        }
+        int chunkX = MCUtil.getChunkCoordinate(entity.locX());
+        int chunkZ = MCUtil.getChunkCoordinate(entity.locZ());
+        int index = entity.getEntityType().getEnumCreatureType().ordinal();
+
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> players = this.playerMobDistanceMap.getObjectsInRange(chunkX, chunkZ);
+        if (players != null) {
+            Object[] backingSet = players.getBackingSet();
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof EntityPlayer)) {
+                    continue;
+                }
+                EntityPlayer player = (EntityPlayer)temp;
+                ++player.mobCounts[index];
+            }
+        }
+    }
+
+    public int getMobCountNear(EntityPlayer entityPlayer, EnumCreatureType enumCreatureType) {
+        return entityPlayer.mobCounts[enumCreatureType.ordinal()];
     }
 
     private static double a(ChunkCoordIntPair chunkcoordintpair, Entity entity) {
diff --git a/src/main/java/net/minecraft/server/SpawnerCreature.java b/src/main/java/net/minecraft/server/SpawnerCreature.java
index fdac5bb3a..58bbf2f9d 100644
--- a/src/main/java/net/minecraft/server/SpawnerCreature.java
+++ b/src/main/java/net/minecraft/server/SpawnerCreature.java
@@ -3,6 +3,7 @@ package net.minecraft.server;
 import java.util.List;
 import java.util.Objects;
 import java.util.Random;
+import java.util.function.Consumer; // Paper
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -16,9 +17,14 @@ public final class SpawnerCreature {
 
     private static final Logger LOGGER = LogManager.getLogger();
 
+    // Paper start - add maxSpawns parameter and return spawned mobs
     public static void a(EnumCreatureType enumcreaturetype, WorldServer worldserver, Chunk chunk, BlockPosition blockposition) {
+        spawnMobs(enumcreaturetype, worldserver, chunk, blockposition, Integer.MAX_VALUE, null);
+    }
+    public static int spawnMobs(EnumCreatureType enumcreaturetype, WorldServer worldserver, Chunk chunk, BlockPosition blockposition, int maxSpawns, Consumer<Entity> trackEntity) {
+        // Paper end
         ChunkGenerator<?> chunkgenerator = worldserver.getChunkProvider().getChunkGenerator();
-        int i = 0;
+        int i = 0; // Paper - force diff on name change
         BlockPosition blockposition1 = getRandomPosition(worldserver, chunk);
         int j = blockposition1.getX();
         int k = blockposition1.getY();
@@ -88,7 +94,7 @@ public final class SpawnerCreature {
                                                         );
                                                         if (!event.callEvent()) {
                                                             if (event.shouldAbortSpawn()) {
-                                                                return;
+                                                                return i; // Paper
                                                             }
                                                             ++i2;
                                                             continue;
@@ -107,7 +113,7 @@ public final class SpawnerCreature {
                                                         } catch (Exception exception) {
                                                             SpawnerCreature.LOGGER.warn("Failed to create mob", exception);
                                                             ServerInternalException.reportInternalException(exception); // Paper
-                                                            return;
+                                                            return i; // Paper
                                                         }
 
                                                         entityinsentient.setPositionRotation((double) f, (double) k, (double) f1, worldserver.random.nextFloat() * 360.0F, 0.0F);
@@ -115,12 +121,16 @@ public final class SpawnerCreature {
                                                             groupdataentity = entityinsentient.prepare(worldserver, worldserver.getDamageScaler(new BlockPosition(entityinsentient)), EnumMobSpawn.NATURAL, groupdataentity, (NBTTagCompound) null);
                                                             // CraftBukkit start
                                                             if (worldserver.addEntity(entityinsentient, SpawnReason.NATURAL)) {
-                                                                ++i;
+                                                                ++i; // Paper - force diff on name change
                                                                 ++i2;
+                                                                if (trackEntity != null) {
+                                                                    trackEntity.accept(entityinsentient); // Paper
+                                                                }
                                                             }
+                                                            if (i >= maxSpawns) { return i; } // Paper
                                                             // CraftBukkit end
                                                             if (i >= entityinsentient.getMaxSpawnGroup()) {
-                                                                return;
+                                                                return i; // Paper
                                                             }
 
                                                             if (entityinsentient.c(i2)) {
@@ -146,6 +156,7 @@ public final class SpawnerCreature {
 
             }
         }
+        return i; // Paper
     }
 
     @Nullable
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index edffae055..88cc8763f 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -1024,7 +1024,20 @@ public class WorldServer extends World {
     }
 
     public Object2IntMap<EnumCreatureType> l() {
-        Object2IntMap<EnumCreatureType> object2intmap = new Object2IntOpenHashMap();
+        // Paper start
+        int[] values = this.countMobs(false);
+        EnumCreatureType[] byId = EnumCreatureType.values();
+        Object2IntMap<EnumCreatureType> ret = new Object2IntOpenHashMap<>();
+
+        for (int i = 0, len = values.length; i < len; ++i) {
+            ret.put(byId[i], values[i]);
+        }
+
+        return ret;
+    }
+    public int[] countMobs(boolean updatePlayerCounts) {
+        int[] ret = new int[EntityPlayer.ENUMCREATURETYPE_TOTAL_ENUMS];
+        // Paper end
         ObjectIterator objectiterator = this.entitiesById.values().iterator();
 
         while (objectiterator.hasNext()) {
@@ -1049,11 +1062,16 @@ public class WorldServer extends World {
                     continue;
                 }
                 // Paper end
-                object2intmap.mergeInt(enumcreaturetype, 1, Integer::sum);
+                // Paper start - rework mob spawning
+                if (updatePlayerCounts) {
+                    this.getChunkProvider().playerChunkMap.updatePlayerMobTypeMap(entity);
+                }
+                ++ret[enumcreaturetype.ordinal()];
+                // Paper end
             }
         }
 
-        return object2intmap;
+        return ret;
     }
 
     @Override
-- 
2.25.0

