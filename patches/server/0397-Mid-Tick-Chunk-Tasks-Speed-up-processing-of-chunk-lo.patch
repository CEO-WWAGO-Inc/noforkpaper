From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Thu, 9 Apr 2020 00:09:26 -0400
Subject: [PATCH] Mid Tick Chunk Tasks - Speed up processing of chunk loads and
 generation

Credit to Spotted for the idea

A lot of the new chunk system requires constant back and forth the main thread
to handle priority scheduling and ensuring conflicting tasks do not run at the
same time.

The issue is, these queues are only checked at either:

A) Sync Chunk Loads
B) End of Tick while sleeping

This results in generating chunks sitting waiting for a full tick to
complete before it will even start the next unit of work to do.

Additionally, this also delays loading of chunks until this same timing.

We will now periodically poll the chunk task queues throughout the tick,
looking for work to do.
We do this in a fair method that considers all worlds, not just the one being
ticked, so that each world can get 1 task procesed each before the next pass.

In a view distance of 15, chunk loading performance was visually faster on the client.

Flying at high speed in spectator mode was able to keep up with chunk loading (as long as they are already generated)

diff --git a/src/main/java/co/aikar/timings/MinecraftTimings.java b/src/main/java/co/aikar/timings/MinecraftTimings.java
index b47b7dce26805badd422c1867733ff4bfd00e9f4..b9cdbf8acccfd6b207a0116f068168f3b8c8e17d 100644
--- a/src/main/java/co/aikar/timings/MinecraftTimings.java
+++ b/src/main/java/co/aikar/timings/MinecraftTimings.java
@@ -16,6 +16,7 @@ import java.util.Map;
 public final class MinecraftTimings {
 
     public static final Timing serverOversleep = Timings.ofSafe("Server Oversleep");
+    public static final Timing midTickChunkTasks = Timings.ofSafe("Mid Tick Chunk Tasks");
     public static final Timing playerListTimer = Timings.ofSafe("Player List");
     public static final Timing commandFunctionsTimer = Timings.ofSafe("Command Functions");
     public static final Timing connectionTimer = Timings.ofSafe("Connection Handler");
diff --git a/src/main/java/com/destroystokyo/paper/PaperConfig.java b/src/main/java/com/destroystokyo/paper/PaperConfig.java
index 86e16e39a9a996669989d990b76f69116bcee300..529df264d3f12112517462a6827f825e8d3afcc0 100644
--- a/src/main/java/com/destroystokyo/paper/PaperConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperConfig.java
@@ -432,4 +432,9 @@ public class PaperConfig {
             log("Async Chunks: Enabled - Chunks will be loaded much faster, without lag.");
         }
     }
+
+    public static int midTickChunkTasks = 1000;
+    private static void midTickChunkTasks() {
+        midTickChunkTasks = getInt("settings.chunk-tasks-per-tick", midTickChunkTasks);
+    }
 }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 273774ad46b993212a0cd4cfa81f0e02807c442e..e74a761992377a06917aa50d5dd1ee8b17e8c5b5 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1137,6 +1137,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                         // Paper end
                         tickSection = curTime;
                     }
+                    midTickChunksTasksRan = 0; // Paper
                     // Spigot end
 
                     if (this.debugCommandProfilerDelayStart) {
@@ -1211,7 +1212,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     }
 
-    private boolean haveTime() {
+    public boolean haveTime() { // Paper
         // CraftBukkit start
         if (isOversleep) return canOversleep();// Paper - because of our changes, this logic is broken
         return this.forceTicks || this.runningTask() || Util.getMillis() < (this.mayHaveDelayedTasks ? this.delayedTasksMaxNextTickTime : this.nextTickTime);
@@ -1241,6 +1242,23 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         });
     }
 
+    // Paper start
+    public int midTickChunksTasksRan = 0;
+    private long midTickLastRan = 0;
+    public void midTickLoadChunks() {
+        if (!isSameThread() || System.nanoTime() - midTickLastRan < 1000000) {
+            // only check once per 0.25ms incase this code is called in a hot method
+            return;
+        }
+        try (co.aikar.timings.Timing ignored = co.aikar.timings.MinecraftTimings.midTickChunkTasks.startTiming()) {
+            for (ServerLevel value : this.getAllLevels()) {
+                value.getChunkSource().mainThreadProcessor.midTickLoadChunks();
+            }
+            midTickLastRan = System.nanoTime();
+        }
+    }
+    // Paper end
+
     @Override
     public TickTask wrapRunnable(Runnable runnable) {
         return new TickTask(this.tickCount, runnable);
@@ -1330,6 +1348,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // Paper start - move oversleep into full server tick
         isOversleep = true;MinecraftTimings.serverOversleep.startTiming();
         this.managedBlock(() -> {
+            midTickLoadChunks(); // will only do loads since we are still considered !canSleepForTick
             return !this.canOversleep();
         });
         isOversleep = false;MinecraftTimings.serverOversleep.stopTiming();
@@ -1399,13 +1418,16 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public void tickChildren(BooleanSupplier shouldKeepTicking) {
+        midTickLoadChunks(); // Paper
         MinecraftTimings.bukkitSchedulerTimer.startTiming(); // Spigot // Paper
         this.server.getScheduler().mainThreadHeartbeat(this.tickCount); // CraftBukkit
         MinecraftTimings.bukkitSchedulerTimer.stopTiming(); // Spigot // Paper
+        midTickLoadChunks(); // Paper
         this.profiler.push("commandFunctions");
         MinecraftTimings.commandFunctionsTimer.startTiming(); // Spigot // Paper
         this.getFunctions().tick();
         MinecraftTimings.commandFunctionsTimer.stopTiming(); // Spigot // Paper
+        midTickLoadChunks(); // Paper
         this.profiler.popPush("levels");
         Iterator iterator = this.getAllLevels().iterator();
 
@@ -1416,7 +1438,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             this.processQueue.remove().run();
         }
         MinecraftTimings.processQueueTimer.stopTiming(); // Spigot
-
+        midTickLoadChunks(); // Paper
         MinecraftTimings.timeUpdateTimer.startTiming(); // Spigot // Paper
         // Send time updates to everyone, it will get the right time from the world the player is in.
         // Paper start - optimize time updates
@@ -1458,6 +1480,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             this.profiler.push("tick");
 
             try {
+                midTickLoadChunks(); // Paper
                 worldserver.timings.doTick.startTiming(); // Spigot
                 worldserver.tick(shouldKeepTicking);
                 // Paper start
@@ -1466,6 +1489,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 }
                 // Paper end
                 worldserver.timings.doTick.stopTiming(); // Spigot
+                midTickLoadChunks(); // Paper
             } catch (Throwable throwable) {
                 // Spigot Start
                 CrashReport crashreport;
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 9daf2b6268623aa68d2fdb7d64528d8fd66f392c..018a29dfa6989fbc74124bc5a714f3134b2438e7 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -868,6 +868,7 @@ public class ServerChunkCache extends ChunkSource {
         this.level.getProfiler().push("purge");
         this.level.timings.doChunkMap.startTiming(); // Spigot
         this.distanceManager.purgeStaleTickets();
+        this.level.getServer().midTickLoadChunks(); // Paper
         this.runDistanceManagerUpdates();
         this.level.timings.doChunkMap.stopTiming(); // Spigot
         this.level.getProfiler().popPush("chunks");
@@ -877,6 +878,7 @@ public class ServerChunkCache extends ChunkSource {
         this.level.timings.doChunkUnload.startTiming(); // Spigot
         this.level.getProfiler().popPush("unload");
         this.chunkMap.tick(booleansupplier);
+        this.level.getServer().midTickLoadChunks(); // Paper
         this.level.timings.doChunkUnload.stopTiming(); // Spigot
         this.level.getProfiler().pop();
         this.clearCache();
@@ -932,6 +934,7 @@ public class ServerChunkCache extends ChunkSource {
             };
             // Paper end
             this.level.timings.chunkTicks.startTiming(); // Paper
+            final int[] chunksTicked = {0}; // Paper
             list.forEach((playerchunk) -> {
                 Optional<LevelChunk> optional = ((Either) playerchunk.getTickingChunkFuture().getNow(ChunkHolder.UNLOADED_LEVEL_CHUNK)).left();
 
@@ -943,6 +946,7 @@ public class ServerChunkCache extends ChunkSource {
                         chunk.setInhabitedTime(chunk.getInhabitedTime() + j);
                         if (flag1 && (this.spawnEnemies || this.spawnFriendlies) && this.level.getWorldBorder().isWithinBounds(chunk.getPos()) && !this.chunkMap.isOutsideOfRange(chunkcoordintpair, true)) { // Spigot
                             NaturalSpawner.spawnForChunk(this.level, chunk, spawnercreature_d, this.spawnFriendlies, this.spawnEnemies, flag2);
+                            if (chunksTicked[0]++ % 10 == 0) this.level.getServer().midTickLoadChunks(); // Paper
                         }
 
                         // this.level.timings.doTickTiles.startTiming(); // Spigot // Paper
@@ -960,7 +964,7 @@ public class ServerChunkCache extends ChunkSource {
             }
 
             this.level.getProfiler().popPush("broadcast");
-            this.chunkMap.getChunks().forEach((playerchunk) -> { // Paper - no... just no...
+            this.chunkMap.forEachVisibleChunk((playerchunk) -> { // Paper - safe iterator incase chunk loads, also no wrapping
                 Optional<LevelChunk> optional = ((Either) playerchunk.getTickingChunkFuture().getNow(ChunkHolder.UNLOADED_LEVEL_CHUNK)).left(); // CraftBukkit - decompile error
 
                 Objects.requireNonNull(playerchunk);
@@ -1124,6 +1128,41 @@ public class ServerChunkCache extends ChunkSource {
             super.doRunTask(task);
         }
 
+        // Paper start
+        private long lastMidTickChunkTask = 0;
+        public boolean pollChunkLoadTasks() {
+            if (com.destroystokyo.paper.io.chunk.ChunkTaskManager.pollChunkWaitQueue() || ServerChunkCache.this.level.asyncChunkTaskManager.pollNextChunkTask()) {
+                try {
+                    ServerChunkCache.this.runDistanceManagerUpdates();
+                } finally {
+                    // from below: process pending Chunk loadCallback() and unloadCallback() after each run task
+                    chunkMap.callbackExecutor.run();
+                }
+                return true;
+            }
+            return false;
+        }
+        public void midTickLoadChunks() {
+            net.minecraft.server.MinecraftServer server = ServerChunkCache.this.level.getServer();
+            // always try to load chunks, restrain generation/other updates only. don't count these towards tick count
+            //noinspection StatementWithEmptyBody
+            while (pollChunkLoadTasks()) {}
+
+            if (System.nanoTime() - lastMidTickChunkTask < 200000) {
+                return;
+            }
+
+            for (;server.midTickChunksTasksRan < com.destroystokyo.paper.PaperConfig.midTickChunkTasks && server.haveTime();) {
+                if (this.pollTask()) {
+                    server.midTickChunksTasksRan++;
+                    lastMidTickChunkTask = System.nanoTime();
+                } else {
+                    break;
+                }
+            }
+        }
+        // Paper end
+
         @Override
         // CraftBukkit start - process pending Chunk loadCallback() and unloadCallback() after each run task
         public boolean pollTask() {
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index f3ba3c430a713fdef7e941b991ea8497de2e6a05..b3b459b548d1a133657334ce8452e163406b27ef 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -634,6 +634,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         }
         timings.scheduledBlocks.stopTiming(); // Paper
 
+        this.getServer().midTickLoadChunks(); // Paper
         gameprofilerfiller.popPush("raid");
         this.timings.raids.startTiming(); // Paper - timings
         this.raids.tick();
@@ -646,6 +647,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         timings.doSounds.startTiming(); // Spigot
         this.runBlockEvents();
         timings.doSounds.stopTiming(); // Spigot
+        this.getServer().midTickLoadChunks(); // Paper
         this.handlingTick = false;
         gameprofilerfiller.pop();
         boolean flag3 = true || !this.players.isEmpty() || !this.getForcedChunks().isEmpty(); // CraftBukkit - this prevents entity cleanup, other issues on servers with no players
@@ -692,10 +694,12 @@ public class ServerLevel extends Level implements WorldGenLevel {
             timings.entityTick.stopTiming(); // Spigot
             timings.tickEntities.stopTiming(); // Spigot
             gameprofilerfiller.pop();
+            this.getServer().midTickLoadChunks(); // Paper
             this.tickBlockEntities();
         }
 
         gameprofilerfiller.push("entityManagement");
+        this.getServer().midTickLoadChunks(); // Paper
         this.entityManager.tick();
         gameprofilerfiller.pop();
     }
