From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: dfsek <dfsek@protonmail.com>
Date: Wed, 16 Sep 2020 01:12:29 -0700
Subject: [PATCH] Add StructureLocateEvent


diff --git a/src/main/java/io/papermc/paper/PaperRegistry.java b/src/main/java/io/papermc/paper/PaperRegistry.java
new file mode 100644
index 0000000000000000000000000000000000000000..87a3f9b851b4bfcdac4e32c8781c3759c567a772
--- /dev/null
+++ b/src/main/java/io/papermc/paper/PaperRegistry.java
@@ -0,0 +1,69 @@
+package io.papermc.paper;
+
+import com.google.common.base.Suppliers;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Keyed;
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import java.util.function.Supplier;
+
+@DefaultQualifier(NonNull.class)
+public abstract class PaperRegistry<API extends Keyed, MINECRAFT> implements org.bukkit.Registry<API> {
+
+    private static final Set<PaperRegistry<?, ?>> REGISTRIES = new HashSet<>();
+
+    private final ResourceKey<? extends Registry<MINECRAFT>> registryKey;
+    private final Supplier<Registry<MINECRAFT>> registry;
+    private final Map<NamespacedKey, API> cache = new HashMap<>();
+
+    public PaperRegistry(ResourceKey<? extends Registry<MINECRAFT>> registryKey) {
+        this.registryKey = registryKey;
+        this.registry = Suppliers.memoize(() -> MinecraftServer.getServer().registryAccess().registryOrThrow(this.registryKey));
+        if (!REGISTRIES.add(this)) {
+            throw new IllegalStateException("duplicate registry");
+        }
+    }
+
+    @Override
+    public @Nullable API get(NamespacedKey key) {
+        return this.cache.computeIfAbsent(key, k -> {
+            final @Nullable MINECRAFT nms = this.registry.get().get(CraftNamespacedKey.toMinecraft(k));
+            if (nms != null) {
+                return this.convertToApi(k, nms);
+            }
+            return null;
+        });
+    }
+
+    public abstract API convertToApi(NamespacedKey key, MINECRAFT nms);
+
+    @Override
+    public Iterator<API> iterator() {
+        return this.registry.get().keySet().stream().map(key -> this.get(CraftNamespacedKey.fromMinecraft(key))).iterator();
+    }
+
+    @Override
+    public boolean equals(@Nullable Object o) {
+        if (this == o) return true;
+        if (o == null || !PaperRegistry.class.isAssignableFrom(o.getClass())) return false;
+        PaperRegistry<?, ?> that = (PaperRegistry<?, ?>) o;
+        return this.registryKey.equals(that.registryKey);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(this.registryKey);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/world/structure/PaperConfiguredStructure.java b/src/main/java/io/papermc/paper/world/structure/PaperConfiguredStructure.java
new file mode 100644
index 0000000000000000000000000000000000000000..fae5c4427fa1070916fe423000aa32498ba689a4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/world/structure/PaperConfiguredStructure.java
@@ -0,0 +1,36 @@
+package io.papermc.paper.world.structure;
+
+import com.google.common.base.Preconditions;
+import com.google.common.base.Suppliers;
+import io.papermc.paper.PaperRegistry;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.level.levelgen.feature.ConfiguredStructureFeature;
+import net.minecraft.world.level.levelgen.feature.StructureFeature;
+import org.bukkit.NamespacedKey;
+import org.bukkit.StructureType;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.util.Objects;
+import java.util.function.Supplier;
+
+@DefaultQualifier(NonNull.class)
+public final class PaperConfiguredStructure {
+
+    public static void init() {
+        Preconditions.checkState(ConfiguredStructure.REGISTRY == null);
+        ConfiguredStructure.REGISTRY = new PaperRegistry<>(Registry.CONFIGURED_STRUCTURE_FEATURE_REGISTRY) {
+
+            private static final Supplier<Registry<StructureFeature<?>>> STRUCTURE_FEATURE_REGISTRY = Suppliers.memoize(() -> MinecraftServer.getServer().registryAccess().registryOrThrow(Registry.STRUCTURE_FEATURE_REGISTRY));
+
+            @Override
+            public ConfiguredStructure convertToApi(NamespacedKey key, ConfiguredStructureFeature<?, ?> nms) {
+                final ResourceLocation structureFeatureLoc = Objects.requireNonNull(STRUCTURE_FEATURE_REGISTRY.get().getKey(nms.feature));
+                final StructureType structureType = Objects.requireNonNull(StructureType.getStructureTypes().get(structureFeatureLoc.getPath()), structureFeatureLoc + " could not be converted to an API type");
+                return new ConfiguredStructure(key, structureType);
+            }
+        };
+    }
+}
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
index f9fc2fc63080a60fe61ebb08ddd93c4f189df84d..97c3ec08f943dd6960f599637037c98825788478 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkGenerator.java
@@ -294,6 +294,32 @@ public abstract class ChunkGenerator implements BiomeManager.NoiseBiomeSource {
 
     @Nullable
     public Pair<BlockPos, Holder<ConfiguredStructureFeature<?, ?>>> findNearestMapFeature(ServerLevel worldserver, HolderSet<ConfiguredStructureFeature<?, ?>> holderset, BlockPos center, int radius, boolean skipExistingChunks) {
+        // Paper start - StructureLocateEvent
+        final org.bukkit.World world = worldserver.getWorld();
+        final org.bukkit.Location origin = net.minecraft.server.MCUtil.toLocation(worldserver, center);
+        final Registry<ConfiguredStructureFeature<?, ?>> configuredStructureFeatureRegistry = worldserver.registryAccess().registryOrThrow(Registry.CONFIGURED_STRUCTURE_FEATURE_REGISTRY);
+        final List<io.papermc.paper.world.structure.ConfiguredStructure> configuredStructures = new ArrayList<>();
+        for (Holder<net.minecraft.world.level.levelgen.feature.ConfiguredStructureFeature<?, ?>> holder : holderset) {
+            final net.minecraft.resources.ResourceLocation configuredStructureResourceLoc = Objects.requireNonNull(configuredStructureFeatureRegistry.getKey(holder.value()));
+            final io.papermc.paper.world.structure.ConfiguredStructure configuredStructure = org.bukkit.Registry.CONFIGURED_STRUCTURE.get(org.bukkit.craftbukkit.util.CraftNamespacedKey.fromMinecraft(configuredStructureResourceLoc));
+            if (configuredStructure == null) {
+                LOGGER.warn("{} could not be converted to an API type", configuredStructureResourceLoc);
+                continue;
+            }
+            configuredStructures.add(configuredStructure);
+        }
+        final io.papermc.paper.event.world.StructuresLocateEvent event = new io.papermc.paper.event.world.StructuresLocateEvent(world, origin, configuredStructures, radius, skipExistingChunks);
+        if (!event.callEvent()) {
+            return null;
+        }
+        if (event.getResult() != null) {
+            return Pair.of(net.minecraft.server.MCUtil.toBlockPosition(event.getResult().position()), configuredStructureFeatureRegistry.getHolderOrThrow(ResourceKey.create(Registry.CONFIGURED_STRUCTURE_FEATURE_REGISTRY, org.bukkit.craftbukkit.util.CraftNamespacedKey.toMinecraft(event.getResult().configuredStructure().getKey()))));
+        }
+        center = net.minecraft.server.MCUtil.toBlockPosition(event.getOrigin());
+        radius = event.getRadius();
+        skipExistingChunks = event.shouldFindUnexplored();
+        holderset = HolderSet.direct(cs -> configuredStructureFeatureRegistry.getHolderOrThrow(ResourceKey.create(Registry.CONFIGURED_STRUCTURE_FEATURE_REGISTRY, org.bukkit.craftbukkit.util.CraftNamespacedKey.toMinecraft(cs.getKey()))), event.getConfiguredStructures());
+        // Paper end
         Set<Holder<Biome>> set = (Set) holderset.stream().flatMap((holder) -> {
             return ((ConfiguredStructureFeature) holder.value()).biomes().stream();
         }).collect(Collectors.toSet());
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/ConfiguredStructureFeature.java b/src/main/java/net/minecraft/world/level/levelgen/feature/ConfiguredStructureFeature.java
index af9ef29f5c5a600e4544ba735c833699cc93f93a..473a54963fbe08beeff26a828827f9f72d8a29b8 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/ConfiguredStructureFeature.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/ConfiguredStructureFeature.java
@@ -38,6 +38,7 @@ public class ConfiguredStructureFeature<FC extends FeatureConfiguration, F exten
     public final HolderSet<Biome> biomes;
     public final Map<MobCategory, StructureSpawnOverride> spawnOverrides;
     public final boolean adaptNoise;
+    static { io.papermc.paper.world.structure.PaperConfiguredStructure.init(); } // Paper
 
     public ConfiguredStructureFeature(F feature, FC config, HolderSet<Biome> biomes, boolean bl, Map<MobCategory, StructureSpawnOverride> map) {
         this.feature = feature;
diff --git a/src/test/java/io/papermc/paper/world/structure/ConfiguredStructureTest.java b/src/test/java/io/papermc/paper/world/structure/ConfiguredStructureTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..696b986ab32c478ef54cf25c34f6236c67967e1c
--- /dev/null
+++ b/src/test/java/io/papermc/paper/world/structure/ConfiguredStructureTest.java
@@ -0,0 +1,92 @@
+package io.papermc.paper.world.structure;
+
+import net.minecraft.data.BuiltinRegistries;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.Bootstrap;
+import net.minecraft.world.level.levelgen.feature.ConfiguredStructureFeature;
+import net.minecraft.world.level.levelgen.structure.BuiltinStructures;
+import org.bukkit.NamespacedKey;
+import org.bukkit.Registry;
+import org.bukkit.StructureType;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.bukkit.support.AbstractTestingBase;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import java.io.PrintStream;
+import java.lang.reflect.Field;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Objects;
+import java.util.StringJoiner;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+public class ConfiguredStructureTest extends AbstractTestingBase {
+
+    private static final Map<ResourceLocation, String> BUILT_IN_STRUCTURES = new LinkedHashMap<>();
+    private static final Map<StructureType, String> API_STRUCTURE_TYPES = new LinkedHashMap<>();
+    private static PrintStream out;
+
+    @BeforeClass
+    public static void collectStructures() throws ReflectiveOperationException {
+        out = System.out;
+        System.setOut(Bootstrap.STDOUT);
+        for (Field field : BuiltinStructures.class.getDeclaredFields()) {
+            if (field.getType().equals(ResourceKey.class)) {
+                BUILT_IN_STRUCTURES.put(((ResourceKey<ConfiguredStructureFeature<?, ?>>) field.get(null)).location(), field.getName());
+            }
+        }
+
+        for (Field field : StructureType.class.getDeclaredFields()) {
+            if (field.getType().equals(StructureType.class)) {
+                API_STRUCTURE_TYPES.put((StructureType) field.get(null), field.getName());
+            }
+        }
+    }
+
+    @Test
+    public void testMinecraftToApi() {
+        assertEquals("configured structure maps should be the same size", BUILT_IN_STRUCTURES.size(), BuiltinRegistries.CONFIGURED_STRUCTURE_FEATURE.size());
+        assertEquals("api structure types map should be the same size", API_STRUCTURE_TYPES.size(), StructureType.getStructureTypes().size());
+
+        Map<ResourceLocation, ConfiguredStructureFeature<?, ?>> missing = new LinkedHashMap<>();
+        for (ConfiguredStructureFeature<?, ?> feature : BuiltinRegistries.CONFIGURED_STRUCTURE_FEATURE) {
+            final ResourceLocation key = BuiltinRegistries.CONFIGURED_STRUCTURE_FEATURE.getKey(feature);
+            assertNotNull("Missing built-in registry key", key);
+            if (Registry.CONFIGURED_STRUCTURE.get(CraftNamespacedKey.fromMinecraft(key)) == null) {
+                missing.put(key, feature);
+            }
+        }
+
+        assertTrue(printMissing(missing), missing.isEmpty());
+    }
+
+    @Test
+    public void testApiToMinecraft() {
+        for (NamespacedKey apiKey : ConfiguredStructure.getConfiguredStructures().keySet()) {
+            assertTrue(apiKey + " does not have a minecraft counterpart", BuiltinRegistries.CONFIGURED_STRUCTURE_FEATURE.containsKey(CraftNamespacedKey.toMinecraft(apiKey)));
+        }
+    }
+
+    private static String printMissing(Map<ResourceLocation, ConfiguredStructureFeature<?, ?>> missing) {
+        final StringJoiner joiner = new StringJoiner("\n", "Missing: \n", "");
+
+        missing.forEach((key, configuredFeature) -> {
+            final ResourceLocation featureKey = Objects.requireNonNull(net.minecraft.core.Registry.STRUCTURE_FEATURE.getKey(configuredFeature.feature));
+            final StructureType type = StructureType.getStructureTypes().get(featureKey.getPath());
+            joiner.add("public static final ConfiguredStructure " + BUILT_IN_STRUCTURES.get(key) + " = create(\"" + key.getPath() + "\", StructureType." + API_STRUCTURE_TYPES.get(type) +");");
+        });
+
+        return joiner.toString();
+    }
+
+    @AfterClass
+    public static void after() {
+        System.setOut(out);
+    }
+}
