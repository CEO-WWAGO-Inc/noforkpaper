From b293e49162b4756884e81b15c6a5271778047b59 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Sat, 25 Jan 2020 16:59:18 -0800
Subject: [PATCH] fixup! incremental chunk saving


diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index 61fc087722..b82ea26eb6 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -40,6 +40,9 @@ public class PlayerChunk {
 
     private final PlayerChunkMap chunkMap; // Paper
 
+    long lastAutoSaveTime; // Paper - incremental autosave
+    long inactiveTimeStart; // Paper - incremental autosave
+
     public PlayerChunk(ChunkCoordIntPair chunkcoordintpair, int i, LightEngine lightengine, PlayerChunk.c playerchunk_c, PlayerChunk.d playerchunk_d) {
         this.statusFutures = new AtomicReferenceArray(PlayerChunk.CHUNK_STATUSES.size());
         this.fullChunkFuture = PlayerChunk.UNLOADED_CHUNK_FUTURE;
@@ -412,7 +415,19 @@ public class PlayerChunk {
         boolean flag2 = playerchunk_state.isAtLeast(PlayerChunk.State.BORDER);
         boolean flag3 = playerchunk_state1.isAtLeast(PlayerChunk.State.BORDER);
 
+        boolean prevHasBeenLoaded = this.hasBeenLoaded; // Paper
         this.hasBeenLoaded |= flag3;
+        // Paper start - incremental autosave
+        if (this.hasBeenLoaded & !prevHasBeenLoaded) {
+            long timeSinceAutoSave = this.inactiveTimeStart - this.lastAutoSaveTime;
+            if (timeSinceAutoSave < 0) {
+                // safest bet is to assume autosave is needed here
+                timeSinceAutoSave = this.chunkMap.world.paperConfig.autoSavePeriod;
+            }
+            this.lastAutoSaveTime = this.chunkMap.world.getTime() - timeSinceAutoSave;
+            this.chunkMap.autoSaveQueue.add(this);
+        }
+        // Paper end
         if (!flag2 && flag3) {
             // Paper start - cache ticking ready status
             int expectCreateCount = ++this.fullChunkCreateCount;
@@ -526,8 +541,32 @@ public class PlayerChunk {
     }
 
     public void m() {
+        boolean prev = this.hasBeenLoaded; // Paper
+        this.hasBeenLoaded = getChunkState(this.ticketLevel).isAtLeast(PlayerChunk.State.BORDER);
+        // Paper start - incremental autosave
+        if (prev != this.hasBeenLoaded) {
+            if (this.hasBeenLoaded) {
+                long timeSinceAutoSave = this.inactiveTimeStart - this.lastAutoSaveTime;
+                if (timeSinceAutoSave < 0) {
+                    // safest bet is to assume autosave is needed here
+                    timeSinceAutoSave = this.chunkMap.world.paperConfig.autoSavePeriod;
+                }
+                this.lastAutoSaveTime = this.chunkMap.world.getTime() - timeSinceAutoSave;
+                this.chunkMap.autoSaveQueue.add(this);
+            } else {
+                this.inactiveTimeStart = this.chunkMap.world.getTime();
+                this.chunkMap.autoSaveQueue.remove(this);
+            }
+        }
+        // Paper end
+    }
+
+    // Paper start - incremental autosave
+    public boolean setHasBeenLoaded() {
         this.hasBeenLoaded = getChunkState(this.ticketLevel).isAtLeast(PlayerChunk.State.BORDER);
+        return this.hasBeenLoaded;
     }
+    // Paper end
 
     public void a(ProtoChunkExtension protochunkextension) {
         for (int i = 0; i < this.statusFutures.length(); ++i) {
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 8acf042387..36657465f2 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -351,35 +351,63 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     }
 
-    // Paper start - derived from below
+    // Paper start - incremental autosave
+    final it.unimi.dsi.fastutil.objects.ObjectRBTreeSet<PlayerChunk> autoSaveQueue = new it.unimi.dsi.fastutil.objects.ObjectRBTreeSet<>((playerchunk1, playerchunk2) -> {
+        int timeCompare =  Long.compare(playerchunk1.lastAutoSaveTime, playerchunk2.lastAutoSaveTime);
+        if (timeCompare != 0) {
+            return timeCompare;
+        }
+
+        return Long.compare(MCUtil.getCoordinateKey(playerchunk1.location), MCUtil.getCoordinateKey(playerchunk2.location));
+    });
+
     protected void saveIncrementally() {
         int savedThisTick = 0;
-        for (PlayerChunk playerchunk : visibleChunks.values()) {
-            if (playerchunk.hasBeenLoaded()) {
-
-                IChunkAccess ichunkaccess = (IChunkAccess) playerchunk.getChunkSave().getNow(null); // CraftBukkit - decompile error
+        // optimized since we search far less chunks to hit ones that need to be saved
+        List<PlayerChunk> reschedule = new ArrayList<>(this.world.paperConfig.maxAutoSaveChunksPerTick);
+        long currentTick = this.world.getTime();
+        long maxSaveTime = currentTick - this.world.paperConfig.autoSavePeriod;
+
+        for (Iterator<PlayerChunk> iterator = this.autoSaveQueue.iterator(); iterator.hasNext();) {
+            PlayerChunk playerchunk = iterator.next();
+            if (playerchunk.lastAutoSaveTime > maxSaveTime) {
+                break;
+            }
 
+            iterator.remove();
 
-                if (ichunkaccess instanceof ProtoChunkExtension || ichunkaccess instanceof Chunk) {
-                    boolean shouldSave = true;
+            IChunkAccess ichunkaccess = playerchunk.getChunkSave().getNow(null);
+            if (ichunkaccess instanceof Chunk) {
+                boolean shouldSave = ((Chunk)ichunkaccess).lastSaved <= maxSaveTime;
 
-                    if (ichunkaccess instanceof Chunk) {
-                        shouldSave = ((Chunk) ichunkaccess).lastSaved + world.paperConfig.autoSavePeriod <= world.getTime();
-                    }
+                if (shouldSave && this.saveChunk(ichunkaccess)) {
+                    ++savedThisTick;
 
-                    if (shouldSave && this.saveChunk(ichunkaccess)) {
-                        ++savedThisTick;
-                        playerchunk.m();
+                    if (!playerchunk.setHasBeenLoaded()) {
+                        // do not fall through to reschedule logic
+                        playerchunk.inactiveTimeStart = currentTick;
+                        if (savedThisTick >= this.world.paperConfig.maxAutoSaveChunksPerTick) {
+                            break;
+                        }
+                        continue;
                     }
                 }
+            }
 
-                if (savedThisTick >= world.paperConfig.maxAutoSaveChunksPerTick) {
-                    return;
-                }
+            reschedule.add(playerchunk);
+
+            if (savedThisTick >= this.world.paperConfig.maxAutoSaveChunksPerTick) {
+                break;
             }
         }
+
+        for (int i = 0, len = reschedule.size(); i < len; ++i) {
+            PlayerChunk playerchunk = reschedule.get(i);
+            playerchunk.lastAutoSaveTime = this.world.getTime();
+            this.autoSaveQueue.add(playerchunk);
+        }
     }
-    // paper end
+    // Paper end
 
     protected void save(boolean flag) {
         if (flag) {
@@ -551,6 +579,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
                         this.world.unloadChunk(chunk);
                     }
+                    this.autoSaveQueue.remove(playerchunk); // Paper
 
                     try {
                         this.asyncSave(ichunkaccess); // Paper - async chunk saving
@@ -764,6 +793,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                     playerchunk.a(new ProtoChunkExtension(chunk));
                 }
 
+                chunk.setLastSaved(this.world.getTime() - 1); // Paper - avoid autosaving newly generated/loaded chunks
+
                 chunk.a(() -> {
                     return PlayerChunk.getChunkState(playerchunk.getTicketLevel());
                 });
-- 
2.25.0.windows.1

