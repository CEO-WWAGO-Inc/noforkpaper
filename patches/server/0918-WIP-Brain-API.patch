From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Mon, 29 Nov 2021 21:57:05 -0500
Subject: [PATCH] WIP Brain API


diff --git a/src/main/java/io/papermc/paper/entity/brain/PaperBrainHolder.java b/src/main/java/io/papermc/paper/entity/brain/PaperBrainHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..47c963897dcfd97641c637ccca19241c8c7a6a67
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/PaperBrainHolder.java
@@ -0,0 +1,340 @@
+package io.papermc.paper.entity.brain;
+
+import com.google.common.collect.ImmutableList;
+import com.mojang.datafixers.util.Pair;
+import io.papermc.paper.entity.brain.activity.ActivityKey;
+import io.papermc.paper.entity.brain.activity.PaperCustomBehavior;
+import io.papermc.paper.entity.brain.activity.PaperVanillaBehavior;
+import io.papermc.paper.entity.brain.activity.behavior.Behavior;
+import io.papermc.paper.entity.brain.activity.behavior.BehaviorPair;
+import io.papermc.paper.entity.brain.memory.MemoryKeyStatus;
+import io.papermc.paper.entity.brain.memory.MemoryPair;
+import io.papermc.paper.entity.brain.sensor.PaperCustomSensor;
+import io.papermc.paper.entity.brain.sensor.PaperVanillaSensor;
+import io.papermc.paper.entity.brain.sensor.Sensor;
+import io.papermc.paper.entity.brain.sensor.SensorKey;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.ai.Brain;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.memory.MemoryStatus;
+import net.minecraft.world.entity.ai.sensing.SensorType;
+import net.minecraft.world.entity.schedule.Activity;
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.entity.memory.CraftMemoryMapper;
+import org.bukkit.entity.memory.MemoryKey;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+
+/*
+So although every entity "has a brain"
+Not every entity uses it!
+*/
+public interface PaperBrainHolder<T extends org.bukkit.entity.LivingEntity> extends BrainHolder<T> {
+
+    LivingEntity getHandle();
+
+    default Brain<?> getBrain() {
+        return this.getHandle().getBrain();
+    }
+
+    @Override
+    default void unregisterActivities() {
+        Brain<?> brain = this.getBrain();
+
+        // Clear predefined core activities
+        brain.coreActivities = new HashSet<>();
+        brain.activeActivities.clear();
+
+        brain.activityRequirements.clear();
+        brain.activityMemoriesToEraseWhenStopped.clear();
+        brain.availableBehaviorsByPriority.clear();
+    }
+
+    private List<ActivityKey> transformActivities(Collection<Activity> activities) {
+        List<ActivityKey> keys = new ArrayList<>(activities.size());
+        for (Activity activity : activities) {
+            keys.add(PaperBrainUtil.toBukkit(activity));
+        }
+
+        return keys;
+    }
+
+    @Override
+    @NotNull
+    default Map<Integer, Collection<ActivityKey>> getPrioritizedActivities() {
+        Map<Integer, Collection<ActivityKey>> activities = new HashMap<>();
+        for (var entry : this.getBrain().availableBehaviorsByPriority.entrySet()) {
+            activities.put(entry.getKey(), transformActivities(entry.getValue().keySet()));
+        }
+
+        return activities;
+    }
+
+    @Override
+    @NotNull
+    default Collection<ActivityKey> getActiveActivities() {
+        return transformActivities(this.getBrain().activeActivities);
+    }
+
+    @Override
+    @NotNull
+    default Collection<ActivityKey> getCoreActivities() {
+        return transformActivities(this.getBrain().coreActivities);
+    }
+
+
+    @Override
+    default void startActivity(ActivityKey key) {
+        this.getBrain().setActiveActivityIfPossible(PaperBrainUtil.getHandle(key));
+    }
+
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    @Override
+    default void stopActivity(ActivityKey key) {
+        Activity activity = PaperBrainUtil.getHandle(key);
+        Brain<?> brain = this.getBrain();
+
+        if (brain.isActive(activity)) {
+            brain.activeActivities.remove(activity);
+
+            ServerLevel level = (ServerLevel) this.getHandle().level;
+            Map<Integer, Map<Activity, Set<net.minecraft.world.entity.ai.behavior.Behavior>>> map = (Map<Integer, Map<Activity, Set<net.minecraft.world.entity.ai.behavior.Behavior>>>) brain.availableBehaviorsByPriority.values();
+
+            for (var behaviorsMap : map.values()) {
+                Set<net.minecraft.world.entity.ai.behavior.Behavior> behaviors = behaviorsMap.get(activity);
+
+                if (behaviors != null) {
+                    for (var behavior : behaviors) {
+                        if (behavior.getStatus() == net.minecraft.world.entity.ai.behavior.Behavior.Status.RUNNING) {
+                            behavior.doStop(level, this.getHandle(), level.getGameTime());
+                        }
+                    }
+                }
+
+            }
+        }
+    }
+
+    @Override
+    default void startFirstValidActivity(Collection<ActivityKey> keys) {
+        List<Activity> activites = new ArrayList<>(keys.size());
+        for (ActivityKey key : keys) {
+            activites.add(PaperBrainUtil.getHandle(key));
+        }
+
+        this.getBrain().setActiveActivityToFirstValid(activites);
+    }
+
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    @Override
+    default void addActivity(ActivityKey key, Collection<BehaviorPair<? super T>> behaviorPairs, Collection<MemoryPair> requiredMemories, Collection<MemoryKey<?>> keysToRemoveOnFinish) {
+        Brain<?> brain = this.getBrain();
+
+        ImmutableList.Builder behaviorPairList = ImmutableList.builderWithExpectedSize(behaviorPairs.size());
+        // Build nms behaviors from pairs
+        for (BehaviorPair<? super T> pair : behaviorPairs) {
+            net.minecraft.world.entity.ai.behavior.Behavior mcBehavior;
+            Behavior<?> paperBehavior = pair.behavior();
+            if (paperBehavior instanceof PaperVanillaBehavior vanillaBehavior) { // Don't wrap vanilla behaviors
+                mcBehavior = vanillaBehavior.getHandle();
+            } else {
+                mcBehavior = new PaperCustomBehavior<>(pair.behavior());
+            }
+
+            behaviorPairList.add(new Pair<>(pair.priority(), mcBehavior));
+        }
+
+        // Build nms memories that are required inorder to run this activity
+        Set<Pair<MemoryModuleType<?>, MemoryStatus>> memoryPairSet = new HashSet<>(requiredMemories.size());
+        for (MemoryPair pair : requiredMemories) {
+            memoryPairSet.add(new Pair<>(PaperBrainUtil.getHandle(pair.key()), PaperBrainUtil.getHandle(pair.requiredStatus())));
+        }
+
+        // Get memories removed when this activity finishes
+        Set<MemoryModuleType<?>> removeSet = new HashSet<>(keysToRemoveOnFinish.size());
+        for (MemoryKey<?> memoryKey : keysToRemoveOnFinish) {
+            removeSet.add(PaperBrainUtil.getHandle(memoryKey));
+        }
+
+        brain.addActivityAndRemoveMemoriesWhenStopped(PaperBrainUtil.getHandle(key),
+            behaviorPairList.build(),
+            memoryPairSet,
+            removeSet
+        );
+    }
+
+    @Override
+    default ActivityKey getDefaultActivity() {
+        return PaperBrainUtil.toBukkit(this.getBrain().defaultActivity);
+    }
+
+    @Override
+    default void setDefaultActivity(ActivityKey key) {
+        this.getBrain().setDefaultActivity(PaperBrainUtil.getHandle(key));
+    }
+
+    @Override
+    default void setCoreActivities(Collection<ActivityKey> keys) {
+        Set<Activity> activites = new HashSet<>(keys.size());
+        for (ActivityKey key : keys) {
+            activites.add(PaperBrainUtil.getHandle(key));
+        }
+
+        this.getBrain().setCoreActivities(activites);
+    }
+
+    @Override
+    @NotNull
+    default List<ActivityKey> getActivityQueue() {
+        return transformActivities(this.getBrain().manuallyCheckingActivities);
+    }
+
+    @Override
+    default void setActivityQueue(List<ActivityKey> keys) {
+        List<Activity> activites = new ArrayList<>(keys.size());
+        for (ActivityKey key : keys) {
+            activites.add(PaperBrainUtil.getHandle(key));
+        }
+
+        this.getBrain().manuallyCheckingActivities = activites;
+    }
+
+    @Override
+    default void forceTickBrain(boolean forceTick) {
+        this.getBrain().isForceTickingBrain = forceTick;
+    }
+
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    @Override
+    default void addSensor(SensorKey key, Sensor<? super T> sensor) {
+        Brain<?> brain = this.getBrain();
+
+        // See brain constructor
+        net.minecraft.world.entity.ai.sensing.Sensor mcSensor;
+        if (sensor instanceof PaperVanillaSensor vanillaSensor) { // Don't surround vanilla sensors
+            mcSensor = vanillaSensor.getHandle();
+        } else {
+            mcSensor = new PaperCustomSensor(sensor);
+        }
+
+        SensorType ignoreGenericType = PaperBrainUtil.getHandle(key);
+        // Register sensor
+        brain.sensors.put(ignoreGenericType, mcSensor);
+
+        // Register any required memories
+        Set<MemoryModuleType<?>> thanksIntellij = mcSensor.requires(); // Intellij wants to have this set iterate objects ???????????????????????????
+        for (MemoryModuleType<?> memoryType : thanksIntellij) {
+            brain.memories.putIfAbsent(memoryType, Optional.empty());
+        }
+    }
+
+    @Override
+    default void unregisterSensors() {
+        Brain<?> brain = this.getBrain();
+        brain.sensors.clear();
+    }
+
+    @Override
+    default void removeSensor(SensorKey key) {
+        Brain<?> brain = this.getBrain();
+        brain.sensors.remove(PaperBrainUtil.getHandle(key));
+    }
+
+    @Nullable
+    @Override
+    default Sensor<? extends org.bukkit.entity.LivingEntity> getSensor(SensorKey key) {
+        Brain<?> brain = this.getBrain();
+        return brain.sensors.get(PaperBrainUtil.getHandle(key)).getPaperSensor();
+    }
+
+    @Override
+    @NotNull
+    default Collection<Sensor<? extends org.bukkit.entity.LivingEntity>> getSensors() {
+        Brain<?> brain = this.getBrain();
+
+        List<Sensor<? extends org.bukkit.entity.LivingEntity>> sensors = new ArrayList<>(brain.sensors.size());
+        for (net.minecraft.world.entity.ai.sensing.Sensor<?> sensor : brain.sensors.values()) {
+            sensors.add(sensor.getPaperSensor());
+        }
+
+        return sensors;
+    }
+
+    @Override
+    default void registerMemory(MemoryKey<?> memoryKey) {
+        Brain<?> brain = this.getBrain();
+        brain.memories.put(PaperBrainUtil.getHandle(memoryKey), Optional.empty());
+    }
+
+    @Override
+    default <V> void setMemory(MemoryKey<V> memoryKey, V value) {
+       this.setMemory(memoryKey, value, Long.MAX_VALUE);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    default <V> void setMemory(MemoryKey<V> memoryKey, V value, long expireIn) {
+        Brain<?> brain = this.getBrain();
+
+        // Bukkit api, handle proper mapping to NMS types
+        if (memoryKey.getKey().getNamespace().equals(NamespacedKey.MINECRAFT_NAMESPACE)) {
+            value = (V) CraftMemoryMapper.toNms(value);
+        }
+
+        if (expireIn == Long.MAX_VALUE) {
+            brain.setMemory(PaperBrainUtil.getHandle(memoryKey), value);
+        } else {
+            brain.setMemoryWithExpiry(PaperBrainUtil.getHandle(memoryKey), value, expireIn);
+        }
+    }
+
+    @Override
+    default boolean isMemoryStatus(MemoryKey<?> memoryKey, MemoryKeyStatus status) {
+        Brain<?> brain = this.getBrain();
+
+        return brain.checkMemory(PaperBrainUtil.getHandle(memoryKey), PaperBrainUtil.getHandle(status));
+    }
+
+    @Override
+    default void forgetMemory(MemoryKey<?> memoryKey) {
+        Brain<?> brain = this.getBrain();
+
+        brain.eraseMemory(PaperBrainUtil.getHandle(memoryKey));
+    }
+
+    @Override
+    default void unregisterMemory(MemoryKey<?> memoryKey) {
+        this.getBrain().memories.remove(PaperBrainUtil.getHandle(memoryKey));
+    }
+
+    @Override
+    @NotNull
+    default Collection<MemoryKey<?>> getMemories() {
+        Brain<?> brain = this.getBrain();
+
+        List<MemoryKey<?>> memories = new ArrayList<>(); // Don't specify initial size since keys can be null due to this being a separate api
+        for (MemoryModuleType<?> memory : brain.memories.keySet()) {
+            MemoryKey<?> key = PaperBrainUtil.toBukkit(memory);
+            if (key != null) {
+                memories.add(key);
+            }
+        }
+
+        return memories;
+    }
+
+    @Override
+    default void unregisterMemories() {
+        this.getBrain().memories.clear();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/PaperBrainUtil.java b/src/main/java/io/papermc/paper/entity/brain/PaperBrainUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..be7cdc86fb990ac8ddea1e67f959d3899078c977
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/PaperBrainUtil.java
@@ -0,0 +1,97 @@
+package io.papermc.paper.entity.brain;
+
+import io.leangen.geantyref.GenericTypeReflector;
+import io.papermc.paper.entity.brain.activity.ActivityKey;
+import io.papermc.paper.entity.brain.activity.PaperActivity;
+import io.papermc.paper.entity.brain.activity.VanillaActivityKey;
+import io.papermc.paper.entity.brain.memory.MemoryKeyStatus;
+import io.papermc.paper.entity.brain.memory.PaperDataTypeWrapperCodec;
+import io.papermc.paper.entity.brain.sensor.PaperSensor;
+import io.papermc.paper.entity.brain.sensor.SensorKey;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.memory.MemoryStatus;
+import net.minecraft.world.entity.ai.sensing.SensorType;
+import net.minecraft.world.entity.schedule.Activity;
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.bukkit.entity.memory.MemoryKey;
+import org.bukkit.entity.memory.PaperMemoryKey;
+import org.bukkit.persistence.PersistentDataType;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Optional;
+
+public class PaperBrainUtil {
+
+    @SuppressWarnings("unchecked")
+    public static <C> MemoryKey<C> registerCustomMemoryKey(NamespacedKey key, io.leangen.geantyref.TypeToken<C> type, @Nullable PersistentDataType<C, ?> dataType) {
+        MemoryKey<C> memoryKey = PaperMemoryKey.create(key, (Class<C>) GenericTypeReflector.erase(type.getType()));
+        Registry.register(Registry.MEMORY_MODULE_TYPE, new ResourceLocation(key.toString()), new MemoryModuleType<>(Optional.ofNullable(dataType == null ? null : new PaperDataTypeWrapperCodec<>(dataType))));
+
+        return memoryKey;
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <T> MemoryModuleType<T> getHandle(MemoryKey<T> key) {
+        return (MemoryModuleType<T>) Registry.MEMORY_MODULE_TYPE.get(CraftNamespacedKey.toMinecraft(key.getKey()));
+    }
+
+    public static MemoryKey<?> toBukkit(MemoryModuleType<?> key) {
+        return MemoryKey.getByKey(CraftNamespacedKey.fromMinecraft(Registry.MEMORY_MODULE_TYPE.getKey(key)));
+    }
+
+    public static MemoryKeyStatus toBukkit(MemoryStatus status) {
+        return switch (status) {
+            case VALUE_ABSENT -> MemoryKeyStatus.ABSENT;
+            case VALUE_PRESENT -> MemoryKeyStatus.PRESENT;
+            case REGISTERED -> MemoryKeyStatus.REGISTERED;
+        };
+    }
+
+    public static MemoryStatus getHandle(MemoryKeyStatus status) {
+        return switch (status) {
+            case ABSENT -> MemoryStatus.VALUE_ABSENT;
+            case PRESENT -> MemoryStatus.VALUE_PRESENT;
+            case REGISTERED -> MemoryStatus.REGISTERED;
+        };
+    }
+
+    public static io.papermc.paper.entity.brain.sensor.SensorKey registerCustomSensorKey(NamespacedKey key) {
+        Registry.register(Registry.SENSOR_TYPE, new ResourceLocation(key.toString()), new SensorType<>(() -> {
+            throw new UnsupportedOperationException("This is only called when the brain is initially created. Paper does not use this and instead directly injects itself into " +
+                "the brain directly.");
+        }));
+
+        return new PaperSensor(key);
+    }
+
+    public static SensorType<?> getHandle(SensorKey key) {
+        if (key == null) { // Null check to prevent confusing exception
+            throw new NullPointerException("Null key provided");
+        }
+
+        return Registry.SENSOR_TYPE.get(CraftNamespacedKey.toMinecraft(key.getKey()));
+    }
+
+    public static ActivityKey registerCustomActivityKey(NamespacedKey key) {
+        ActivityKey activityKey = new PaperActivity(key);
+        Registry.register(Registry.ACTIVITY, new ResourceLocation(key.toString()), new Activity(key.toString()));
+
+        return activityKey;
+    }
+
+    public static Activity getHandle(ActivityKey key) {
+        if (key == null) { // Null check to prevent confusing exception
+            throw new NullPointerException("Null key provided");
+        }
+
+        return Registry.ACTIVITY.get(CraftNamespacedKey.toMinecraft(key.getKey()));
+    }
+
+    public static ActivityKey toBukkit(Activity activity) {
+        return VanillaActivityKey.getByKey(CraftNamespacedKey.fromMinecraft(Registry.ACTIVITY.getKey(activity)));
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/activity/PaperActivity.java b/src/main/java/io/papermc/paper/entity/brain/activity/PaperActivity.java
new file mode 100644
index 0000000000000000000000000000000000000000..989dfd561de18124034cfa0b1225a680c7c45f5d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/activity/PaperActivity.java
@@ -0,0 +1,13 @@
+package io.papermc.paper.entity.brain.activity;
+
+import org.bukkit.NamespacedKey;
+import org.jetbrains.annotations.NotNull;
+
+public record PaperActivity(NamespacedKey key) implements ActivityKey {
+
+    @Override
+    public @NotNull
+    NamespacedKey getKey() {
+        return key;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/activity/PaperCustomBehavior.java b/src/main/java/io/papermc/paper/entity/brain/activity/PaperCustomBehavior.java
new file mode 100644
index 0000000000000000000000000000000000000000..1f8d16a82f4f2bdb4b6a973e815119dfffad0862
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/activity/PaperCustomBehavior.java
@@ -0,0 +1,61 @@
+package io.papermc.paper.entity.brain.activity;
+
+import io.papermc.paper.entity.brain.PaperBrainUtil;
+import io.papermc.paper.entity.brain.memory.MemoryPair;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.ai.behavior.Behavior;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.memory.MemoryStatus;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+
+
+public class PaperCustomBehavior<T extends LivingEntity> extends Behavior<T> {
+
+    private final io.papermc.paper.entity.brain.activity.behavior.Behavior<org.bukkit.entity.LivingEntity> behavior;
+
+    public PaperCustomBehavior(io.papermc.paper.entity.brain.activity.behavior.Behavior behavior) {
+        super(toMinecraft(behavior), behavior.getMinRuntime(), behavior.getMaxRuntime());
+        this.behavior = behavior;
+    }
+
+    @Override
+    protected void start(ServerLevel world, T entity, long time) {
+        behavior.start(entity.getBukkitLivingEntity());
+    }
+
+    @Override
+    protected void tick(ServerLevel world, T entity, long time) {
+        behavior.tick(entity.getBukkitLivingEntity());
+    }
+
+    @Override
+    protected void stop(ServerLevel world, T entity, long time) {
+        behavior.stop(entity.getBukkitLivingEntity());
+    }
+
+    @Override
+    protected boolean checkExtraStartConditions(ServerLevel world, T entity) {
+        return behavior.canStart(entity.getBukkitLivingEntity());
+    }
+
+    @Override
+    protected boolean canStillUse(ServerLevel world, T entity, long time) {
+        return behavior.canStillRun(entity.getBukkitLivingEntity());
+    }
+
+    private static Map<MemoryModuleType<?>, MemoryStatus> toMinecraft(io.papermc.paper.entity.brain.activity.behavior.Behavior behavior) {
+        Collection<MemoryPair> requirement = behavior.getMemoryRequirements();
+
+        Map<MemoryModuleType<?>, MemoryStatus> map = new HashMap<>(requirement.size());
+        for (MemoryPair pair : requirement) {
+            map.put(PaperBrainUtil.getHandle(pair.key()), PaperBrainUtil.getHandle(pair.requiredStatus()));
+        }
+
+        return map;
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/activity/PaperVanillaBehavior.java b/src/main/java/io/papermc/paper/entity/brain/activity/PaperVanillaBehavior.java
new file mode 100644
index 0000000000000000000000000000000000000000..2da79dc1337745e3484ca5a347455c3dcaa72c12
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/activity/PaperVanillaBehavior.java
@@ -0,0 +1,81 @@
+package io.papermc.paper.entity.brain.activity;
+
+import io.papermc.paper.entity.brain.PaperBrainUtil;
+import io.papermc.paper.entity.brain.activity.behavior.Behavior;
+import io.papermc.paper.entity.brain.memory.MemoryKeyStatus;
+import io.papermc.paper.entity.brain.memory.MemoryPair;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.memory.MemoryStatus;
+import org.bukkit.craftbukkit.entity.CraftLivingEntity;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.memory.MemoryKey;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+
+public class PaperVanillaBehavior implements Behavior<LivingEntity> {
+
+    private final net.minecraft.world.entity.ai.behavior.Behavior<net.minecraft.world.entity.LivingEntity> handle;
+    private final Collection<MemoryPair> memoryRequirements;
+
+    public PaperVanillaBehavior(net.minecraft.world.entity.ai.behavior.Behavior<net.minecraft.world.entity.LivingEntity> handle) {
+        this.handle = handle;
+
+        List<MemoryPair> memoryRequirements = new ArrayList<>(handle.entryCondition.size());
+        for (Map.Entry<MemoryModuleType<?>, MemoryStatus> type : handle.entryCondition.entrySet()) {
+
+            MemoryKey<?> key = PaperBrainUtil.toBukkit(type.getKey());
+            if (key != null) {
+                MemoryKeyStatus status = PaperBrainUtil.toBukkit(type.getValue());
+
+                memoryRequirements.add(new MemoryPair(status, key));
+            }
+        }
+
+        this.memoryRequirements = memoryRequirements;
+    }
+
+    @Override
+    public void start(LivingEntity entity) {
+        net.minecraft.world.entity.LivingEntity entityHandle = ((CraftLivingEntity) entity).getHandle();
+
+        handle.tryStart((ServerLevel) entityHandle.level, entityHandle, entityHandle.level.getGameTime());
+    }
+
+    @Override
+    public void tick(LivingEntity entity) {
+        net.minecraft.world.entity.LivingEntity entityHandle = ((CraftLivingEntity) entity).getHandle();
+
+        handle.tickOrStop((ServerLevel) entityHandle.level, entityHandle, entityHandle.level.getGameTime());
+    }
+
+    @Override
+    public void stop(LivingEntity entity) {
+        net.minecraft.world.entity.LivingEntity entityHandle = ((CraftLivingEntity) entity).getHandle();
+
+        handle.doStop((ServerLevel) entityHandle.level, entityHandle, entityHandle.level.getGameTime());
+    }
+
+    @Override
+    public int getMinRuntime() {
+        return handle.minDuration;
+    }
+
+    @Override
+    public int getMaxRuntime() {
+        return handle.maxDuration;
+    }
+
+    @Override
+    public Collection<MemoryPair> getMemoryRequirements() {
+        return memoryRequirements;
+    }
+
+    public net.minecraft.world.entity.ai.behavior.Behavior<net.minecraft.world.entity.LivingEntity> getHandle() {
+        return handle;
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/memory/PaperDataTypeWrapperCodec.java b/src/main/java/io/papermc/paper/entity/brain/memory/PaperDataTypeWrapperCodec.java
new file mode 100644
index 0000000000000000000000000000000000000000..83d60a179049fa43450ea1ef15e8efe20c9fd4bd
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/memory/PaperDataTypeWrapperCodec.java
@@ -0,0 +1,78 @@
+package io.papermc.paper.entity.brain.memory;
+
+import com.mojang.datafixers.DataFixUtils;
+import com.mojang.serialization.Codec;
+import com.mojang.serialization.DataResult;
+import com.mojang.serialization.DynamicOps;
+import com.mojang.serialization.codecs.PrimitiveCodec;
+import org.bukkit.craftbukkit.persistence.CraftPersistentDataAdapterContext;
+import org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry;
+import org.bukkit.persistence.PersistentDataType;
+
+import java.nio.ByteBuffer;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.stream.IntStream;
+import java.util.stream.LongStream;
+
+public class PaperDataTypeWrapperCodec<P, C, A> implements PrimitiveCodec<C> {
+
+    private static final Map<Class<?>, PrimitiveCodec<?>> CODEC_PDT_MAP = new HashMap<>();
+
+    static {
+        CODEC_PDT_MAP.put(Byte.class, Codec.BYTE);
+        CODEC_PDT_MAP.put(Short.class, Codec.SHORT);
+        CODEC_PDT_MAP.put(Integer.class, Codec.INT);
+        CODEC_PDT_MAP.put(Long.class, Codec.LONG);
+        CODEC_PDT_MAP.put(Float.class, Codec.FLOAT);
+        CODEC_PDT_MAP.put(Double.class, Codec.DOUBLE);
+        CODEC_PDT_MAP.put(String.class, Codec.STRING);
+        CODEC_PDT_MAP.put(byte[].class, Codec.BYTE_BUFFER);
+        CODEC_PDT_MAP.put(int[].class, Codec.INT_STREAM);
+        CODEC_PDT_MAP.put(long[].class, Codec.LONG_STREAM);
+    }
+
+    private static final CraftPersistentDataAdapterContext CONTEXT = new CraftPersistentDataAdapterContext(new CraftPersistentDataTypeRegistry());
+
+    private final PrimitiveCodec<A> codec; // Codec can be a different type than persistentDataType
+    private final PersistentDataType<P, C> dataType;
+
+    @SuppressWarnings("unchecked")
+    public PaperDataTypeWrapperCodec(PersistentDataType<P, C> persistentDataType) {
+        this.dataType = persistentDataType;
+        this.codec = (PrimitiveCodec<A>) CODEC_PDT_MAP.get(persistentDataType.getPrimitiveType());
+        if (codec == null) {
+            throw new IllegalArgumentException("Provided PersistentDataType was not a primitive! Couldn't find fit for: " + persistentDataType.getPrimitiveType());
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <T> DataResult<C> read(DynamicOps<T> ops, T input) {
+        Object deserialized = codec.decode(ops, input).result().orElseThrow().getFirst();
+        if (deserialized instanceof ByteBuffer buffer) {
+            deserialized = DataFixUtils.toArray(buffer);
+        } else if (deserialized instanceof IntStream stream) {
+            deserialized = stream.toArray();
+        } else if (deserialized instanceof LongStream stream) {
+            deserialized = stream.toArray();
+        }
+
+        return DataResult.success(dataType.fromPrimitive((P) deserialized, CONTEXT));
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <T> T write(DynamicOps<T> ops, C value) {
+        Object primitive = dataType.toPrimitive(value, CONTEXT);
+        if (primitive instanceof byte[] bytes) {
+            primitive = ByteBuffer.wrap(bytes);
+        } else if (primitive instanceof int[] ints) {
+            primitive = IntStream.of(ints);
+        } else if (primitive instanceof long[] longs) {
+            primitive = LongStream.of(longs);
+        }
+
+        return codec.write(ops, (A) primitive);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/sensor/PaperCustomSensor.java b/src/main/java/io/papermc/paper/entity/brain/sensor/PaperCustomSensor.java
new file mode 100644
index 0000000000000000000000000000000000000000..d54346f6a38edc20e7c5bbee5a2ece4ae2f6e0b2
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/sensor/PaperCustomSensor.java
@@ -0,0 +1,46 @@
+package io.papermc.paper.entity.brain.sensor;
+
+import io.papermc.paper.entity.brain.PaperBrainUtil;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.memory.MemoryKey;
+
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
+public class PaperCustomSensor extends net.minecraft.world.entity.ai.sensing.Sensor<net.minecraft.world.entity.LivingEntity> {
+
+    private final Sensor<LivingEntity> sensor;
+    private final Set<MemoryModuleType<?>> requiredMemories;
+
+    @SuppressWarnings("unchecked")
+    public PaperCustomSensor(Sensor<? extends LivingEntity> sensor) {
+        super(sensor.getInterval());
+        this.sensor = (Sensor<LivingEntity>) sensor;
+
+        Set<MemoryModuleType<?>> minecraftRequiredMemories = new HashSet<>(sensor.requiredMemories().size());
+        Collection<MemoryKey<?>> setupidIntellij = sensor.requiredMemories();
+        for (MemoryKey<?> key : setupidIntellij) {
+            minecraftRequiredMemories.add(PaperBrainUtil.getHandle(key));
+        }
+
+        this.requiredMemories = minecraftRequiredMemories;
+    }
+
+    @Override
+    protected void doTick(ServerLevel world, net.minecraft.world.entity.LivingEntity entity) {
+        sensor.tick(entity.getBukkitLivingEntity());
+    }
+
+    @Override
+    public Set<MemoryModuleType<?>> requires() {
+        return requiredMemories;
+    }
+
+    @Override
+    public Sensor<? extends LivingEntity> getPaperSensor() {
+        return sensor;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/sensor/PaperSensor.java b/src/main/java/io/papermc/paper/entity/brain/sensor/PaperSensor.java
new file mode 100644
index 0000000000000000000000000000000000000000..56b8452dab250b362fe200f22469f811b191b481
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/sensor/PaperSensor.java
@@ -0,0 +1,12 @@
+package io.papermc.paper.entity.brain.sensor;
+
+import org.bukkit.NamespacedKey;
+import org.jetbrains.annotations.NotNull;
+
+public record PaperSensor(NamespacedKey key) implements SensorKey {
+
+    @Override
+    public @NotNull NamespacedKey getKey() {
+        return key;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/sensor/PaperVanillaSensor.java b/src/main/java/io/papermc/paper/entity/brain/sensor/PaperVanillaSensor.java
new file mode 100644
index 0000000000000000000000000000000000000000..1e9a52f987bae5168a3bdb46b9bdd329a31769bb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/sensor/PaperVanillaSensor.java
@@ -0,0 +1,58 @@
+package io.papermc.paper.entity.brain.sensor;
+
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.entity.CraftLivingEntity;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.memory.MemoryKey;
+
+import java.util.HashSet;
+import java.util.Set;
+
+public class PaperVanillaSensor implements Sensor<LivingEntity> {
+
+    private final net.minecraft.world.entity.ai.sensing.Sensor<net.minecraft.world.entity.LivingEntity> handle;
+
+    // temp
+    @SuppressWarnings("unchecked")
+    public PaperVanillaSensor(net.minecraft.world.entity.ai.sensing.Sensor<?> handle) {
+        this.handle = (net.minecraft.world.entity.ai.sensing.Sensor<net.minecraft.world.entity.LivingEntity>) handle;
+    }
+
+    @Override
+    public int getInterval() {
+        return handle.scanRate;
+    }
+
+    @Override
+    public void tick(LivingEntity entity) {
+        net.minecraft.world.entity.LivingEntity livingEntityHandle = ((CraftLivingEntity) entity).getHandle();
+
+        handle.tick((ServerLevel) livingEntityHandle.level, livingEntityHandle);
+    }
+
+    @Override
+    public Set<MemoryKey<?>> requiredMemories() {
+        Set<MemoryKey<?>> keys = new HashSet<>(handle.requires().size());
+        for (MemoryModuleType<?> type : handle.requires()) {
+            MemoryKey<?> key = MemoryKey.getByKey(NamespacedKey.minecraft(type.toString()));
+            if (key != null) {
+                keys.add(key);
+            }
+        }
+
+        return keys;
+    }
+
+    public net.minecraft.world.entity.ai.sensing.Sensor<net.minecraft.world.entity.LivingEntity> getHandle() {
+        return handle;
+    }
+
+    @Override
+    public String toString() {
+        return "PaperVanillaSensor{" +
+            "handle=" + handle +
+            '}';
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 279051442ac6cf288a03a16a35ddbf66d1cd1e90..c2899b4547d35ff4caef215ad76d87205d9d77f3 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -142,7 +142,6 @@ import org.bukkit.event.entity.EntityTeleportEvent;
 import org.bukkit.event.player.PlayerItemConsumeEvent;
 // CraftBukkit end
 
-import co.aikar.timings.MinecraftTimings; // Paper
 
 public abstract class LivingEntity extends Entity {
 
@@ -309,7 +308,18 @@ public abstract class LivingEntity extends Entity {
     }
 
     protected Brain.Provider<?> brainProvider() {
-        return Brain.provider(ImmutableList.of(), ImmutableList.of());
+        // Paper start
+        // Create our own brain provider for living entities to mark that this entity might not actually use their
+        // brain. Entities that override this method typically are using and ticking their brain normally.
+        return new Brain.Provider<>(ImmutableList.of(), ImmutableList.of()) {
+            @Override
+            public Brain<LivingEntity> makeBrain(Dynamic<?> data) {
+                Brain<LivingEntity> brain = super.makeBrain(data);
+                brain.isBrainTickingNormally = false;
+                return brain;
+            }
+        };
+        // Paper end
     }
 
     protected Brain<?> makeBrain(Dynamic<?> dynamic) {
diff --git a/src/main/java/net/minecraft/world/entity/Mob.java b/src/main/java/net/minecraft/world/entity/Mob.java
index 3646b969fa51b9683ab4137e530c3a6f6fc6c465..c14ac54e48b02e056f4881c0b7fdfb0f114fb786 100644
--- a/src/main/java/net/minecraft/world/entity/Mob.java
+++ b/src/main/java/net/minecraft/world/entity/Mob.java
@@ -873,6 +873,12 @@ public abstract class Mob extends LivingEntity {
         this.level.getProfiler().pop();
         this.level.getProfiler().push("mob tick");
         this.customServerAiStep();
+        // Paper start
+        net.minecraft.world.entity.ai.Brain brain = this.getBrain();
+        if (!brain.isBrainTickingNormally && brain.isForceTickingBrain) {
+            brain.tick((ServerLevel) level, this);
+        }
+        // Paper end
         this.level.getProfiler().pop();
         this.level.getProfiler().push("controls");
         this.level.getProfiler().push("move");
diff --git a/src/main/java/net/minecraft/world/entity/ai/Brain.java b/src/main/java/net/minecraft/world/entity/ai/Brain.java
index 8c8b98c7ca107b1c37c1734ef0f2b11604dd4f70..806a0b4577386ea429868be34154d8d7de761ead 100644
--- a/src/main/java/net/minecraft/world/entity/ai/Brain.java
+++ b/src/main/java/net/minecraft/world/entity/ai/Brain.java
@@ -52,6 +52,11 @@ public class Brain<E extends LivingEntity> {
     public final Set<Activity> activeActivities = Sets.newHashSet();
     public Activity defaultActivity = Activity.IDLE;
     private long lastScheduleUpdate = -9999L;
+    // Paper start
+    public boolean isBrainTickingNormally = true;
+    public boolean isForceTickingBrain = false;
+    public java.util.List<Activity> manuallyCheckingActivities = java.util.List.of();
+    // Paper end
 
     public static <E extends LivingEntity> Brain.Provider<E> provider(Collection<? extends MemoryModuleType<?>> memoryModules, Collection<? extends SensorType<? extends Sensor<? super E>>> sensors) {
         return new Brain.Provider<>(memoryModules, sensors);
@@ -80,7 +85,7 @@ public class Brain<E extends LivingEntity> {
                     mutableObject.setValue(mutableObject.getValue().apply2(ImmutableList.Builder::add, dataResult2));
                 });
                 ImmutableList<Brain.MemoryValue<?>> immutableList = mutableObject.getValue().resultOrPartial(Brain.LOGGER::error).map(ImmutableList.Builder::build).orElseGet(ImmutableList::of);
-                return DataResult.success(new Brain<>(memoryModules, sensors, immutableList, mutableObject::getValue));
+                return DataResult.success(new Brain(memoryModules, sensors, immutableList, mutableObject::getValue)); // Paper - decomp
             }
 
             private <T, U> DataResult<Brain.MemoryValue<U>> captureRead(MemoryModuleType<U> memoryModuleType, DynamicOps<T> dynamicOps, T object) {
@@ -172,7 +177,7 @@ public class Brain<E extends LivingEntity> {
         if (optional == null) {
             throw new IllegalStateException("Unregistered memory fetched: " + type);
         } else {
-            return optional.map(ExpirableValue::getValue);
+            return (Optional<U>) optional.map(ExpirableValue::getValue); // Paper - decomp
         }
     }
 
@@ -373,6 +378,11 @@ public class Brain<E extends LivingEntity> {
         this.tickSensors(world, entity);
         this.startEachNonRunningBehavior(world, entity);
         this.tickEachRunningBehavior(world, entity);
+        // Paper start - Note that this will get overriden by most normal entities.
+        if (!this.manuallyCheckingActivities.isEmpty()) {
+            this.setActiveActivityToFirstValid(this.manuallyCheckingActivities);
+        }
+        // Paper end
     }
 
     private void tickSensors(ServerLevel world, E entity) {
@@ -467,7 +477,7 @@ public class Brain<E extends LivingEntity> {
         private final MemoryModuleType<U> type;
         private final Optional<? extends ExpirableValue<U>> value;
 
-        static <U> Brain.MemoryValue<U> createUnchecked(MemoryModuleType<U> type, Optional<? extends ExpirableValue<?>> data) {
+        static <U> Brain.MemoryValue<U> createUnchecked(MemoryModuleType<U> type, Optional data) { // Paper - decomp
             return new Brain.MemoryValue<>(type, data);
         }
 
@@ -494,7 +504,7 @@ public class Brain<E extends LivingEntity> {
         private final Collection<? extends SensorType<? extends Sensor<? super E>>> sensorTypes;
         private final Codec<Brain<E>> codec;
 
-        Provider(Collection<? extends MemoryModuleType<?>> memoryModules, Collection<? extends SensorType<? extends Sensor<? super E>>> sensors) {
+        public Provider(Collection<? extends MemoryModuleType<?>> memoryModules, Collection<? extends SensorType<? extends Sensor<? super E>>> sensors) { // Paper
             this.memoryTypes = memoryModules;
             this.sensorTypes = sensors;
             this.codec = Brain.codec(memoryModules, sensors);
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/Sensor.java b/src/main/java/net/minecraft/world/entity/ai/sensing/Sensor.java
index fcdb9bde8e1605e30dde3e580491522d4b62cdc0..a019155e369005119f7912451455fec3647c01ae 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/Sensor.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/Sensor.java
@@ -17,7 +17,7 @@ public abstract class Sensor<E extends LivingEntity> {
     private static final TargetingConditions ATTACK_TARGET_CONDITIONS_IGNORE_INVISIBILITY_TESTING = TargetingConditions.forCombat().range(16.0D).ignoreInvisibilityTesting();
     private static final TargetingConditions ATTACK_TARGET_CONDITIONS_IGNORE_LINE_OF_SIGHT = TargetingConditions.forCombat().range(16.0D).ignoreLineOfSight();
     private static final TargetingConditions ATTACK_TARGET_CONDITIONS_IGNORE_INVISIBILITY_AND_LINE_OF_SIGHT = TargetingConditions.forCombat().range(16.0D).ignoreLineOfSight().ignoreInvisibilityTesting();
-    private final int scanRate;
+    public final int scanRate;
     private long timeToTick;
     // Paper start - configurable sensor tick rate and timings
     private final String configKey;
@@ -69,4 +69,16 @@ public abstract class Sensor<E extends LivingEntity> {
     public static boolean isEntityAttackableIgnoringLineOfSight(LivingEntity entity, LivingEntity target) {
         return entity.getBrain().isMemoryValue(MemoryModuleType.ATTACK_TARGET, target) ? ATTACK_TARGET_CONDITIONS_IGNORE_INVISIBILITY_AND_LINE_OF_SIGHT.test(entity, target) : ATTACK_TARGET_CONDITIONS_IGNORE_LINE_OF_SIGHT.test(entity, target);
     }
+
+    // Paper start - mob goal api
+    private io.papermc.paper.entity.brain.sensor.Sensor<? extends org.bukkit.entity.LivingEntity> paperSensor = null;
+
+    public io.papermc.paper.entity.brain.sensor.Sensor<? extends org.bukkit.entity.LivingEntity> getPaperSensor() {
+        if (this.paperSensor == null) {
+            this.paperSensor = new io.papermc.paper.entity.brain.sensor.PaperVanillaSensor(this);
+        }
+
+        return this.paperSensor;
+    }
+    // Paper end - mob goal api
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 61c2f864bb23e75f6c377f7ccbf2ec44a670348c..09c39a5c3fc8f4d64315ac13211ca8b08ab6b843 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -2890,5 +2890,19 @@ public final class CraftServer implements Server {
         return this.potionBrewer;
     }
 
+    @Override
+    public io.papermc.paper.entity.brain.activity.ActivityKey createActivityKey(NamespacedKey key) {
+        return io.papermc.paper.entity.brain.PaperBrainUtil.registerCustomActivityKey(key);
+    }
+
+    @Override
+    public io.papermc.paper.entity.brain.sensor.SensorKey createSensorKey(NamespacedKey key) {
+        return io.papermc.paper.entity.brain.PaperBrainUtil.registerCustomSensorKey(key);
+    }
+
+    @Override
+    public <C> org.bukkit.entity.memory.MemoryKey<C> registerMemoryKey(NamespacedKey key, io.leangen.geantyref.TypeToken<C> type, org.bukkit.persistence.PersistentDataType<C, ?> serializer) {
+        return io.papermc.paper.entity.brain.PaperBrainUtil.registerCustomMemoryKey(key, type, serializer);
+    }
     // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java
index c022751e3b45469cc0ad6732e2d6ff08918bafa4..3c03a8831fe5316f85ecab5492dabb18023c3541 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java
@@ -84,7 +84,7 @@ import org.bukkit.util.BlockIterator;
 import org.bukkit.util.RayTraceResult;
 import org.bukkit.util.Vector;
 
-public class CraftLivingEntity extends CraftEntity implements LivingEntity {
+public class CraftLivingEntity extends CraftEntity implements LivingEntity, io.papermc.paper.entity.brain.PaperBrainHolder<org.bukkit.entity.LivingEntity> { // Paper
     private CraftEntityEquipment equipment;
 
     public CraftLivingEntity(final CraftServer server, final net.minecraft.world.entity.LivingEntity entity) {
diff --git a/src/main/java/org/bukkit/entity/memory/PaperMemoryKey.java b/src/main/java/org/bukkit/entity/memory/PaperMemoryKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..7f7ece65e8645e3df1fab98b3a082e3e71ca0b3f
--- /dev/null
+++ b/src/main/java/org/bukkit/entity/memory/PaperMemoryKey.java
@@ -0,0 +1,13 @@
+package org.bukkit.entity.memory;
+
+import org.bukkit.NamespacedKey;
+
+public final class PaperMemoryKey {
+
+    private PaperMemoryKey() {
+    }
+
+    public static <T> MemoryKey<T> create(NamespacedKey key, Class<T> clazz) {
+        return new MemoryKey<>(key, clazz);
+    }
+}
diff --git a/src/test/java/io/papermc/paper/entity/brain/MissingBrainAPITest.java b/src/test/java/io/papermc/paper/entity/brain/MissingBrainAPITest.java
new file mode 100644
index 0000000000000000000000000000000000000000..99e68796afbd0b121adb55bb1a7580b3252f2ef3
--- /dev/null
+++ b/src/test/java/io/papermc/paper/entity/brain/MissingBrainAPITest.java
@@ -0,0 +1,57 @@
+package io.papermc.paper.entity.brain;
+
+import com.google.common.base.Joiner;
+import io.papermc.paper.entity.brain.activity.ActivityKey;
+import io.papermc.paper.entity.brain.activity.VanillaActivityKey;
+import io.papermc.paper.entity.brain.sensor.SensorKey;
+import io.papermc.paper.entity.brain.sensor.VanillaSensorKey;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.junit.Test;
+
+import java.lang.reflect.Field;
+import java.util.HashSet;
+import java.util.Set;
+
+import static org.junit.Assert.assertTrue;
+
+public class MissingBrainAPITest {
+
+    @Test
+    public void missingActivities() throws IllegalAccessException {
+        Set<NamespacedKey> activities = new HashSet<>();
+        for (ResourceLocation minecraftRegistered : Registry.ACTIVITY.keySet()) {
+            activities.add(CraftNamespacedKey.fromMinecraft(minecraftRegistered));
+        }
+
+        for (Field field : VanillaActivityKey.class.getDeclaredFields()) {
+            if (field.getType() == ActivityKey.class) {
+                activities.remove(((ActivityKey) field.get(null)).getKey());
+            }
+        }
+
+
+        assertTrue(ActivityKey.class.getName() + " instance(s): " + Joiner.on(", ").join(activities) + " do not have bukkit equivalents", activities.size() == 0);
+    }
+
+    @Test
+    public void missingSensors() throws IllegalAccessException {
+        Set<NamespacedKey> sensors = new HashSet<>();
+        for (ResourceLocation minecraftRegistered : Registry.SENSOR_TYPE.keySet()) {
+            sensors.add(CraftNamespacedKey.fromMinecraft(minecraftRegistered));
+        }
+        sensors.remove(NamespacedKey.minecraft("dummy"));
+
+        for (Field field : VanillaSensorKey.class.getDeclaredFields()) {
+            if (field.getType() == SensorKey.class) {
+                sensors.remove(((SensorKey) field.get(null)).getKey());
+            }
+        }
+
+
+        assertTrue(SensorKey.class.getName() + " instance(s): " + Joiner.on(", ").join(sensors) + " do not have bukkit equivalents", sensors.size() == 0);
+    }
+
+}
