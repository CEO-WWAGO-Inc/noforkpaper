From 8f444d74558ffbee056508ea69b0976c4806a94d Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Sun, 12 Apr 2020 20:46:37 -0700
Subject: [PATCH] fixup! MC Utils


diff --git a/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Int.java b/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Int.java
index 968c9ed32..59868f37d 100644
--- a/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Int.java
+++ b/src/main/java/com/destroystokyo/paper/util/map/QueuedChangesMapLong2Int.java
@@ -95,7 +95,7 @@ public class QueuedChangesMapLong2Int {
         while (iterator0.hasNext()) {
             final Long2IntMap.Entry entry = iterator0.next();
             final long key = entry.getLongKey();
-            final int val = entry.getValue();
+            final int val = entry.getIntValue();
 
             this.updatingMapSeqLock.acquireWrite();
             try {
@@ -105,6 +105,8 @@ public class QueuedChangesMapLong2Int {
             }
         }
 
+        this.queuedPuts.clear();
+
         final LongIterator iterator1 = this.queuedRemove.iterator();
         while (iterator1.hasNext()) {
             final long key = iterator1.nextLong();
@@ -117,6 +119,7 @@ public class QueuedChangesMapLong2Int {
             }
         }
 
+        this.queuedRemove.clear();
 
         return true;
     }
@@ -135,11 +138,13 @@ public class QueuedChangesMapLong2Int {
             while (iterator0.hasNext()) {
                 final Long2IntMap.Entry entry = iterator0.next();
                 final long key = entry.getLongKey();
-                final int val = entry.getValue();
+                final int val = entry.getIntValue();
 
                 this.visibleMap.put(key, val);
             }
 
+            this.queuedPuts.clear();
+
             final LongIterator iterator1 = this.queuedRemove.iterator();
             while (iterator1.hasNext()) {
                 final long key = iterator1.nextLong();
@@ -147,6 +152,7 @@ public class QueuedChangesMapLong2Int {
                 this.visibleMap.remove(key);
             }
 
+            this.queuedRemove.clear();
 
             return true;
         } finally {
diff --git a/src/main/java/com/destroystokyo/paper/util/maplist/ChunkList.java b/src/main/java/com/destroystokyo/paper/util/maplist/ChunkList.java
index 4ec248adb..4eac05778 100644
--- a/src/main/java/com/destroystokyo/paper/util/maplist/ChunkList.java
+++ b/src/main/java/com/destroystokyo/paper/util/maplist/ChunkList.java
@@ -13,12 +13,14 @@ import java.util.NoSuchElementException;
  */
 public final class ChunkList implements Iterable<Chunk> {
 
-    protected final Long2IntOpenHashMap chunkToIndex = new Long2IntOpenHashMap();
+    protected final Long2IntOpenHashMap chunkToIndex = new Long2IntOpenHashMap(2, 0.8f);
     {
         this.chunkToIndex.defaultReturnValue(Integer.MIN_VALUE);
     }
 
-    protected Chunk[] chunks = new Chunk[16];
+    protected static final Chunk[] EMPTY_LIST = new Chunk[0];
+
+    protected Chunk[] chunks = EMPTY_LIST;
     protected int count;
 
     public int size() {
@@ -26,11 +28,11 @@ public final class ChunkList implements Iterable<Chunk> {
     }
 
     public boolean contains(final Chunk chunk) {
-        return this.chunkToIndex.containsKey(MCUtil.getCoordinateKey(chunk.getPos()));
+        return this.chunkToIndex.containsKey(chunk.coordinateKey);
     }
 
     public boolean remove(final Chunk chunk) {
-        final int index = this.chunkToIndex.remove(MCUtil.getCoordinateKey(chunk.getPos()));
+        final int index = this.chunkToIndex.remove(chunk.coordinateKey);
         if (index == Integer.MIN_VALUE) {
             return false;
         }
@@ -40,7 +42,7 @@ public final class ChunkList implements Iterable<Chunk> {
         final Chunk end = this.chunks[endIndex];
         if (index != endIndex) {
             // not empty after this call
-            this.chunkToIndex.put(MCUtil.getCoordinateKey(end.getPos()), index); // update index
+            this.chunkToIndex.put(end.coordinateKey, index); // update index
         }
         this.chunks[index] = end;
         this.chunks[endIndex] = null;
@@ -50,7 +52,7 @@ public final class ChunkList implements Iterable<Chunk> {
 
     public boolean add(final Chunk chunk) {
         final int count = this.count;
-        final int currIndex = this.chunkToIndex.putIfAbsent(MCUtil.getCoordinateKey(chunk.getPos()), count);
+        final int currIndex = this.chunkToIndex.putIfAbsent(chunk.coordinateKey, count);
 
         if (currIndex != Integer.MIN_VALUE) {
             return false; // already in this list
@@ -60,7 +62,7 @@ public final class ChunkList implements Iterable<Chunk> {
 
         if (list.length == count) {
             // resize required
-            list = this.chunks = Arrays.copyOf(list, count * 2); // overflow results in negative
+            list = this.chunks = Arrays.copyOf(list, (int)Math.max(4L, count * 2L)); // overflow results in negative
         }
 
         list[count] = chunk;
diff --git a/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java b/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
index f3cb346c9..cdda74564 100644
--- a/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
+++ b/src/main/java/com/destroystokyo/paper/util/maplist/EntityList.java
@@ -12,12 +12,14 @@ import java.util.NoSuchElementException;
  */
 public final class EntityList implements Iterable<Entity> {
 
-    protected final Int2IntOpenHashMap entityToIndex = new Int2IntOpenHashMap();
+    protected final Int2IntOpenHashMap entityToIndex = new Int2IntOpenHashMap(2, 0.8f);
     {
         this.entityToIndex.defaultReturnValue(Integer.MIN_VALUE);
     }
 
-    protected Entity[] entities = new Entity[16];
+    protected static final Entity[] EMPTY_LIST = new Entity[0];
+
+    protected Entity[] entities = EMPTY_LIST;
     protected int count;
 
     public int size() {
@@ -59,7 +61,7 @@ public final class EntityList implements Iterable<Entity> {
 
         if (list.length == count) {
             // resize required
-            list = this.entities = Arrays.copyOf(list, count * 2); // overflow results in negative
+            list = this.entities = Arrays.copyOf(list, (int)Math.max(4L, count * 2L)); // overflow results in negative
         }
 
         list[count] = entity;
diff --git a/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java b/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java
index c2f7e4ca0..84ef8d9ec 100644
--- a/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java
+++ b/src/main/java/com/destroystokyo/paper/util/maplist/IBlockDataList.java
@@ -15,12 +15,14 @@ public final class IBlockDataList {
     static final DataPaletteGlobal<IBlockData> GLOBAL_PALETTE = (DataPaletteGlobal)ChunkSection.GLOBAL_PALETTE;
 
     // map of location -> (index | (location << 16) | (palette id << 32))
-    private final Short2LongOpenHashMap map = new Short2LongOpenHashMap(16, 0.7f);
+    private final Short2LongOpenHashMap map = new Short2LongOpenHashMap(2, 0.8f);
     {
         this.map.defaultReturnValue(Long.MAX_VALUE);
     }
 
-    private long[] byIndex = new long[16];
+    private static final long[] EMPTY_LIST = new long[0];
+
+    private long[] byIndex = EMPTY_LIST;
     private int size;
 
     public static int getLocationKey(final int x, final int y, final int z) {
@@ -60,7 +62,7 @@ public final class IBlockDataList {
             this.map.put((short)location, raw);
 
             if (index >= this.byIndex.length) {
-                this.byIndex = Arrays.copyOf(this.byIndex, this.byIndex.length * 2);
+                this.byIndex = Arrays.copyOf(this.byIndex, (int)Math.max(4L, this.byIndex.length * 2L));
             }
 
             this.byIndex[index] = raw;
diff --git a/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java b/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
index 5a44bc644..f625da9f0 100644
--- a/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
+++ b/src/main/java/com/destroystokyo/paper/util/misc/AreaMap.java
@@ -1,5 +1,6 @@
 package com.destroystokyo.paper.util.misc;
 
+import com.destroystokyo.paper.util.math.IntegerUtil;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
@@ -10,15 +11,13 @@ import net.minecraft.server.MinecraftServer;
 import javax.annotation.Nullable;
 import java.util.Iterator;
 
-/**
- * @author Spottedleaf
- */
+/** @author Spottedleaf */
 public abstract class AreaMap<E> {
 
     /* Tested via https://gist.github.com/Spottedleaf/520419c6f41ef348fe9926ce674b7217 */
 
-    private final Object2LongOpenHashMap<E> objectToLastCoordinate = new Object2LongOpenHashMap<>();
-    private final Object2IntOpenHashMap<E> objectToViewDistance = new Object2IntOpenHashMap<>();
+    protected final Object2LongOpenHashMap<E> objectToLastCoordinate = new Object2LongOpenHashMap<>();
+    protected final Object2IntOpenHashMap<E> objectToViewDistance = new Object2IntOpenHashMap<>();
 
     {
         this.objectToViewDistance.defaultReturnValue(-1);
@@ -27,11 +26,11 @@ public abstract class AreaMap<E> {
 
     // we use linked for better iteration.
     // map of: coordinate to set of objects in coordinate
-    private final Long2ObjectOpenHashMap<PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E>> areaMap = new Long2ObjectOpenHashMap<>(1024, 0.3f);
-    private final PooledLinkedHashSets<E> pooledHashSets;
+    protected final Long2ObjectOpenHashMap<PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E>> areaMap = new Long2ObjectOpenHashMap<>(1024, 0.7f);
+    protected final PooledLinkedHashSets<E> pooledHashSets;
 
-    private final ChangeCallback<E> addCallback;
-    private final ChangeCallback<E> removeCallback;
+    protected final ChangeCallback<E> addCallback;
+    protected final ChangeCallback<E> removeCallback;
 
     public AreaMap() {
         this(new PooledLinkedHashSets<>());
@@ -49,48 +48,57 @@ public abstract class AreaMap<E> {
     }
 
     @Nullable
-    public PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> getObjectsInRange(final long key) {
+    public final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> getObjectsInRange(final long key) {
         return this.areaMap.get(key);
     }
 
     @Nullable
-    public PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> getObjectsInRange(final ChunkCoordIntPair chunkPos) {
-        return this.getObjectsInRange(chunkPos.x, chunkPos.z);
+    public final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> getObjectsInRange(final ChunkCoordIntPair chunkPos) {
+        return this.areaMap.get(MCUtil.getCoordinateKey(chunkPos));
     }
 
     @Nullable
-    public PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> getObjectsInRange(final int chunkX, final int chunkZ) {
-        return this.getObjectsInRange(MCUtil.getCoordinateKey(chunkX, chunkZ));
+    public final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> getObjectsInRange(final int chunkX, final int chunkZ) {
+        return this.areaMap.get(MCUtil.getCoordinateKey(chunkX, chunkZ));
     }
 
     // Long.MIN_VALUE indicates the object is not mapped
-    public long getLastCoordinate(final E object) {
+    public final long getLastCoordinate(final E object) {
         return this.objectToLastCoordinate.getOrDefault(object, Long.MIN_VALUE);
     }
 
     // -1 indicates the object is not mapped
-    public int getLastViewDistance(final E object) {
+    public final int getLastViewDistance(final E object) {
         return this.objectToViewDistance.getOrDefault(object, -1);
     }
 
     // returns the total number of mapped chunks
-    public int size() {
+    public final int size() {
         return this.areaMap.size();
     }
 
-    public void update(final E object, final int chunkX, final int chunkZ, final int viewDistance) {
-        final int oldDistance = this.objectToViewDistance.put(object, viewDistance);
+    public final void update(final E object, final int chunkX, final int chunkZ, final int viewDistance) {
+        final int oldViewDistance = this.objectToViewDistance.put(object, viewDistance);
         final long newPos = MCUtil.getCoordinateKey(chunkX, chunkZ);
-        if (oldDistance == -1) {
+        if (oldViewDistance == -1) {
             this.objectToLastCoordinate.put(object, newPos);
             this.addObject(object, chunkX, chunkZ, Integer.MIN_VALUE, Integer.MIN_VALUE, viewDistance);
+            this.addObjectCallback(object, chunkX, chunkZ, viewDistance);
         } else {
-            this.updateObject(object, this.objectToLastCoordinate.put(object, newPos), newPos, oldDistance, viewDistance);
+            final long oldPos = this.objectToLastCoordinate.put(object, newPos);
+            this.updateObject(object, oldPos, newPos, oldViewDistance, viewDistance);
+            this.updateObjectCallback(object, oldPos, newPos, oldViewDistance, viewDistance);
         }
         //this.validate(object, viewDistance);
     }
 
-    public boolean remove(final E object) {
+    // called after the distance map updates
+    protected void addObjectCallback(final E object, final int chunkX, final int chunkZ, final int viewDistance) {}
+
+    // called after the distance map updates
+    protected void updateObjectCallback(final E Object, final long oldPosition, final long newPosition, final int oldViewDistance, final int newViewDistance) {}
+
+    public final boolean remove(final E object) {
         final long position = this.objectToLastCoordinate.removeLong(object);
         final int viewDistance = this.objectToViewDistance.removeInt(object);
 
@@ -102,14 +110,18 @@ public abstract class AreaMap<E> {
         final int currentZ = MCUtil.getCoordinateZ(position);
 
         this.removeObject(object, currentX, currentZ, currentX, currentZ, viewDistance);
+        this.removeObjectCallback(object, currentX, currentZ, viewDistance);
         //this.validate(object, -1);
         return true;
     }
 
+    // called after the distance map updates
+    protected void removeObjectCallback(final E object, final int chunkX, final int chunkZ, final int viewDistance) {}
+
     protected abstract PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> getEmptySetFor(final E object);
 
     // expensive op, only for debug
-    private void validate(final E object, final int viewDistance) {
+    protected void validate(final E object, final int viewDistance) {
         int entiesGot = 0;
         int expectedEntries = (2 * viewDistance + 1);
         expectedEntries *= expectedEntries;
@@ -139,7 +151,7 @@ public abstract class AreaMap<E> {
                 final int chunkX = MCUtil.getCoordinateX(key);
                 final int chunkZ = MCUtil.getCoordinateZ(key);
 
-                final int dist = Math.max(Math.abs(chunkX - centerX), Math.abs(chunkZ - centerZ));
+                final int dist = Math.max(IntegerUtil.branchlessAbs(chunkX - centerX), IntegerUtil.branchlessAbs(chunkZ - centerZ));
 
                 if (dist > viewDistance) {
                     throw new IllegalStateException("Expected view distance " + viewDistance + ", got " + dist);
@@ -152,8 +164,8 @@ public abstract class AreaMap<E> {
         }
     }
 
-    protected final void addObjectTo(final E object, final int chunkX, final int chunkZ, final int currChunkX,
-                                     final int currChunkZ, final int prevChunkX, final int prevChunkZ) {
+    private void addObjectTo(final E object, final int chunkX, final int chunkZ, final int currChunkX,
+                             final int currChunkZ, final int prevChunkX, final int prevChunkZ) {
         final long key = MCUtil.getCoordinateKey(chunkX, chunkZ);
 
         PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> empty = this.getEmptySetFor(object);
@@ -184,8 +196,8 @@ public abstract class AreaMap<E> {
         }
     }
 
-    protected final void removeObjectFrom(final E object, final int chunkX, final int chunkZ, final int currChunkX,
-                                          final int currChunkZ, final int prevChunkX, final int prevChunkZ) {
+    private void removeObjectFrom(final E object, final int chunkX, final int chunkZ, final int currChunkX,
+                                  final int currChunkZ, final int prevChunkX, final int prevChunkZ) {
         final long key = MCUtil.getCoordinateKey(chunkX, chunkZ);
 
         PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> current = this.areaMap.get(key);
@@ -221,8 +233,10 @@ public abstract class AreaMap<E> {
     private void addObject(final E object, final int chunkX, final int chunkZ, final int prevChunkX, final int prevChunkZ, final int viewDistance) {
         final int maxX = chunkX + viewDistance;
         final int maxZ = chunkZ + viewDistance;
-        for (int x = chunkX - viewDistance; x <= maxX; ++x) {
-            for (int z = chunkZ - viewDistance; z <= maxZ; ++z) {
+        final int minX = chunkX - viewDistance;
+        final int minZ = chunkZ - viewDistance;
+        for (int x = minX; x <= maxX; ++x) {
+            for (int z = minZ; z <= maxZ; ++z) {
                 this.addObjectTo(object, x, z, chunkX, chunkZ, prevChunkX, prevChunkZ);
             }
         }
@@ -231,8 +245,10 @@ public abstract class AreaMap<E> {
     private void removeObject(final E object, final int chunkX, final int chunkZ, final int currentChunkX, final int currentChunkZ, final int viewDistance) {
         final int maxX = chunkX + viewDistance;
         final int maxZ = chunkZ + viewDistance;
-        for (int x = chunkX - viewDistance; x <= maxX; ++x) {
-            for (int z = chunkZ - viewDistance; z <= maxZ; ++z) {
+        final int minX = chunkX - viewDistance;
+        final int minZ = chunkZ - viewDistance;
+        for (int x = minX; x <= maxX; ++x) {
+            for (int z = minZ; z <= maxZ; ++z) {
                 this.removeObjectFrom(object, x, z, currentChunkX, currentChunkZ, chunkX, chunkZ);
             }
         }
@@ -243,7 +259,7 @@ public abstract class AreaMap<E> {
         return 1 | (val >> (Integer.SIZE - 1));
     }
 
-    protected final void updateObject(final E object, final long oldPosition, final long newPosition, final int oldViewDistance, final int newViewDistance) {
+    private void updateObject(final E object, final long oldPosition, final long newPosition, final int oldViewDistance, final int newViewDistance) {
         final int toX = MCUtil.getCoordinateX(newPosition);
         final int toZ = MCUtil.getCoordinateZ(newPosition);
         final int fromX = MCUtil.getCoordinateX(oldPosition);
@@ -252,8 +268,8 @@ public abstract class AreaMap<E> {
         final int dx = toX - fromX;
         final int dz = toZ - fromZ;
 
-        final int totalX = Math.abs(fromX - toX);
-        final int totalZ = Math.abs(fromZ - toZ);
+        final int totalX = IntegerUtil.branchlessAbs(fromX - toX);
+        final int totalZ = IntegerUtil.branchlessAbs(fromZ - toZ);
 
         if (Math.max(totalX, totalZ) > (2 * Math.max(newViewDistance, oldViewDistance))) {
             // teleported?
@@ -265,13 +281,15 @@ public abstract class AreaMap<E> {
         if (oldViewDistance != newViewDistance) {
             // remove loop
 
+            final int oldMinX = fromX - oldViewDistance;
+            final int oldMinZ = fromZ - oldViewDistance;
             final int oldMaxX = fromX + oldViewDistance;
             final int oldMaxZ = fromZ + oldViewDistance;
-            for (int currX = fromX - oldViewDistance; currX <= oldMaxX; ++currX) {
-                for (int currZ = fromZ - oldViewDistance; currZ <= oldMaxZ; ++currZ) {
+            for (int currX = oldMinX; currX <= oldMaxX; ++currX) {
+                for (int currZ = oldMinZ; currZ <= oldMaxZ; ++currZ) {
 
                     // only remove if we're outside the new view distance...
-                    if (Math.max(Math.abs(currX - toX), Math.abs(currZ - toZ)) > newViewDistance) {
+                    if (Math.max(IntegerUtil.branchlessAbs(currX - toX), IntegerUtil.branchlessAbs(currZ - toZ)) > newViewDistance) {
                         this.removeObjectFrom(object, currX, currZ, toX, toZ, fromX, fromZ);
                     }
                 }
@@ -279,13 +297,15 @@ public abstract class AreaMap<E> {
 
             // add loop
 
+            final int newMinX = toX - newViewDistance;
+            final int newMinZ = toZ - newViewDistance;
             final int newMaxX = toX + newViewDistance;
             final int newMaxZ = toZ + newViewDistance;
-            for (int currX = toX - newViewDistance; currX <= newMaxX; ++currX) {
-                for (int currZ = toZ - newViewDistance; currZ <= newMaxZ; ++currZ) {
+            for (int currX = newMinX; currX <= newMaxX; ++currX) {
+                for (int currZ = newMinZ; currZ <= newMaxZ; ++currZ) {
 
                     // only add if we're outside the old view distance...
-                    if (Math.max(Math.abs(currX - fromX), Math.abs(currZ - fromZ)) > oldViewDistance) {
+                    if (Math.max(IntegerUtil.branchlessAbs(currX - fromX), IntegerUtil.branchlessAbs(currZ - fromZ)) > oldViewDistance) {
                         this.addObjectTo(object, currX, currZ, toX, toZ, fromX, fromZ);
                     }
                 }
diff --git a/src/main/java/com/destroystokyo/paper/util/misc/DistanceTrackingAreaMap.java b/src/main/java/com/destroystokyo/paper/util/misc/DistanceTrackingAreaMap.java
new file mode 100644
index 000000000..3f86c1ad4
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/misc/DistanceTrackingAreaMap.java
@@ -0,0 +1,175 @@
+package com.destroystokyo.paper.util.misc;
+
+import com.destroystokyo.paper.util.math.IntegerUtil;
+import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.MCUtil;
+
+/** @author Spottedleaf */
+public abstract class DistanceTrackingAreaMap<E> extends AreaMap<E> {
+
+    // use this map only if you need distance tracking, the tracking here is obviously going to hit harder.
+
+    protected final Long2IntOpenHashMap chunkToNearestDistance = new Long2IntOpenHashMap(1024, 0.7f);
+    {
+        this.chunkToNearestDistance.defaultReturnValue(-1);
+    }
+
+    protected final DistanceChangeCallback<E> distanceChangeCallback;
+
+    public DistanceTrackingAreaMap() {
+        this(new PooledLinkedHashSets<>());
+    }
+
+    // let users define a "global" or "shared" pooled sets if they wish
+    public DistanceTrackingAreaMap(final PooledLinkedHashSets<E> pooledHashSets) {
+        this(pooledHashSets, null, null, null);
+    }
+
+    public DistanceTrackingAreaMap(final PooledLinkedHashSets<E> pooledHashSets, final ChangeCallback<E> addCallback, final ChangeCallback<E> removeCallback,
+                                   final DistanceChangeCallback<E> distanceChangeCallback) {
+        super(pooledHashSets, addCallback, removeCallback);
+        this.distanceChangeCallback = distanceChangeCallback;
+    }
+
+    // ret -1 if there is nothing mapped
+    public final int getNearestObjectDistance(final long key) {
+        return this.chunkToNearestDistance.get(key);
+    }
+
+    // ret -1 if there is nothing mapped
+    public final int getNearestObjectDistance(final ChunkCoordIntPair chunkPos) {
+        return this.chunkToNearestDistance.get(MCUtil.getCoordinateKey(chunkPos));
+    }
+
+    // ret -1 if there is nothing mapped
+    public final int getNearestObjectDistance(final int chunkX, final int chunkZ) {
+        return this.chunkToNearestDistance.get(MCUtil.getCoordinateKey(chunkX, chunkZ));
+    }
+
+    protected final void recalculateDistance(final int chunkX, final int chunkZ) {
+        final long key = MCUtil.getCoordinateKey(chunkX, chunkZ);
+        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> state = this.areaMap.get(key);
+        if (state == null) {
+            final int oldDistance = this.chunkToNearestDistance.remove(key);
+            // nothing here.
+            if (oldDistance == -1) {
+                // nothing was here previously
+                return;
+            }
+            if (this.distanceChangeCallback != null) {
+                this.distanceChangeCallback.accept(chunkX, chunkZ, oldDistance, -1, null);
+            }
+            return;
+        }
+
+        int newDistance = Integer.MAX_VALUE;
+
+        final Object[] rawData = state.getBackingSet();
+        for (int i = 0, len = rawData.length; i < len; ++i) {
+            final Object raw = rawData[i];
+
+            if (raw == null) {
+                continue;
+            }
+
+            final E object = (E)raw;
+            final long location = this.objectToLastCoordinate.getLong(object);
+
+            final int distance = Math.max(IntegerUtil.branchlessAbs(chunkX - MCUtil.getCoordinateX(location)), IntegerUtil.branchlessAbs(chunkZ - MCUtil.getCoordinateZ(location)));
+
+            if (distance < newDistance) {
+                newDistance = distance;
+            }
+        }
+
+        final int oldDistance = this.chunkToNearestDistance.put(key, newDistance);
+
+        if (oldDistance != newDistance) {
+            if (this.distanceChangeCallback != null) {
+                this.distanceChangeCallback.accept(chunkX, chunkZ, oldDistance, newDistance, state);
+            }
+        }
+    }
+
+    @Override
+    protected void addObjectCallback(final E object, final int chunkX, final int chunkZ, final int viewDistance) {
+        final int maxX = chunkX + viewDistance;
+        final int maxZ = chunkZ + viewDistance;
+        final int minX = chunkX - viewDistance;
+        final int minZ = chunkZ - viewDistance;
+        for (int x = minX; x <= maxX; ++x) {
+            for (int z = minZ; z <= maxZ; ++z) {
+                this.recalculateDistance(x, z);
+            }
+        }
+    }
+
+    @Override
+    protected void removeObjectCallback(final E object, final int chunkX, final int chunkZ, final int viewDistance) {
+        final int maxX = chunkX + viewDistance;
+        final int maxZ = chunkZ + viewDistance;
+        final int minX = chunkX - viewDistance;
+        final int minZ = chunkZ - viewDistance;
+        for (int x = minX; x <= maxX; ++x) {
+            for (int z = minZ; z <= maxZ; ++z) {
+                this.recalculateDistance(x, z);
+            }
+        }
+    }
+
+    @Override
+    protected void updateObjectCallback(final E object, final long oldPosition, final long newPosition, final int oldViewDistance, final int newViewDistance) {
+        if (oldPosition == newPosition && newViewDistance == oldViewDistance) {
+            return;
+        }
+
+        final int toX = MCUtil.getCoordinateX(newPosition);
+        final int toZ = MCUtil.getCoordinateZ(newPosition);
+        final int fromX = MCUtil.getCoordinateX(oldPosition);
+        final int fromZ = MCUtil.getCoordinateZ(oldPosition);
+
+        final int totalX = IntegerUtil.branchlessAbs(fromX - toX);
+        final int totalZ = IntegerUtil.branchlessAbs(fromZ - toZ);
+
+        if (Math.max(totalX, totalZ) > (2 * Math.max(newViewDistance, oldViewDistance))) {
+            // teleported?
+            this.removeObjectCallback(object, fromX, fromZ, oldViewDistance);
+            this.addObjectCallback(object, toX, toZ, newViewDistance);
+            return;
+        }
+
+        final int minX = Math.min(fromX - oldViewDistance, toX - newViewDistance);
+        final int maxX = Math.max(fromX + oldViewDistance, toX + newViewDistance);
+        final int minZ = Math.min(fromZ - oldViewDistance, toZ - newViewDistance);
+        final int maxZ = Math.max(fromZ + oldViewDistance, toZ + newViewDistance);
+
+        for (int x = minX; x <= maxX; ++x) {
+            for (int z = minZ; z <= maxZ; ++z) {
+                final int distXOld = IntegerUtil.branchlessAbs(x - fromX);
+                final int distZOld = IntegerUtil.branchlessAbs(z - fromZ);
+
+                if (Math.max(distXOld, distZOld) <= oldViewDistance) {
+                    this.recalculateDistance(x, z);
+                    continue;
+                }
+
+                final int distXNew = IntegerUtil.branchlessAbs(x - toX);
+                final int distZNew = IntegerUtil.branchlessAbs(z - toZ);
+
+                if (Math.max(distXNew, distZNew) <= newViewDistance) {
+                    this.recalculateDistance(x, z);
+                    continue;
+                }
+            }
+        }
+    }
+
+    @FunctionalInterface
+    public static interface DistanceChangeCallback<E> {
+
+        void accept(final int posX, final int posZ, final int oldNearestDistance, final int newNearestDistance,
+                    final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<E> state);
+
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/misc/PlayerDistanceTrackingAreaMap.java b/src/main/java/com/destroystokyo/paper/util/misc/PlayerDistanceTrackingAreaMap.java
new file mode 100644
index 000000000..0292afc52
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/misc/PlayerDistanceTrackingAreaMap.java
@@ -0,0 +1,24 @@
+package com.destroystokyo.paper.util.misc;
+
+import net.minecraft.server.EntityPlayer;
+
+public class PlayerDistanceTrackingAreaMap extends DistanceTrackingAreaMap<EntityPlayer> {
+
+    public PlayerDistanceTrackingAreaMap() {
+        super();
+    }
+
+    public PlayerDistanceTrackingAreaMap(final PooledLinkedHashSets<EntityPlayer> pooledHashSets) {
+        super(pooledHashSets);
+    }
+
+    public PlayerDistanceTrackingAreaMap(final PooledLinkedHashSets<EntityPlayer> pooledHashSets, final ChangeCallback<EntityPlayer> addCallback,
+                                         final ChangeCallback<EntityPlayer> removeCallback, final DistanceChangeCallback<EntityPlayer> distanceChangeCallback) {
+        super(pooledHashSets, addCallback, removeCallback, distanceChangeCallback);
+    }
+
+    @Override
+    protected PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> getEmptySetFor(final EntityPlayer player) {
+        return player.cachedSingleHashSet;
+    }
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/misc/PooledLinkedHashSets.java b/src/main/java/com/destroystokyo/paper/util/misc/PooledLinkedHashSets.java
index 5f2d88797..e51104e65 100644
--- a/src/main/java/com/destroystokyo/paper/util/misc/PooledLinkedHashSets.java
+++ b/src/main/java/com/destroystokyo/paper/util/misc/PooledLinkedHashSets.java
@@ -4,9 +4,7 @@ import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import java.lang.ref.WeakReference;
 
-/**
- * @author Spottedleaf
- */
+/** @author Spottedleaf */
 public class PooledLinkedHashSets<E> {
 
     /* Tested via https://gist.github.com/Spottedleaf/a93bb7a8993d6ce142d3efc5932bf573 */
diff --git a/src/main/java/net/minecraft/server/AxisAlignedBB.java b/src/main/java/net/minecraft/server/AxisAlignedBB.java
index c950139c0..3fdb52007 100644
--- a/src/main/java/net/minecraft/server/AxisAlignedBB.java
+++ b/src/main/java/net/minecraft/server/AxisAlignedBB.java
@@ -193,6 +193,7 @@ public class AxisAlignedBB {
         return this.d(vec3d.x, vec3d.y, vec3d.z);
     }
 
+    public final boolean intersects(AxisAlignedBB axisalignedbb) { return this.c(axisalignedbb); } // Paper - OBFHELPER
     public boolean c(AxisAlignedBB axisalignedbb) {
         return this.a(axisalignedbb.minX, axisalignedbb.minY, axisalignedbb.minZ, axisalignedbb.maxX, axisalignedbb.maxY, axisalignedbb.maxZ);
     }
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 2b0e43187..719c6f3e7 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -160,6 +160,88 @@ public class Chunk implements IChunkAccess {
     // Paper start
     public final com.destroystokyo.paper.util.maplist.EntityList entities = new com.destroystokyo.paper.util.maplist.EntityList();
     public PlayerChunk playerChunk;
+
+    static final int NEIGHBOUR_CACHE_RADIUS = 3;
+    public static int getNeighbourCacheRadius() {
+        return NEIGHBOUR_CACHE_RADIUS;
+    }
+
+    boolean loadedTicketLevel;
+    private long neighbourChunksLoadedBitset;
+    private final Chunk[] loadedNeighbourChunks = new Chunk[(NEIGHBOUR_CACHE_RADIUS * 2 + 1) * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)];
+
+    private static int getNeighbourIndex(final int relativeX, final int relativeZ) {
+        // index = (relativeX + NEIGHBOUR_CACHE_RADIUS) + (relativeZ + NEIGHBOUR_CACHE_RADIUS) * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)
+        // optimised variant of the above by moving some of the ops to compile time
+        return relativeX + (relativeZ * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)) + (NEIGHBOUR_CACHE_RADIUS + NEIGHBOUR_CACHE_RADIUS * ((NEIGHBOUR_CACHE_RADIUS * 2 + 1)));
+    }
+
+    public final Chunk getRelativeNeighbourIfLoaded(final int relativeX, final int relativeZ) {
+        return this.loadedNeighbourChunks[getNeighbourIndex(relativeX, relativeZ)];
+    }
+
+    public final boolean isNeighbourLoaded(final int relativeX, final int relativeZ) {
+        return (this.neighbourChunksLoadedBitset & (1L << getNeighbourIndex(relativeX, relativeZ))) != 0;
+    }
+
+    public final void setNeighbourLoaded(final int relativeX, final int relativeZ, final Chunk chunk) {
+        if (chunk == null) {
+            throw new IllegalArgumentException("Chunk must be non-null, neighbour: (" + relativeX + "," + relativeZ + "), chunk: " + this.loc);
+        }
+        final int index = getNeighbourIndex(relativeX, relativeZ);
+        this.loadedNeighbourChunks[index] = chunk;
+        this.neighbourChunksLoadedBitset |= (1L << index);
+    }
+
+    public final void setNeighbourUnloaded(final int relativeX, final int relativeZ) {
+        final int index = getNeighbourIndex(relativeX, relativeZ);
+        this.loadedNeighbourChunks[index] = null;
+        this.neighbourChunksLoadedBitset &= ~(1L << index);
+    }
+
+    public final void resetNeighbours() {
+        this.neighbourChunksLoadedBitset = 0L;
+        java.util.Arrays.fill(this.loadedNeighbourChunks, null);
+    }
+
+    public final boolean areNeighboursLoaded(final int radius) {
+        // index = relativeX + (relativeZ * (NEIGHBOUR_CACHE_RADIUS * 2 + 1)) + (NEIGHBOUR_CACHE_RADIUS + NEIGHBOUR_CACHE_RADIUS * ((NEIGHBOUR_CACHE_RADIUS * 2 + 1)))
+        switch (radius) {
+            case 0: {
+                return this.loadedTicketLevel;
+            }
+            case 1: {
+                long mask = 0L;
+                for (int dx = -1; dx <= 1; ++dx) {
+                    for (int dz = -1; dz <= 1; ++dz) {
+                        mask |= (1L << getNeighbourIndex(dx, dz));
+                    }
+                }
+                return (this.neighbourChunksLoadedBitset & mask) == mask;
+            }
+            case 2: {
+                long mask = 0L;
+                for (int dx = -2; dx <= 2; ++dx) {
+                    for (int dz = -2; dz <= 2; ++dz) {
+                        mask |= (1L << getNeighbourIndex(dx, dz));
+                    }
+                }
+                return (this.neighbourChunksLoadedBitset & mask) == mask;
+            }
+            case 3: {
+                long mask = 0L;
+                for (int dx = -3; dx <= 3; ++dx) {
+                    for (int dz = -3; dz <= 3; ++dz) {
+                        mask |= (1L << getNeighbourIndex(dx, dz));
+                    }
+                }
+                return (this.neighbourChunksLoadedBitset & mask) == mask;
+            }
+
+            default:
+                throw new IllegalArgumentException("Radius not recognized: " + radius);
+        }
+    }
     // Paper end
 
     public Chunk(World world, ProtoChunk protochunk) {
@@ -654,6 +736,23 @@ public class Chunk implements IChunkAccess {
 
     // CraftBukkit start
     public void loadCallback() {
+        // Paper start - neighbour cache
+        int chunkX = this.loc.x;
+        int chunkZ = this.loc.z;
+        ChunkProviderServer chunkProvider = ((WorldServer)this.world).getChunkProvider();
+        for (int dx = -NEIGHBOUR_CACHE_RADIUS; dx <= NEIGHBOUR_CACHE_RADIUS; ++dx) {
+            for (int dz = -NEIGHBOUR_CACHE_RADIUS; dz <= NEIGHBOUR_CACHE_RADIUS; ++dz) {
+                Chunk neighbour = chunkProvider.getChunkAtIfLoadedMainThreadNoCache(chunkX + dx, chunkZ + dz);
+                if (neighbour != null) {
+                    neighbour.setNeighbourLoaded(-dx, -dz, this);
+                    // should be in cached already
+                    this.setNeighbourLoaded(dx, dz, neighbour);
+                }
+            }
+        }
+        this.setNeighbourLoaded(0, 0, this);
+        this.loadedTicketLevel = true;
+        // Paper end - neighbour cache
         org.bukkit.Server server = this.world.getServer();
         ((WorldServer)this.world).getChunkProvider().addLoadedChunk(this); // Paper
         if (server != null) {
@@ -697,6 +796,21 @@ public class Chunk implements IChunkAccess {
         // note: saving can be prevented, but not forced if no saving is actually required
         this.mustNotSave = !unloadEvent.isSaveChunk();
         ((WorldServer)this.world).getChunkProvider().removeLoadedChunk(this); // Paper
+        // Paper start - neighbour cache
+        int chunkX = this.loc.x;
+        int chunkZ = this.loc.z;
+        ChunkProviderServer chunkProvider = ((WorldServer)this.world).getChunkProvider();
+        for (int dx = -NEIGHBOUR_CACHE_RADIUS; dx <= NEIGHBOUR_CACHE_RADIUS; ++dx) {
+            for (int dz = -NEIGHBOUR_CACHE_RADIUS; dz <= NEIGHBOUR_CACHE_RADIUS; ++dz) {
+                Chunk neighbour = chunkProvider.getChunkAtIfLoadedMainThreadNoCache(chunkX + dx, chunkZ + dz);
+                if (neighbour != null) {
+                    neighbour.setNeighbourUnloaded(-dx, -dz);
+                }
+            }
+        }
+        this.loadedTicketLevel = false;
+        this.resetNeighbours();
+        // Paper end
     }
     // CraftBukkit end
 
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index 9980e4c27..ffaf496ee 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -38,12 +38,18 @@ public final class MCUtil {
 
     public static final long INVALID_CHUNK_KEY = getCoordinateKey(Integer.MAX_VALUE, Integer.MAX_VALUE);
 
+    public static void ensureTickThread(final String reason) {
+        if (MinecraftServer.getServer().serverThread != Thread.currentThread()) {
+            throw new IllegalStateException(reason);
+        }
+    }
+
     public static long getCoordinateKey(final BlockPosition blockPos) {
-        return getCoordinateKey(blockPos.getX() >> 4, blockPos.getZ() >> 4);
+        return ((long)(blockPos.getZ() >> 4) << 32) | ((blockPos.getX() >> 4) & 0xFFFFFFFFL);
     }
 
     public static long getCoordinateKey(final Entity entity) {
-        return getCoordinateKey(getChunkCoordinate(entity.locX()), getChunkCoordinate(entity.locZ()));
+        return ((long)(MCUtil.fastFloor(entity.locZ()) >> 4) << 32) | ((MCUtil.fastFloor(entity.locX()) >> 4) & 0xFFFFFFFFL);
     }
 
     public static int fastFloor(double x) {
@@ -57,7 +63,7 @@ public final class MCUtil {
     }
 
     public static long getCoordinateKey(final ChunkCoordIntPair pair) {
-        return getCoordinateKey(pair.x, pair.z);
+        return ((long)pair.z << 32) | (pair.x & 0xFFFFFFFFL);
     }
 
     public static long getCoordinateKey(final int x, final int z) {
@@ -85,7 +91,7 @@ public final class MCUtil {
     }
 
     public static long getBlockKey(final BlockPosition pos) {
-        return getBlockKey(pos.getX(), pos.getY(), pos.getZ());
+        return ((long)pos.getX() & 0x7FFFFFF) | (((long)pos.getZ() & 0x7FFFFFF) << 27) | ((long)pos.getY() << 54);
     }
 
     public static long getBlockKey(final Entity entity) {
-- 
2.26.0

