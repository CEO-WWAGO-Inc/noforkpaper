From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Mark Vainomaa <mikroskeem@mikroskeem.eu>
Date: Wed, 12 Sep 2018 18:53:55 +0300
Subject: [PATCH] Implement an API for CanPlaceOn and CanDestroy NBT values


diff --git a/src/main/java/org/bukkit/craftbukkit/block/data/CraftBlockData.java b/src/main/java/org/bukkit/craftbukkit/block/data/CraftBlockData.java
index 8ec78b26d6bfbcdad443c9649e35f79dd336b095..43afedc7bbd7f420e6bb7647d2cba0c9a3d7f1e6 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/data/CraftBlockData.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/data/CraftBlockData.java
@@ -32,7 +32,7 @@ import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 public class CraftBlockData implements BlockData {
 
     private BlockState state;
-    private Map<Property<?>, Comparable<?>> parsedStates;
+    public Map<Property<?>, Comparable<?>> parsedStates; // Paper private -> public
 
     protected CraftBlockData() {
         throw new AssertionError("Template Constructor");
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
index 01ceb8de8411193fa407bf19bbd25a4bf44765d3..c5e4a8942ac96ab8c37dabe42e76fb09c5cb9c55 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
@@ -83,6 +83,12 @@ import org.bukkit.persistence.PersistentDataContainer;
 import static org.spigotmc.ValidateUtils.*;
 // Spigot end
 
+// Paper start
+import com.destroystokyo.paper.Namespaced;
+import com.destroystokyo.paper.NamespacedTag;
+import java.util.Collections;
+// Paper end
+
 /**
  * Children must include the following:
  *
@@ -268,6 +274,10 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     @Specific(Specific.To.NBT)
     static final ItemMetaKey BLOCK_DATA = new ItemMetaKey("BlockStateTag");
     static final ItemMetaKey BUKKIT_CUSTOM_TAG = new ItemMetaKey("PublicBukkitValues");
+    // Paper start - Implement an API for CanPlaceOn and CanDestroy NBT values
+    static final ItemMetaKey CAN_DESTROY = new ItemMetaKey("CanDestroy");
+    static final ItemMetaKey CAN_PLACE_ON = new ItemMetaKey("CanPlaceOn");
+    // Paper end
 
     // We store the raw original JSON representation of all text data. See SPIGOT-5063, SPIGOT-5656, SPIGOT-5304
     private String displayName;
@@ -281,6 +291,12 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     private int hideFlag;
     private boolean unbreakable;
     private int damage;
+    // Paper start - Implement an API for CanPlaceOn and CanDestroy NBT values
+    private Set<NamespacedTag> placeableTags = Sets.newHashSet();
+    private Set<NamespacedTag> destroyableTags = Sets.newHashSet();
+    private Set<BlockData> placeableDatas = Sets.newHashSet();
+    private Set<BlockData> destroyableDatas = Sets.newHashSet();
+    // Paper end
 
     private static final Set<String> HANDLED_TAGS = Sets.newHashSet();
     private static final CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new CraftPersistentDataTypeRegistry();
@@ -318,6 +334,21 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         this.hideFlag = meta.hideFlag;
         this.unbreakable = meta.unbreakable;
         this.damage = meta.damage;
+        // Paper start - Implement an API for CanPlaceOn and CanDestroy NBT values
+        if (meta.placeableTags != null && !meta.placeableTags.isEmpty()) {
+            this.placeableTags = new java.util.HashSet<>(meta.placeableTags);
+        }
+        if (meta.placeableDatas != null && !meta.placeableDatas.isEmpty()) {
+            this.placeableDatas = new java.util.HashSet<>(meta.placeableDatas);
+        }
+
+        if (meta.destroyableTags != null && !meta.destroyableTags.isEmpty()) {
+            this.destroyableTags = new java.util.HashSet<>(meta.destroyableTags);
+        }
+        if (meta.destroyableDatas != null && !meta.destroyableDatas.isEmpty()) {
+            this.destroyableDatas = new java.util.HashSet<>(meta.destroyableDatas);
+        }
+        // Paper end
         this.unhandledTags.putAll(meta.unhandledTags);
         this.persistentDataContainer.putAll(meta.persistentDataContainer.getRaw());
 
@@ -381,6 +412,21 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
                 this.persistentDataContainer.put(key, compound.get(key).copy());
             }
         }
+        // Paper start - Implement an API for CanPlaceOn and CanDestroy NBT values
+        if (tag.contains(CAN_DESTROY.NBT)) {
+            ListTag list = tag.getList(CAN_DESTROY.NBT, CraftMagicNumbers.NBT.TAG_STRING);
+            for (int i = 0; i < list.size(); i++) {
+                deserializeNamespaced(list.getString(i), destroyableTags, destroyableDatas);
+            }
+        }
+
+        if (tag.contains(CAN_PLACE_ON.NBT)) {
+            ListTag list = tag.getList(CAN_PLACE_ON.NBT, CraftMagicNumbers.NBT.TAG_STRING);
+            for (int i = 0; i < list.size(); i++) {
+                deserializeNamespaced(list.getString(i), placeableTags, placeableDatas);
+            }
+        }
+        // Paper end
 
         Set<String> keys = tag.getAllKeys();
         for (String key : keys) {
@@ -519,6 +565,24 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
             this.setDamage(damage);
         }
 
+        // Paper start - Implement an API for CanPlaceOn and CanDestroy NBT values
+        Iterable<?> canPlaceOnSerialized = SerializableMeta.getObject(Iterable.class, map, CAN_PLACE_ON.BUKKIT, true);
+        if (canPlaceOnSerialized != null) {
+            for (Object canPlaceOnElement : canPlaceOnSerialized) {
+                String canPlaceOnRaw = (String) canPlaceOnElement;
+                deserializeNamespaced(canPlaceOnRaw, placeableTags, placeableDatas);
+            }
+        }
+
+        Iterable<?> canDestroySerialized = SerializableMeta.getObject(Iterable.class, map, CAN_DESTROY.BUKKIT, true);
+        if (canDestroySerialized != null) {
+            for (Object canDestroyElement : canDestroySerialized) {
+                String canDestroyRaw = (String) canDestroyElement;
+                deserializeNamespaced(canDestroyRaw, destroyableTags, destroyableDatas);
+            }
+        }
+        // Paper end
+
         String internal = SerializableMeta.getString(map, "internal", true);
         if (internal != null) {
             ByteArrayInputStream buf = new ByteArrayInputStream(Base64.getDecoder().decode(internal));
@@ -647,6 +711,32 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         if (this.hasDamage()) {
             itemTag.putInt(DAMAGE.NBT, damage);
         }
+        // Paper start - Implement an API for CanPlaceOn and CanDestroy NBT values
+        if (hasPlaceableKeys()) {
+            List<String> items = this.placeableTags.stream()
+                .map(CraftMetaItem::serializeNamespaced).toList();
+
+            List<String> datas = this.placeableDatas.stream()
+                .map(CraftMetaItem::serializeData).toList();
+
+            List<String> itemsTotal = new ArrayList<>(items);
+            itemsTotal.addAll(datas);
+            itemTag.put(CAN_PLACE_ON.NBT, createNonComponentStringList(itemsTotal));
+        }
+
+        if (hasDestroyableKeys()) {
+            List<String> items = this.destroyableTags.stream()
+                .map(CraftMetaItem::serializeNamespaced).toList();
+
+            List<String> datas = this.destroyableDatas.stream()
+                .map(CraftMetaItem::serializeData).toList();
+
+            List<String> itemsTotal = new ArrayList<>(items);
+            itemsTotal.addAll(datas);
+
+            itemTag.put(CAN_DESTROY.NBT, createNonComponentStringList(itemsTotal));
+        }
+        // Paper end
 
         for (Map.Entry<String, Tag> e : this.unhandledTags.entrySet()) {
             itemTag.put(e.getKey(), e.getValue());
@@ -663,6 +753,21 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         }
     }
 
+    // Paper start
+    static ListTag createNonComponentStringList(List<String> list) {
+        if (list == null || list.isEmpty()) {
+            return null;
+        }
+
+        ListTag tagList = new ListTag();
+        for (String value : list) {
+            tagList.add(StringTag.valueOf(value)); // Paper - NBTTagString.of(String str)
+        }
+
+        return tagList;
+    }
+    // Paper end
+
     ListTag createStringList(List<String> list) {
         if (list == null) {
             return null;
@@ -746,7 +851,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
 
     @Overridden
     boolean isEmpty() {
-        return !(this.hasDisplayName() || this.hasLocalizedName() || this.hasEnchants() || (this.lore != null) || this.hasCustomModelData() || this.hasBlockData() || this.hasRepairCost() || !this.unhandledTags.isEmpty() || !this.persistentDataContainer.isEmpty() || this.hideFlag != 0 || this.isUnbreakable() || this.hasDamage() || this.hasAttributeModifiers());
+        return !(this.hasDisplayName() || this.hasLocalizedName() || this.hasEnchants() || (this.lore != null) || this.hasCustomModelData() || this.hasBlockData() || this.hasRepairCost() || !this.unhandledTags.isEmpty() || !this.persistentDataContainer.isEmpty() || this.hideFlag != 0 || this.isUnbreakable() || this.hasDamage() || this.hasAttributeModifiers() || this.hasPlaceableKeys() || this.hasDestroyableKeys()); // Paper - Implement an API for CanPlaceOn and CanDestroy NBT values
     }
 
     // Paper start
@@ -1177,7 +1282,11 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
                 && (this.hideFlag == that.hideFlag)
                 && (this.isUnbreakable() == that.isUnbreakable())
                 && (this.hasDamage() ? that.hasDamage() && this.damage == that.damage : !that.hasDamage())
-                && (this.version == that.version);
+                && (this.version == that.version)
+                // Paper start - Implement an API for CanPlaceOn and CanDestroy NBT values
+                && (this.hasPlaceableKeys() ? that.hasPlaceableKeys() && Objects.equals(placeableTags, that.placeableTags) && Objects.equals(placeableDatas, that.placeableDatas) : !that.hasPlaceableKeys())
+                && (this.hasDestroyableKeys() ? that.hasDestroyableKeys() && Objects.equals(destroyableTags, that.destroyableTags) && Objects.equals(destroyableDatas, that.destroyableDatas) : !that.hasDestroyableKeys());
+                // Paper end
     }
 
     /**
@@ -1212,6 +1321,12 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         hash = 61 * hash + (this.hasDamage() ? this.damage : 0);
         hash = 61 * hash + (this.hasAttributeModifiers() ? this.attributeModifiers.hashCode() : 0);
         hash = 61 * hash + this.version;
+        // Paper start - Implement an API for CanPlaceOn and CanDestroy NBT values
+        hash = 61 * hash + (this.placeableTags != null && !this.placeableTags.isEmpty() ? this.placeableTags.hashCode() : 0);
+        hash = 61 * hash + (this.placeableDatas != null && !this.placeableDatas.isEmpty() ? this.placeableDatas.hashCode() : 0);
+        hash = 61 * hash + (this.destroyableTags != null && !this.destroyableTags.isEmpty() ? this.destroyableTags.hashCode() : 0);
+        hash = 61 * hash + (this.destroyableDatas != null && !this.destroyableDatas.isEmpty() ? this.destroyableDatas.hashCode() : 0);
+        // Paper end
         return hash;
     }
 
@@ -1236,6 +1351,20 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
             clone.unbreakable = this.unbreakable;
             clone.damage = this.damage;
             clone.version = this.version;
+            // Paper start - Implement an API for CanPlaceOn and CanDestroy NBT values
+            if (this.placeableTags != null) {
+                clone.placeableTags = Sets.newHashSet(this.placeableTags);
+            }
+            if (this.placeableDatas != null) {
+                clone.placeableDatas = Sets.newHashSet(this.placeableDatas);
+            }
+            if (this.destroyableTags != null) {
+                clone.destroyableTags = Sets.newHashSet(this.destroyableTags);
+            }
+            if(this.destroyableDatas != null) {
+                clone.destroyableDatas = Sets.newHashSet(this.destroyableDatas);
+            }
+            // Paper end
             return clone;
         } catch (CloneNotSupportedException e) {
             throw new Error(e);
@@ -1293,6 +1422,33 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
             builder.put(DAMAGE.BUKKIT, damage);
         }
 
+        // Paper start - Implement an API for CanPlaceOn and CanDestroy NBT values
+        if (this.hasPlaceableKeys()) {
+            List<String> cerealPlaceable = this.placeableTags.stream()
+                .map(CraftMetaItem::serializeNamespaced).toList();
+
+            List<String> cerealPlaceableData = this.placeableDatas.stream()
+                .map(CraftMetaItem::serializeData).toList();
+
+            List<String> cerealPlaceableTotal = new ArrayList<>(cerealPlaceable);
+            cerealPlaceableTotal.addAll(cerealPlaceableData);
+
+            builder.put(CAN_PLACE_ON.BUKKIT, cerealPlaceableTotal);
+        }
+
+        if (this.hasDestroyableKeys()) {
+            List<String> cerealDestroyable = this.destroyableTags.stream()
+                .map(CraftMetaItem::serializeNamespaced).toList();
+
+            List<String> cerealDestroyableData = this.destroyableDatas.stream()
+                .map(CraftMetaItem::serializeData).toList();
+
+            List<String> cerealDestroyableTotal = new ArrayList<>(cerealDestroyable);
+            cerealDestroyableTotal.addAll(cerealDestroyableData);
+
+            builder.put(CAN_DESTROY.BUKKIT, cerealDestroyableTotal);
+        }
+        // Paper end
         final Map<String, Tag> internalTags = new HashMap<String, Tag>(this.unhandledTags);
         this.serializeInternal(internalTags);
         if (!internalTags.isEmpty()) {
@@ -1459,6 +1615,8 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
                         CraftMetaArmorStand.SHOW_ARMS.NBT,
                         CraftMetaArmorStand.SMALL.NBT,
                         CraftMetaArmorStand.MARKER.NBT,
+                        CAN_DESTROY.NBT,
+                        CAN_PLACE_ON.NBT,
                         // Paper end
                         CraftMetaCompass.LODESTONE_DIMENSION.NBT,
                         CraftMetaCompass.LODESTONE_POS.NBT,
@@ -1487,4 +1645,186 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     }
     // Paper end
 
+    // Paper start - Implement an API for CanPlaceOn and CanDestroy NBT values
+    @Override
+    @SuppressWarnings("deprecation")
+    public Set<Material> getCanDestroy() {
+        return !hasDestroyableKeys() ? Collections.emptySet() : legacyGetMatsFromKeys(this.destroyableTags, this.destroyableDatas);
+    }
+
+    @Override
+    @SuppressWarnings("deprecation")
+    public void setCanDestroy(Set<Material> canDestroy) {
+        Validate.notNull(canDestroy, "Cannot replace with null set!");
+        legacyClearAndReplaceKeys(this.destroyableDatas, canDestroy);
+    }
+
+    @Override
+    @SuppressWarnings("deprecation")
+    public Set<Material> getCanPlaceOn() {
+        return !hasPlaceableKeys() ? Collections.emptySet() : legacyGetMatsFromKeys(this.placeableTags, this.placeableDatas);
+    }
+
+    @Override
+    @SuppressWarnings("deprecation")
+    public void setCanPlaceOn(Set<Material> canPlaceOn) {
+        Validate.notNull(canPlaceOn, "Cannot replace with null set!");
+        legacyClearAndReplaceKeys(this.placeableDatas, canPlaceOn);
+    }
+
+    @Override
+    public Set<Namespaced> getDestroyableKeys() {
+        return !(this.destroyableTags != null && !this.destroyableTags.isEmpty()) ? Collections.emptySet() : Sets.newHashSet(this.destroyableTags);
+    }
+
+    @Override
+    public void setDestroyableKeys(Collection<Namespaced> canDestroy) {
+        Validate.notNull(canDestroy, "Cannot replace with null collection!");
+        Validate.isTrue(ofAcceptableType(canDestroy), "Can only use NamespacedKey or NamespacedTag objects!");
+        this.destroyableTags.clear();
+        this.destroyableDatas.clear();
+        for(Namespaced namespaced : canDestroy) {
+            if(namespaced instanceof NamespacedTag namespacedTag) {
+                this.destroyableTags.add(namespacedTag);
+            } else {
+                this.destroyableDatas.add(CraftBlockData.newData(null, namespaced.toString()));
+            }
+        }
+    }
+
+    @Override
+    public Set<BlockData> getDestroyableDatas() {
+        return !(this.destroyableDatas != null && !this.destroyableDatas.isEmpty()) ? Collections.emptySet() : Sets.newHashSet(this.destroyableDatas);
+    }
+
+    @Override
+    public void setDestroyableDatas(Collection<BlockData> canDestroy) {
+        Validate.notNull(canDestroy, "Cannot replace with null collection!");
+        this.destroyableDatas.clear();
+        this.destroyableDatas.addAll(canDestroy);
+    }
+
+    @Override
+    public Set<Namespaced> getPlaceableKeys() {
+        return !(this.placeableTags != null && !this.placeableTags.isEmpty()) ? Collections.emptySet() : Sets.newHashSet(this.placeableTags);
+    }
+
+    @Override
+    public void setPlaceableKeys(Collection<Namespaced> canPlaceOn) {
+        Validate.notNull(canPlaceOn, "Cannot replace with null collection!");
+        Validate.isTrue(ofAcceptableType(canPlaceOn), "Can only use NamespacedKey or NamespacedTag objects!");
+        this.placeableTags.clear();
+        this.placeableDatas.clear();
+        for(Namespaced namespaced : canPlaceOn) {
+            if(namespaced instanceof NamespacedTag namespacedTag) {
+                this.placeableTags.add(namespacedTag);
+            } else {
+                this.placeableDatas.add(CraftBlockData.newData(null, namespaced.toString()));
+            }
+        }
+    }
+
+    @Override
+    public Set<BlockData> getPlaceableDatas() {
+        return !(this.placeableDatas != null && !this.placeableDatas.isEmpty()) ? Collections.emptySet() : Sets.newHashSet(this.placeableDatas);
+    }
+
+    @Override
+    public void setPlaceableDatas(Collection<BlockData> canPlaceOn) {
+        Validate.notNull(canPlaceOn, "Cannot replace with null collection!");
+        this.placeableDatas.clear();
+        this.placeableDatas.addAll(canPlaceOn);
+    }
+
+    @Override
+    public boolean hasPlaceableKeys() {
+        return (this.placeableTags != null && !this.placeableTags.isEmpty()) || (this.placeableDatas != null && !this.placeableDatas.isEmpty());
+    }
+
+    @Override
+    public boolean hasDestroyableKeys() {
+        return (this.destroyableTags != null && !this.destroyableTags.isEmpty()) || (this.destroyableDatas != null && !this.destroyableDatas.isEmpty());
+    }
+
+    @Deprecated
+    private static void legacyClearAndReplaceKeys(Collection<BlockData> toUpdate, Collection<Material> beingSet) {
+        if (beingSet.stream().anyMatch(Material::isLegacy)) {
+            throw new IllegalArgumentException("Set must not contain any legacy materials!");
+        }
+
+        toUpdate.clear();
+        toUpdate.addAll(beingSet.stream().map(mat ->  CraftBlockData.newData(mat, null)).collect(java.util.stream.Collectors.toSet()));
+    }
+
+    @Deprecated
+    private static Set<Material> legacyGetMatsFromKeys(Collection<NamespacedTag> names, Collection<BlockData> datas) {
+        Set<Material> mats = Sets.newHashSet();
+        for (Namespaced key : names) {
+            if (!(key instanceof org.bukkit.NamespacedKey)) {
+                continue;
+            }
+
+            Material material = Material.matchMaterial(key.toString(), false);
+            if (material != null) {
+                mats.add(material);
+            }
+        }
+
+        for(BlockData data : datas) {
+            mats.add(data.getMaterial());
+        }
+
+        return mats;
+    }
+
+    private static void deserializeNamespaced(String raw, Collection<NamespacedTag> tags, Collection<BlockData> datas) {
+        boolean isTag = raw.length() > 0 && raw.codePointAt(0) == '#';
+        com.mojang.datafixers.util.Either<net.minecraft.commands.arguments.blocks.BlockStateParser.BlockResult, net.minecraft.commands.arguments.blocks.BlockStateParser.TagResult> result;
+        try {
+            result = net.minecraft.commands.arguments.blocks.BlockStateParser.parseForTesting(net.minecraft.core.Registry.BLOCK, raw, false);
+        } catch (com.mojang.brigadier.exceptions.CommandSyntaxException e) {
+            return;
+        }
+
+        net.minecraft.resources.ResourceLocation key = null;
+        if (isTag && result.right().isPresent() && result.right().get().tag() instanceof net.minecraft.core.HolderSet.Named<net.minecraft.world.level.block.Block> namedSet) {
+            key = namedSet.key().location();
+        } else if (result.left().isPresent()) {
+            CraftBlockData data = CraftBlockData.fromData(result.left().get().blockState());
+            data.parsedStates = result.left().get().properties();
+            datas.add(data);
+            return;
+        }
+
+        // don't DC the player if something slips through somehow
+        if(key != null && isTag) {
+            try {
+                tags.add(new NamespacedTag(key.getNamespace(), key.getPath()));
+            } catch (IllegalArgumentException ex) {
+                org.bukkit.Bukkit.getLogger().warning("Namespaced tag does not validate: " + key);
+                ex.printStackTrace();
+            }
+        }
+    }
+
+    private static @Nonnull String serializeNamespaced(Namespaced resource) {
+        return resource.toString();
+    }
+
+    private static @Nonnull String serializeData(BlockData data) {
+        return data.getAsString(true);
+    }
+
+    // not a fan of this
+    private static boolean ofAcceptableType(Collection<Namespaced> namespacedResources) {
+        
+        for (Namespaced resource : namespacedResources) {
+            if (!(resource instanceof org.bukkit.NamespacedKey || resource instanceof com.destroystokyo.paper.NamespacedTag)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+    // Paper end
 }
