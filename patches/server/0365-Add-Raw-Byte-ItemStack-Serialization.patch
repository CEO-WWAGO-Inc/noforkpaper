From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Mariell Hoversholm <proximyst@proximyst.com>
Date: Thu, 30 Apr 2020 16:56:54 +0200
Subject: [PATCH] Add Raw Byte ItemStack Serialization

Serializes using NBT which is safer for server data migrations than bukkits format.

diff --git a/src/main/java/io/papermc/paper/APIBridgeImpl.java b/src/main/java/io/papermc/paper/APIBridgeImpl.java
index 0e3bc884b680cd35338cc4bfd102bfbaf0c86e9c..91f5e700672998b7fedf0c7defae994205b3818c 100644
--- a/src/main/java/io/papermc/paper/APIBridgeImpl.java
+++ b/src/main/java/io/papermc/paper/APIBridgeImpl.java
@@ -1,14 +1,25 @@
 package io.papermc.paper;
 
+import ca.spottedleaf.dataconverter.minecraft.MCDataConverter;
+import ca.spottedleaf.dataconverter.minecraft.datatypes.MCTypeRegistry;
 import com.destroystokyo.paper.PaperVersionFetcher;
 import com.destroystokyo.paper.util.VersionFetcher;
+import com.google.common.base.Preconditions;
 import io.papermc.paper.adventure.PaperAdventure;
 import io.papermc.paper.configuration.GlobalConfiguration;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import net.kyori.adventure.text.Component;
 import net.kyori.adventure.text.flattener.ComponentFlattener;
+import net.minecraft.SharedConstants;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtIo;
+import org.bukkit.Material;
 import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.entity.Entity;
+import org.bukkit.inventory.ItemStack;
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.checkerframework.framework.qual.DefaultQualifier;
@@ -35,4 +46,49 @@ public final class APIBridgeImpl implements APIBridge {
     public VersionFetcher getVersionFetcher() {
         return new PaperVersionFetcher();
     }
+
+    @Override
+    public byte[] serializeItem(final ItemStack item) {
+        Preconditions.checkNotNull(item, "null cannot be serialized");
+        Preconditions.checkArgument(item.getType() != Material.AIR, "air cannot be serialized");
+
+        return this.serializeNbtToBytes((item instanceof CraftItemStack ? ((CraftItemStack) item).handle : CraftItemStack.asNMSCopy(item)).save(new CompoundTag()));
+    }
+
+    @Override
+    public ItemStack deserializeItem(final byte[] data) {
+        Preconditions.checkNotNull(data, "null cannot be deserialized");
+        Preconditions.checkArgument(data.length > 0, "cannot deserialize nothing");
+
+        CompoundTag compound = this.deserializeNbtFromBytes(data);
+        int dataVersion = compound.getInt("DataVersion");
+        return CraftItemStack.asCraftMirror(net.minecraft.world.item.ItemStack.of(MCDataConverter.convertTag(MCTypeRegistry.ITEM_STACK, compound, dataVersion, currentDataVersion())));
+    }
+
+    private byte[] serializeNbtToBytes(final CompoundTag compound) {
+        compound.putInt("DataVersion", currentDataVersion());
+        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+        try {
+            NbtIo.writeCompressed(compound, outputStream);
+        } catch (IOException ex) {
+            throw new RuntimeException(ex);
+        }
+        return outputStream.toByteArray();
+    }
+
+    private CompoundTag deserializeNbtFromBytes(final byte[] data) {
+        CompoundTag compound;
+        try {
+            compound = NbtIo.readCompressed(new ByteArrayInputStream(data));
+        } catch (IOException ex) {
+            throw new RuntimeException(ex);
+        }
+        int dataVersion = compound.getInt("DataVersion");
+        Preconditions.checkArgument(dataVersion <= currentDataVersion(), "Newer version! Server downgrades are not supported!");
+        return compound;
+    }
+
+    private static int currentDataVersion() {
+        return SharedConstants.getCurrentVersion().getDataVersion().getVersion();
+    }
 }
