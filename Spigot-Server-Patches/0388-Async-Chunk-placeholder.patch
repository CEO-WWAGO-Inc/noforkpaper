From fd6e42ad97f51e2656777ae3a4d09cd2e171c48b Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Mon, 6 May 2019 12:29:24 -0700
Subject: [PATCH] Async Chunk placeholder

Until we figure out Mojang's ticket system.

diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 421e92cfa5..625f8ade6a 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -118,6 +118,86 @@ public class ChunkProviderServer extends IChunkProvider {
         }
     }
 
+    // Paper start - async chunk api
+    public CompletableFuture<Chunk> getChunkAtAsynchronously(int x, int z, boolean gen) {
+        if (Thread.currentThread() != this.serverThread) {
+            CompletableFuture<Chunk> ret = new CompletableFuture<>();
+            this.serverThreadQueue.execute(() -> {
+                this.getChunkAtAsynchronously(x, z, gen).whenComplete((chunk, throwable) -> {
+                    if (chunk == null) {
+                        ret.completeExceptionally(throwable);
+                    } else {
+                        ret.complete(chunk);
+                    }
+                });
+            });
+            return ret;
+        }
+        // on main thread
+        // copied from above
+        // if the chunk doesn't exist and we don't want to gen we return immediately
+        try {
+            if (!gen && !this.playerChunkMap.chunkExists(new ChunkCoordIntPair(x, z))) {
+                return CompletableFuture.completedFuture(null);
+            }
+        } catch (IOException ex) {
+            throw new RuntimeException(ex);
+        }
+        long k = ChunkCoordIntPair.pair(x, z);
+
+        IChunkAccess ichunkaccess;
+        ChunkCoordIntPair chunkcoord = new ChunkCoordIntPair(x, z);
+
+        // search cache
+        for (int l = 0; l < 4; ++l) {
+            if (k == this.n[l] && ChunkStatus.FULL == this.o[l]) {
+                ichunkaccess = this.p[l];
+
+                // move the chunk to first in cache
+                for (int i1 = 3; i1 > 0; --i1) {
+                    this.n[i1] = this.n[i1 - 1];
+                    this.o[i1] = this.o[i1 - 1];
+                    this.p[i1] = this.p[i1 - 1];
+                }
+
+                this.n[0] = k;
+                this.o[0] = ChunkStatus.FULL;
+                this.p[0] = ichunkaccess;
+
+                return CompletableFuture.completedFuture((Chunk)ichunkaccess);
+            }
+        }
+
+        this.addTicket(TicketType.PLUGIN, chunkcoord, 1, Unit.INSTANCE);
+
+        CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> completablefuture = this.getChunkFutureMainThread(x, z, ChunkStatus.FULL, true);
+        CompletableFuture<Chunk> ret = new CompletableFuture<>();
+
+        completablefuture.whenComplete((either, throwable) -> {
+            this.serverThreadQueue.execute(() -> {
+                // either left -> success
+                // either right -> failure
+
+                if (throwable != null) {
+                    throw new RuntimeException(throwable);
+                }
+
+                Optional<PlayerChunk.Failure> didWeFail = either.right();
+                if (didWeFail.isPresent()) {
+                    // we failed
+                    throw new IllegalStateException("Chunk failed to load: " + didWeFail.get().toString());
+                } else {
+                    // did not fail
+                    ret.complete((Chunk)either.left().get());
+                }
+                this.removeTicket(TicketType.PLUGIN, chunkcoord, 1, Unit.INSTANCE);
+                this.addTicket(TicketType.UNKNOWN, chunkcoord, 1, chunkcoord);
+            });
+        });
+        return ret;
+    }
+    // Paper end
+
     private void l() {
         Arrays.fill(this.n, ChunkCoordIntPair.a);
         Arrays.fill(this.o, (Object) null);
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index e18ae24bf8..548dbbd81e 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -14,6 +14,7 @@ import java.util.Objects;
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
 import java.util.function.Predicate;
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.BiomeBase;
@@ -2118,6 +2119,18 @@ public class CraftWorld implements World {
         return (nearest == null) ? null : new Location(this, nearest.getX(), nearest.getY(), nearest.getZ());
     }
 
+    // Paper start
+
+    @Override
+    public CompletableFuture<Chunk> getChunkAtAsync(int x, int z, boolean gen) {
+        CompletableFuture<Chunk> ret = new CompletableFuture<>();
+        this.world.getChunkProvider().getChunkAtAsynchronously(x, z, gen).thenAccept((chunk) -> {
+            ret.complete(chunk == null ? null : chunk.bukkitChunk);
+        });
+        return ret;
+    }
+    // Paper end
+
     // Spigot start
     private final Spigot spigot = new Spigot()
     {
-- 
2.21.0

