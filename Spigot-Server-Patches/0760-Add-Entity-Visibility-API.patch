From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Janmm14 <gitconfig1@janmm14.de>
Date: Fri, 25 Jun 2021 00:30:53 +0200
Subject: [PATCH] Add Entity Visibility API


diff --git a/src/main/java/net/minecraft/server/level/PlayerChunkMap.java b/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
index 6835401bd7863bbd655502547a9fd4ae0f298da1..800e62220574753a0d89e9ef037991e3f85fa6ea 100644
--- a/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
@@ -2377,7 +2377,7 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
         // Paper start - use distance map to optimise tracker
         com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> lastTrackerCandidates;
 
-        final void updatePlayers(com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newTrackerCandidates) {
+        public final void updatePlayers(com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newTrackerCandidates) {
             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> oldTrackerCandidates = this.lastTrackerCandidates;
             this.lastTrackerCandidates = newTrackerCandidates;
 
@@ -2485,7 +2485,15 @@ Sections go from 0..16. Now whenever a section is not empty, it can potentially
                         Player player = ((EntityPlayer) this.tracker).getBukkitEntity();
                         if (!entityplayer.getBukkitEntity().canSee(player)) {
                             flag1 = false;
-                        }
+                        } // Paper start - Entity Visibility API
+                    } else if (flag1) {
+                        org.bukkit.craftbukkit.entity.CraftEntity ce = this.tracker.getBukkitEntity();
+                        boolean override = ce.visibilityOverrides.contains(entityplayer.getBukkitEntity());
+                        if (ce.shownByDefault) {
+                            flag1 = !override;
+                        } else {
+                            flag1 = override;
+                        } // Paper end
                     }
 
                     entityplayer.removeQueue.remove(Integer.valueOf(this.tracker.getId()));
diff --git a/src/main/java/net/minecraft/server/level/WorldServer.java b/src/main/java/net/minecraft/server/level/WorldServer.java
index f68a252378a94c8fcab622d2d89d738aceab45a4..89802563e831e62fc1ffea32758ebfcca6737fe1 100644
--- a/src/main/java/net/minecraft/server/level/WorldServer.java
+++ b/src/main/java/net/minecraft/server/level/WorldServer.java
@@ -1648,7 +1648,7 @@ public class WorldServer extends World implements GeneratorAccessSeed {
                 double d2 = (double) blockposition.getZ() - entityplayer.locZ();
 
                 // CraftBukkit start
-                if (entityhuman != null && entityhuman instanceof EntityPlayer && !entityplayer.getBukkitEntity().canSee(((EntityPlayer) entityhuman).getBukkitEntity())) {
+                if (!entityplayer.getBukkitEntity().canSee(entity.getBukkitEntity())) { // Paper - Entity Visibility API
                     continue;
                 }
                 // CraftBukkit end
diff --git a/src/main/java/net/minecraft/world/level/World.java b/src/main/java/net/minecraft/world/level/World.java
index f7f593a9e58b537109fa6ca1c783f6614f4bfad5..c7f2ca0379e257926c24914e0a9498eddacff6b2 100644
--- a/src/main/java/net/minecraft/world/level/World.java
+++ b/src/main/java/net/minecraft/world/level/World.java
@@ -283,8 +283,8 @@ public abstract class World implements GeneratorAccess, AutoCloseable {
         for (int i = 0, len = entities.size(); i < len; ++i) {
             Entity entity = entities.get(i);
 
-            if (checkCanSee && source instanceof EntityPlayer && entity instanceof EntityPlayer
-                && !((EntityPlayer) source).getBukkitEntity().canSee(((EntityPlayer) entity).getBukkitEntity())) {
+            if (checkCanSee && source instanceof EntityPlayer
+                && !((EntityPlayer) source).getBukkitEntity().canSee(entity.getBukkitEntity())) { // Paper - Entity Visibility API
                 continue;
             }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 295ffab08672d77d88aca368cb5b56f80bc4f1b5..40b9edf7f8e14a7f280aaa48d00a0a64f447c092 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -1166,4 +1166,23 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         return getHandle().isTicking();
     }
     // Paper end
+
+    // Paper start - Entity Visibility API
+    public boolean shownByDefault = true;
+    public final java.util.Set<CraftEntity> visibilityOverrides = java.util.Collections.newSetFromMap(new java.util.WeakHashMap<>());
+
+    @Override
+    public boolean isShownByDefault() {
+        return shownByDefault;
+    }
+
+    @Override
+    public void resetAndSetShownByDefault(boolean shownByDefault) {
+        this.shownByDefault = shownByDefault;
+        visibilityOverrides.clear();
+        if (isValid()) { // only update tracking if spawned
+            getHandle().tracker.updatePlayers(getHandle().getPlayersInTrackRange());
+        }
+    }
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index cfe6898dc373fe55a08acf5c90e200061aa7d0fc..daa12538d90e9c843ee7e1be04302dd571227a86 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -2444,4 +2444,68 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         return spigot;
     }
     // Spigot end
+
+    // Paper start - Entity Visibility API
+    @Override
+    public boolean canSee(org.bukkit.entity.Entity entity) {
+        if (entity instanceof Player) {
+            return canSee((Player) entity);
+        }
+        CraftEntity ce = (CraftEntity) entity;
+        return Boolean.logicalXor(ce.shownByDefault, ce.visibilityOverrides.contains(this));
+    }
+
+    @Override
+    public void showEntity(org.bukkit.entity.Entity entity) {
+        if (entity instanceof Player) {
+            showPlayer((Player) entity);
+        } else {
+            CraftEntity ce = (CraftEntity) entity;
+            boolean nowShown;
+            if (ce.shownByDefault) {
+                nowShown = ce.visibilityOverrides.remove(this);
+            } else {
+                nowShown = ce.visibilityOverrides.add(this);
+            }
+            if (nowShown) {
+                registerEntity(ce.getHandle());
+            }
+        }
+    }
+
+    @Override
+    public void hideEntity(org.bukkit.entity.Entity entity) {
+        if (entity instanceof Player) {
+            hidePlayer((Player) entity);
+        } else {
+            CraftEntity ce = (CraftEntity) entity;
+            boolean nowHidden;
+            if (ce.shownByDefault) {
+                nowHidden = ce.visibilityOverrides.add(this);
+            } else {
+                nowHidden = ce.visibilityOverrides.remove(this);
+            }
+            if (nowHidden) {
+                unregisterEntity(ce.getHandle());
+            }
+        }
+    }
+
+    private void registerEntity(Entity other) {
+        PlayerChunkMap tracker = ((WorldServer) entity.world).getChunkProvider().playerChunkMap;
+        PlayerChunkMap.EntityTracker entry = tracker.trackedEntities.get(other.getId());
+        if (entry != null && !entry.trackedPlayers.contains(getHandle())) {
+            entry.updatePlayer(getHandle());
+        }
+    }
+    private void unregisterEntity(Entity other) {
+        PlayerChunkMap tracker = ((WorldServer) entity.world).getChunkProvider().playerChunkMap;
+        PlayerChunkMap.EntityTracker entry = tracker.trackedEntities.get(other.getId());
+        if (entry != null) {
+            entry.clear(getHandle());
+        }
+    }
+
+    // Paper end
+
 }
