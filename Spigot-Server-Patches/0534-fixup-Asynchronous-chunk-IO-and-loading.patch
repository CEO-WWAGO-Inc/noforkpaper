From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Tue, 26 May 2020 23:24:26 -0700
Subject: [PATCH] fixup! Asynchronous chunk IO and loading


diff --git a/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java b/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
index 4f10a8311ea931026079c85bb59e223b0122a4a9..a6434b4e28a73ecab4350862c5747b7494761ba0 100644
--- a/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
+++ b/src/main/java/com/destroystokyo/paper/io/PaperFileIOThread.java
@@ -107,48 +107,6 @@ public final class PaperFileIOThread extends QueueExecutorThread {
         }
     }
 
-    // Hack start
-    /**
-     * if {@code waitForRead} is true, then this task will wait on an available read task, else it will wait on an available
-     * write task
-     * if {@code poiTask} is true, then this task will wait on a poi task, else it will wait on chunk data task
-     * @deprecated API is garbage and will only work for main thread queueing of tasks (which is vanilla), plugins messing
-     *            around asynchronously will give unexpected results
-     * @return whether the task succeeded, or {@code null} if there is no task
-     */
-    @Deprecated
-    public Boolean waitForIOToComplete(final WorldServer world, final int chunkX, final int chunkZ, final boolean waitForRead,
-                                       final boolean poiTask) {
-        final ChunkDataTask task;
-
-        final Long key = IOUtil.getCoordinateKey(chunkX, chunkZ);
-        if (poiTask) {
-            task = world.poiDataController.tasks.get(key);
-        } else {
-            task = world.chunkDataController.tasks.get(key);
-        }
-
-        if (task == null) {
-            return null;
-        }
-
-        if (waitForRead) {
-            ChunkDataController.InProgressRead read = task.inProgressRead;
-            if (read == null) {
-                return null;
-            }
-            return Boolean.valueOf(read.readFuture.join() != PaperFileIOThread.FAILURE_VALUE);
-        }
-
-        // wait for write
-        ChunkDataController.InProgressWrite write = task.inProgressWrite;
-        if (write == null) {
-            return null;
-        }
-        return Boolean.valueOf(write.wrote.join() != PaperFileIOThread.FAILURE_VALUE);
-    }
-    // Hack end
-
     public NBTTagCompound getPendingWrite(final WorldServer world, final int chunkX, final int chunkZ, final boolean poiData) {
         final ChunkDataController taskController = poiData ? world.poiDataController : world.chunkDataController;
 
@@ -486,11 +444,6 @@ public final class PaperFileIOThread extends QueueExecutorThread {
         public static final class InProgressWrite {
             public long writeCounter;
             public NBTTagCompound data;
-
-            // Hack start
-            @Deprecated
-            public CompletableFuture<NBTTagCompound> wrote = new CompletableFuture<>();
-            // Hack end
         }
 
         public static final class InProgressRead {
@@ -543,7 +496,6 @@ public final class PaperFileIOThread extends QueueExecutorThread {
         void reschedule(final int priority) {
             // priority is checked before this stage // TODO what
             this.queue.lazySet(null);
-            this.inProgressWrite.wrote = new CompletableFuture<>(); // Hack
             this.priority.lazySet(priority);
             PaperFileIOThread.Holder.INSTANCE.queueTask(this);
         }
@@ -596,7 +548,6 @@ public final class PaperFileIOThread extends QueueExecutorThread {
                 LOGGER.fatal("Couldn't save chunk; already in use by another instance of Minecraft?", ex);
                 // we don't need to set the write counter to -1 as we know at this stage there's no point in re-scheduling
                 // writes since they'll fail anyways.
-                write.wrote.complete(PaperFileIOThread.FAILURE_VALUE); // Hack - However we need to fail the write
                 return;
             }
 
@@ -626,19 +577,14 @@ public final class PaperFileIOThread extends QueueExecutorThread {
 
                 ChunkDataTask inMap = this.taskController.tasks.compute(chunkKey, (final Long keyInMap, final ChunkDataTask valueInMap) -> {
                     if (valueInMap == null) {
-                        ChunkDataTask.this.inProgressWrite.wrote.complete(PaperFileIOThread.FAILURE_VALUE); // Hack
                         throw new IllegalStateException("Write completed concurrently, expected this task: " + ChunkDataTask.this.toString() + ", report this!");
                     }
                     if (valueInMap != ChunkDataTask.this) {
-                        ChunkDataTask.this.inProgressWrite.wrote.complete(PaperFileIOThread.FAILURE_VALUE); // Hack
                         throw new IllegalStateException("Chunk task mismatch, expected this task: " + ChunkDataTask.this.toString() + ", got: " + valueInMap.toString() + ", report this!");
                     }
                     if (valueInMap.inProgressWrite.writeCounter == writeCounter) {
                         if (finalFailWrite) {
                             valueInMap.inProgressWrite.writeCounter = -1L;
-                            valueInMap.inProgressWrite.wrote.complete(PaperFileIOThread.FAILURE_VALUE);
-                        } else {
-                            valueInMap.inProgressWrite.wrote.complete(data);
                         }
 
                         return null;
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index b7d8a7487e303c2c44160ec1093987b3e0d175bc..0c65f0fa9cb087ecf109a58c6663ffcee3d4fb26 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -1350,39 +1350,9 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         return this.u.get();
     }
 
-    // Paper start - async chunk io
-    private boolean writeDataAsync(ChunkCoordIntPair chunkPos, NBTTagCompound poiData, NBTTagCompound chunkData, boolean async) {
-        com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(this.world, chunkPos.x, chunkPos.z,
-            poiData, chunkData, !async ? com.destroystokyo.paper.io.PrioritizedTaskQueue.HIGHEST_PRIORITY : com.destroystokyo.paper.io.PrioritizedTaskQueue.LOW_PRIORITY);
-
-        if (async) {
-            return true;
-        }
-
-        try (co.aikar.timings.Timing ignored = this.world.timings.chunkSaveIOWait.startTiming()) { // Paper
-        Boolean successPoi = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.waitForIOToComplete(this.world, chunkPos.x, chunkPos.z, true, true);
-        Boolean successChunk = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.waitForIOToComplete(this.world, chunkPos.x, chunkPos.z, true, false);
-
-        if (successPoi == Boolean.FALSE || successChunk == Boolean.FALSE) {
-            return false;
-        }
-
-        // null indicates no task existed, which means our write completed before we waited on it
-
-        return true;
-        } // Paper
-    }
-    // Paper end
-
     public boolean saveChunk(IChunkAccess ichunkaccess) {
-        // Paper start - async param
-        return this.saveChunk(ichunkaccess, true);
-    }
-    public boolean saveChunk(IChunkAccess ichunkaccess, boolean async) {
-        try (co.aikar.timings.Timing ignored = this.world.timings.chunkSave.startTiming()) {
-        NBTTagCompound poiData = this.getVillagePlace().getData(ichunkaccess.getPos()); // Paper
-        //this.m.a(ichunkaccess.getPos()); // Delay
-        // Paper end
+        try (co.aikar.timings.Timing ignored = this.world.timings.chunkSave.startTiming()) { // Paper
+        this.m.a(ichunkaccess.getPos());
         if (!ichunkaccess.isNeedsSaving()) {
             return false;
         } else {
@@ -1402,23 +1372,24 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                     ChunkStatus statusOnDisk = this.getChunkStatusOnDisk(chunkcoordintpair);
                     if (statusOnDisk != null && statusOnDisk.getType() == ChunkStatus.Type.LEVELCHUNK) {
                         // Paper end
-                        this.writeDataAsync(ichunkaccess.getPos(), poiData, null, async); // Paper - Async chunk io
                         return false;
                     }
 
                     if (chunkstatus == ChunkStatus.EMPTY && ichunkaccess.h().values().stream().noneMatch(StructureStart::e)) {
-                        this.writeDataAsync(ichunkaccess.getPos(), poiData, null, async); // Paper - Async chunk io
                         return false;
                     }
                 }
 
-                this.world.getMethodProfiler().c("chunkSave");
                 } // Paper
+                this.world.getMethodProfiler().c("chunkSave");
                 try (co.aikar.timings.Timing ignored1 = this.world.timings.chunkSaveDataSerialization.startTiming()) { // Paper
                 nbttagcompound = ChunkRegionLoader.saveChunk(this.world, ichunkaccess);
                 } // Paper
-                return this.writeDataAsync(ichunkaccess.getPos(), poiData, nbttagcompound, async); // Paper - Async chunk io
-                //return true; // Paper
+                // Paper start - async chunk io
+                com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(this.world, chunkcoordintpair.x, chunkcoordintpair.z,
+                    null, nbttagcompound, com.destroystokyo.paper.io.PrioritizedTaskQueue.NORMAL_PRIORITY);
+                // Paper end - async chunk io
+                return true;
             } catch (Exception exception) {
                 PlayerChunkMap.LOGGER.error("Failed to save chunk {},{}", chunkcoordintpair.x, chunkcoordintpair.z, exception);
                 com.destroystokyo.paper.exception.ServerInternalException.reportInternalException(exception); // Paper
@@ -1558,13 +1529,6 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(
                 this.world, chunkcoordintpair.x, chunkcoordintpair.z, null, nbttagcompound,
                 com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
-
-            Boolean ret = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.waitForIOToComplete(this.world,
-                chunkcoordintpair.x, chunkcoordintpair.z, true, false);
-
-            if (ret == Boolean.FALSE) {
-                throw new IOException("See logs for further detail");
-            }
             return;
         }
         super.write(chunkcoordintpair, nbttagcompound);
diff --git a/src/main/java/net/minecraft/server/VillagePlace.java b/src/main/java/net/minecraft/server/VillagePlace.java
index b59ef1a63338aa150d39e8014e12b2275da26d50..1a5ec6152c15a6ece227d4bac00c3b02bd9c5c95 100644
--- a/src/main/java/net/minecraft/server/VillagePlace.java
+++ b/src/main/java/net/minecraft/server/VillagePlace.java
@@ -276,13 +276,6 @@ public class VillagePlace extends RegionFileSection<VillagePlaceSection> {
             com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.scheduleSave(
                 this.world, chunkcoordintpair.x, chunkcoordintpair.z, nbttagcompound, null,
                 com.destroystokyo.paper.io.IOUtil.getPriorityForCurrentThread());
-
-            Boolean ret = com.destroystokyo.paper.io.PaperFileIOThread.Holder.INSTANCE.waitForIOToComplete(this.world,
-                chunkcoordintpair.x, chunkcoordintpair.z, true, true);
-
-            if (ret == Boolean.FALSE) {
-                throw new java.io.IOException("See logs for further detail");
-            }
             return;
         }
         super.write(chunkcoordintpair, nbttagcompound);
