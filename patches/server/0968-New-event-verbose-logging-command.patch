From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: RyGuy <TheRealRyGuy@users.noreply.github.com>
Date: Tue, 21 Mar 2023 16:21:07 -0400
Subject: [PATCH] New event verbose logging command


diff --git a/src/main/java/io/papermc/paper/command/PaperCommand.java b/src/main/java/io/papermc/paper/command/PaperCommand.java
index 7ba60b4b4f29a42c58d98aafc5ea0fa3214f554c..53c54fa19fbb3760515a5cb161cdda989d29a70a 100644
--- a/src/main/java/io/papermc/paper/command/PaperCommand.java
+++ b/src/main/java/io/papermc/paper/command/PaperCommand.java
@@ -45,6 +45,7 @@ public final class PaperCommand extends Command {
         commands.put(Set.of("dumpitem"), new DumpItemCommand());
         commands.put(Set.of("mobcaps", "playermobcaps"), new MobcapsCommand());
         commands.put(Set.of("dumplisteners"), new DumpListenersCommand());
+        commands.put(Set.of("logevents"), LogEventsCommand.get());
 
         return commands.entrySet().stream()
             .flatMap(entry -> entry.getKey().stream().map(s -> Map.entry(s, entry.getValue())))
diff --git a/src/main/java/io/papermc/paper/command/subcommands/LogEventsCommand.java b/src/main/java/io/papermc/paper/command/subcommands/LogEventsCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..b31ed8707c34f18ec4c8ecce6ed45f58a475b89a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/subcommands/LogEventsCommand.java
@@ -0,0 +1,142 @@
+package io.papermc.paper.command.subcommands;
+
+import com.destroystokyo.paper.event.server.ServerTickEndEvent;
+import com.destroystokyo.paper.event.server.ServerTickStartEvent;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.google.gson.internal.Streams;
+import com.google.gson.stream.JsonWriter;
+import io.papermc.paper.command.PaperSubcommand;
+import io.papermc.paper.util.misc.LoggedEvent;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.CommandSender;
+import org.bukkit.event.Event;
+import org.bukkit.inventory.ItemStack;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.io.IOException;
+import java.io.PrintStream;
+import java.io.StringWriter;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.time.LocalDateTime;
+import java.util.*;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.GREEN;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+
+@DefaultQualifier(NonNull.class)
+public class LogEventsCommand implements PaperSubcommand {
+
+    @Nullable
+    private static LogEventsCommand instance; //instance is declared registering in PaperCommand
+
+    private final List<Wrapper> wrappers = new ArrayList<>();
+    private final Path parent = Path.of("event-debug");
+    //ignore unnecessary events
+    private final Set<Class<? extends Event>> exclude = Set.of(ServerTickStartEvent.class,
+        ServerTickEndEvent.class);
+    private boolean isRunning = false;
+    @Nullable
+    private Path currentFile;
+
+    private LogEventsCommand() {
+    }
+
+    public static synchronized LogEventsCommand get() {
+        if (instance == null)
+            instance = new LogEventsCommand();
+        return instance;
+    }
+
+    /**
+     * Called in {@link io.papermc.paper.plugin.manager.PaperPluginManagerImpl#callEvent(Event)} to save in {@link #wrappers}
+     */
+    public void tryLogEvent(Event ev) {
+        if (!isRunning)
+            return;
+        if (exclude.contains(ev.getClass()))
+            return;
+        wrappers.add(new Wrapper(ev));
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String subCommand, String[] args) {
+        if (!isRunning) {
+            isRunning = true;
+            Path path = parent.resolve("event-verbose-" + LoggedEvent.FORMATTER.format(LocalDateTime.now()) + ".txt");
+            try {
+                Files.createDirectories(parent);
+                currentFile = Files.createFile(path);
+                sender.sendMessage(text("Now logging all event information, run this again to save it to a file!", GREEN));
+            } catch (IOException e) {
+                sender.sendMessage(text("Failed to create event verbose files! See the console for more info.", RED));
+                MinecraftServer.LOGGER.warn("Error occurred while creating event logging files", e);
+                isRunning = false;
+            }
+        } else {
+            isRunning = false;
+            sender.sendMessage(text("Logging events..", GREEN));
+            try {
+                logWrappers();
+                sender.sendMessage(text("Logged all event verbose to " + currentFile, GREEN));
+                currentFile = null;
+                wrappers.clear();
+            } catch (IOException e) {
+                sender.sendMessage(text("Failed to create event verbose files! See the console for more info.", RED));
+                MinecraftServer.LOGGER.warn("Error occurred while dumping event logs", e);
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Dumps all currently stored {@link LoggedEvent}'s to our {@link #currentFile}
+     *
+     * @throws IOException If something broke writing it
+     */
+    private void logWrappers() throws IOException {
+        JsonArray array = new JsonArray();
+        wrappers.forEach(w -> {
+            @Nullable JsonObject obj = w.serialize();
+            if (obj != null) //will only be null if an event class only has final fields
+                array.add(obj);
+        });
+
+        StringWriter stringWriter = new StringWriter();
+        JsonWriter jsonWriter = new JsonWriter(stringWriter);
+        jsonWriter.setIndent(" ");
+        jsonWriter.setLenient(false);
+        Streams.write(array, jsonWriter);
+
+        try (PrintStream out = new PrintStream(Files.newOutputStream(currentFile), false, StandardCharsets.UTF_8)) {
+            out.print(stringWriter);
+        }
+
+    }
+
+    /**
+     * Inheritance of {@link LoggedEvent} that just ensures we ignore "unchangeable" classes
+     */
+    private static final class Wrapper extends LoggedEvent {
+        public Wrapper(Event event) {
+            super(event);
+        }
+
+        @Override
+        public boolean shouldSerialize(List<Field> fields) {
+            for (Field f : fields) {
+                if (!Modifier.isFinal(f.getModifiers()) || f.getType().equals(ItemStack.class) ||
+                    Map.class.isAssignableFrom(f.getType()) || Collection.class.isAssignableFrom(f.getType()))
+                    return true;
+            }
+            return false;
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
index 7ce9ebba8ce304d1f3f21d4f15ee5f3560d7700b..b658a79664edb1a677398c291e22dc29f7bad261 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
@@ -4,6 +4,7 @@ import co.aikar.timings.TimedEventExecutor;
 import com.destroystokyo.paper.event.server.ServerExceptionEvent;
 import com.destroystokyo.paper.exception.ServerEventException;
 import com.google.common.collect.Sets;
+import io.papermc.paper.command.subcommands.LogEventsCommand;
 import org.bukkit.Server;
 import org.bukkit.Warning;
 import org.bukkit.event.Event;
@@ -41,6 +42,7 @@ class PaperEventManager {
         } else if (!event.isAsynchronous() && !this.server.isPrimaryThread() && !this.server.isStopping()) {
             throw new IllegalStateException(event.getEventName() + " may only be triggered synchronously.");
         }
+        LogEventsCommand.get().tryLogEvent(event);
 
         HandlerList handlers = event.getHandlers();
         RegisteredListener[] listeners = handlers.getRegisteredListeners();
diff --git a/src/main/java/io/papermc/paper/util/misc/LoggedEvent.java b/src/main/java/io/papermc/paper/util/misc/LoggedEvent.java
new file mode 100644
index 0000000000000000000000000000000000000000..5acd61d9b679ded94c8ff424302fc5866ee0f75b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/util/misc/LoggedEvent.java
@@ -0,0 +1,67 @@
+package io.papermc.paper.util.misc;
+
+import com.google.gson.JsonObject;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.event.Event;
+import org.checkerframework.checker.nullness.qual.Nullable;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.time.LocalDateTime;
+import java.time.format.DateTimeFormatter;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * A simple event wrapper with a timestamp to allow for QoL JSon serialization
+ */
+public class LoggedEvent {
+
+    public static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd_HH.mm.ss");
+    private final String timestamp;
+    private final Event event;
+
+    public LoggedEvent(Event event) {
+        this.timestamp = FORMATTER.format(LocalDateTime.now());
+        this.event = event;
+    }
+
+    /**
+     * Properly serialize our Wrapper into a JsonObject, so we can log it properly
+     *
+     * @return Null if {@link #shouldSerialize(List)} returns false, otherwise it's your object
+     */
+    @Nullable
+    public JsonObject serialize() {
+        JsonObject parent = new JsonObject();
+        parent.addProperty("timestamp", timestamp);
+        JsonObject obj = new JsonObject();
+        obj.addProperty("event", event.getEventName());
+        try {
+            List<Field> fields = new ArrayList<>(Arrays.asList(event.getClass().getDeclaredFields()));
+            Class<?> clazz = event.getClass().getSuperclass();
+            while (clazz != null) {
+                fields.addAll(Arrays.asList(clazz.getDeclaredFields()));
+                clazz = clazz.getSuperclass();
+            }
+            if (!shouldSerialize(fields)) return null; //check current event class fields if we should serialize
+            for (Field f : fields) {
+                if (Modifier.isStatic(f.getModifiers())) continue;
+                if(f.getName().equals("name")) continue;
+                f.setAccessible(true);
+                Object field = f.get(event);
+                obj.addProperty(f.getName(), field == null ? "null" : field.toString());
+            }
+        } catch (SecurityException | IllegalAccessException ex) {
+            MinecraftServer.LOGGER.warn("Failure to serialize event " + event.getEventName(), ex);
+        }
+        parent.add("info", obj);
+        return parent;
+    }
+
+    public boolean shouldSerialize(List<Field> fields) {
+        return true;
+    }
+}
+
