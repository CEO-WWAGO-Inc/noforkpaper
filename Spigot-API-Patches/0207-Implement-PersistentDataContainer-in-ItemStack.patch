From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Nesaak <52047222+Nesaak@users.noreply.github.com>
Date: Thu, 14 May 2020 12:28:38 -0400
Subject: [PATCH] Implement PersistentDataContainer in ItemStack

This patch implements PersistentDatContainer into ItemStack.

This is done for both convenience and performance. Getting PersistentDataContainer through ItemMeta clones the ItemMeta,
in this patch we will use the ItemMeta stored in ItemStack unless there is non, which we then generate a new ItemMeta.

diff --git a/src/main/java/org/bukkit/inventory/ItemStack.java b/src/main/java/org/bukkit/inventory/ItemStack.java
index d7d6a3e83dfd88359708749f5c12be02815c3580..3e6c1ab96acc1fad2d8e2f69fb376cf2063826ac 100644
--- a/src/main/java/org/bukkit/inventory/ItemStack.java
+++ b/src/main/java/org/bukkit/inventory/ItemStack.java
@@ -25,7 +25,7 @@ import org.jetbrains.annotations.Nullable;
  * use this class to encapsulate Materials for which {@link Material#isItem()}
  * returns false.</b>
  */
-public class ItemStack implements Cloneable, ConfigurationSerializable {
+public class ItemStack implements Cloneable, ConfigurationSerializable, org.bukkit.persistence.PersistentDataContainer { // Paper - implement PersistentDataContainer
     private Material type = Material.AIR;
     private int amount = 0;
     private MaterialData data = null;
@@ -767,5 +767,42 @@ public class ItemStack implements Cloneable, ConfigurationSerializable {
         ItemMeta itemMeta = getItemMeta();
         return itemMeta.hasItemFlag(flag);
     }
+
+    @Override
+    public <T, Z> void set(@NotNull org.bukkit.NamespacedKey key, @NotNull org.bukkit.persistence.PersistentDataType<T, Z> type, @NotNull Z value) {
+        if (meta == null) setItemMeta(getItemMeta());
+        meta.getPersistentDataContainer().set(key, type, value);
+    }
+
+    @Override
+    public <T, Z> boolean has(@NotNull org.bukkit.NamespacedKey key, @NotNull org.bukkit.persistence.PersistentDataType<T, Z> type) {
+        return meta != null && meta.getPersistentDataContainer().has(key, type);
+    }
+
+    @Override
+    public <T, Z> @Nullable Z get(@NotNull org.bukkit.NamespacedKey key, @NotNull org.bukkit.persistence.PersistentDataType<T, Z> type) {
+        return (meta == null ? null : meta.getPersistentDataContainer().get(key, type));
+    }
+
+    @Override
+    public <T, Z> @NotNull Z getOrDefault(@NotNull org.bukkit.NamespacedKey key, @NotNull org.bukkit.persistence.PersistentDataType<T, Z> type, @NotNull Z defaultValue) {
+        return (meta == null ? defaultValue : meta.getPersistentDataContainer().getOrDefault(key, type, defaultValue));
+    }
+
+    @Override
+    public void remove(@NotNull org.bukkit.NamespacedKey key) {
+        if (meta != null) meta.getPersistentDataContainer().remove(key);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return meta == null || meta.getPersistentDataContainer().isEmpty();
+    }
+
+    @Override
+    public @NotNull org.bukkit.persistence.PersistentDataAdapterContext getAdapterContext() {
+        if (meta == null) setItemMeta(getItemMeta());
+        return meta.getPersistentDataContainer().getAdapterContext();
+    }
     // Paper end
 }
