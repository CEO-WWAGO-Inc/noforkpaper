From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: RyGuy <TheRealRyGuy@users.noreply.github.com>
Date: Tue, 21 Mar 2023 16:21:07 -0400
Subject: [PATCH] New event verbose logging command


diff --git a/src/main/java/io/papermc/paper/command/PaperCommand.java b/src/main/java/io/papermc/paper/command/PaperCommand.java
index 7ba60b4b4f29a42c58d98aafc5ea0fa3214f554c..652c7df2c783de56b947535ff25781b0af47fbf0 100644
--- a/src/main/java/io/papermc/paper/command/PaperCommand.java
+++ b/src/main/java/io/papermc/paper/command/PaperCommand.java
@@ -45,6 +45,7 @@ public final class PaperCommand extends Command {
         commands.put(Set.of("dumpitem"), new DumpItemCommand());
         commands.put(Set.of("mobcaps", "playermobcaps"), new MobcapsCommand());
         commands.put(Set.of("dumplisteners"), new DumpListenersCommand());
+        commands.put(Set.of("dumpevents"), new EventVerboseCommand());
 
         return commands.entrySet().stream()
             .flatMap(entry -> entry.getKey().stream().map(s -> Map.entry(s, entry.getValue())))
diff --git a/src/main/java/io/papermc/paper/command/subcommands/EventVerboseCommand.java b/src/main/java/io/papermc/paper/command/subcommands/EventVerboseCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..165bb5324aa06e4bd204a570b45b185b0bd11a84
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/subcommands/EventVerboseCommand.java
@@ -0,0 +1,160 @@
+package io.papermc.paper.command.subcommands;
+
+import com.destroystokyo.paper.event.server.ServerTickEndEvent;
+import com.destroystokyo.paper.event.server.ServerTickStartEvent;
+import com.google.common.collect.Lists;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.google.gson.internal.Streams;
+import com.google.gson.stream.JsonWriter;
+import io.papermc.paper.command.PaperSubcommand;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.CommandSender;
+import org.bukkit.event.Event;
+import org.bukkit.inventory.ItemStack;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.io.IOException;
+import java.io.PrintStream;
+import java.io.StringWriter;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.time.LocalDateTime;
+import java.time.format.DateTimeFormatter;
+import java.util.Collection;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Stream;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.GREEN;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+
+@DefaultQualifier(NonNull.class)
+public class EventVerboseCommand implements PaperSubcommand {
+
+    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd_HH.mm.ss");
+    @Nullable private Path currentFile;
+    //have to be static to static call from paperpluginmanagerimpl
+    private static boolean isRunning = false;
+    private static final LinkedList<Wrapper> toDump = Lists.newLinkedList();
+    //ignore unnecessary events
+    private static final List<Class<? extends Event>> exclude = List.of(ServerTickStartEvent.class,
+        ServerTickEndEvent.class);
+
+
+    @Override
+    public boolean execute(CommandSender sender, String subCommand, String[] args) {
+        if(!isRunning) {
+            isRunning = true;
+            Path parent = Path.of("debug");
+            Path path = parent.resolve("event-verbose-" + FORMATTER.format(LocalDateTime.now()) + ".txt");
+            try {
+                Files.createDirectories(parent);
+                currentFile = Files.createFile(path);
+                sender.sendMessage(text("Now storing event verbose, run this command again to save your file", GREEN));
+            } catch (IOException e) {
+                sender.sendMessage(text("Failed to create event verbose files! See the console for more info.", RED));
+                MinecraftServer.LOGGER.warn("Error occurred while creating event verbose files", e);
+                isRunning = false;
+            }
+        }else {
+            isRunning = false;
+            sender.sendMessage(text("Logging events..", GREEN));
+            try {
+                logWrappers();
+                sender.sendMessage(text("Logged all event verbose to " + currentFile, GREEN));
+                currentFile = null;
+                toDump.clear();
+            }catch(IOException e) {
+                sender.sendMessage(text("Failed to create event verbose files! See the console for more info.", RED));
+                MinecraftServer.LOGGER.warn("Error occurred while dumping event verbose", e);
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Dumps all currently stored {@link Wrapper}'s to our {@link #currentFile}
+     * @throws IOException If something broke writing it
+     */
+    private void logWrappers() throws IOException {
+        JsonArray array = new JsonArray();
+        toDump.forEach(w -> {
+            @Nullable JsonObject obj = w.serialize();
+            if(obj != null) //will only be null if an event class only has final fields
+                array.add(obj);
+        });
+
+        StringWriter stringWriter = new StringWriter();
+        JsonWriter jsonWriter = new JsonWriter(stringWriter);
+        jsonWriter.setIndent(" ");
+        jsonWriter.setLenient(false);
+        Streams.write(array, jsonWriter);
+
+        try (PrintStream out = new PrintStream(Files.newOutputStream(currentFile), false, StandardCharsets.UTF_8)) {
+            out.print(stringWriter);
+        }
+
+    }
+
+    /**
+     * Called in {@link io.papermc.paper.plugin.manager.PaperPluginManagerImpl#callEvent(Event)} to save in {@link #toDump}
+     */
+    public static void tryLogEvent(Event ev) {
+        if(!isRunning)
+            return;
+        if(exclude.contains(ev.getClass()))
+            return;
+        toDump.add(new Wrapper(ev));
+    }
+
+    /**
+     * Wrapper class for QoL Serialization, just stores the event object and the time it ran to log eventually
+     */
+    private static final class Wrapper {
+        private final String timestamp;
+        private final Event event;
+
+        public Wrapper(Event event) {
+            this.timestamp = FORMATTER.format(LocalDateTime.now());
+            this.event = event;
+        }
+
+        @Nullable
+        /**
+         * Properly serialize our Wrapper into a JsonObject, so we can log it properly
+         * @implNote Is null if the event has only final fields
+         */
+        private JsonObject serialize() {
+            JsonObject parent = new JsonObject();
+            parent.addProperty("timestamp", timestamp);
+            JsonObject obj = new JsonObject();
+            obj.addProperty("event", event.getEventName());
+            try {
+                Field[] fields = event.getClass().getDeclaredFields();
+                //ignore update events / anything unchangeable except for ItemStacks, Collections and Maps
+                if(Stream.of(fields).allMatch(f -> Modifier.isFinal(f.getModifiers()) && !f.getType().equals(ItemStack.class) &&
+                    !Map.class.isAssignableFrom(f.getType()) && !Collection.class.isAssignableFrom(f.getType())))
+                    return null;
+                for (Field f : fields) {
+                    if(f.getName().equalsIgnoreCase("handlers"))
+                        continue;
+                    f.setAccessible(true);
+                    Object field = f.get(event);
+                    obj.addProperty(f.getName(), field == null ? "null" : field.toString());
+                }
+            } catch(SecurityException | IllegalAccessException ex) {
+                MinecraftServer.LOGGER.warn("Failure to serialize event verbose", ex);
+            }
+            parent.add("info", obj);
+            return parent;
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
index 7ce9ebba8ce304d1f3f21d4f15ee5f3560d7700b..dfb91cb8e19e0159e0eba9367ca7396125da6d1c 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
@@ -4,6 +4,7 @@ import co.aikar.timings.TimedEventExecutor;
 import com.destroystokyo.paper.event.server.ServerExceptionEvent;
 import com.destroystokyo.paper.exception.ServerEventException;
 import com.google.common.collect.Sets;
+import io.papermc.paper.command.subcommands.EventVerboseCommand;
 import org.bukkit.Server;
 import org.bukkit.Warning;
 import org.bukkit.event.Event;
@@ -41,6 +42,7 @@ class PaperEventManager {
         } else if (!event.isAsynchronous() && !this.server.isPrimaryThread() && !this.server.isStopping()) {
             throw new IllegalStateException(event.getEventName() + " may only be triggered synchronously.");
         }
+        EventVerboseCommand.tryLogEvent(event);
 
         HandlerList handlers = event.getHandlers();
         RegisteredListener[] listeners = handlers.getRegisteredListeners();
