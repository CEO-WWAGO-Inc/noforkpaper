From 0b5fcbc7b17ce0381ed6f3d786754a07089c0dd7 Mon Sep 17 00:00:00 2001
From: slicklibro <slicklibro@gmail.com>
Date: Fri, 20 Sep 2019 17:16:14 +1200
Subject: [PATCH] Ticket level per-player view distance API

This PR implements the per-player view distance API at the ticket level.
This somewhat clean solution comes from the result of many complicated ones (and research).
The view distance will determine how far the player can add tickets to chunks.
The tracking view distance will determine how far the player can see/load chunks with tickets.
All chunks with player tickets within this range will also be served by the server, allowing shared view distance from other players without impacting performance.

diff --git a/src/main/java/com/destroystokyo/paper/util/PlayerMobDistanceMap.java b/src/main/java/com/destroystokyo/paper/util/PlayerMobDistanceMap.java
index 9ebd7ecb..c8a297c2 100644
--- a/src/main/java/com/destroystokyo/paper/util/PlayerMobDistanceMap.java
+++ b/src/main/java/com/destroystokyo/paper/util/PlayerMobDistanceMap.java
@@ -32,14 +32,19 @@ public final class PlayerMobDistanceMap {
         return this.playerMap.getOrDefault(ChunkCoordIntPair.pair(chunkX, chunkZ), EMPTY_SET);
     }
 
-    public void update(final List<EntityPlayer> currentPlayers, final int newViewDistance) {
+    public void update(final List<EntityPlayer> currentPlayers) { //Paper ticket level pp-view-dis
         AsyncCatcher.catchOp("Distance map update");
         final ObjectLinkedOpenHashSet<EntityPlayer> gone = new ObjectLinkedOpenHashSet<>(this.players.keySet());
 
-        final int oldViewDistance = this.viewDistance;
-        this.viewDistance = newViewDistance;
+        //Paper start ticket level pp-view-dist
+        //final int oldViewDistance = this.viewDistance;
+        //this.viewDistance = newViewDistance;
 
         for (final EntityPlayer player : currentPlayers) {
+            player.oldMobViewDistance = player.mobViewDistance;
+            player.mobViewDistance = player.getTrackViewDistance();
+            //Paper end
+
             if (player.isSpectator() || !player.affectsSpawning) {
                 continue; // will be left in 'gone' (or not added at all)
             }
@@ -50,9 +55,10 @@ public final class PlayerMobDistanceMap {
             final SectionPosition oldPosition = this.players.put(player, newPosition);
 
             if (oldPosition == null) {
-                this.addNewPlayer(player, newPosition, newViewDistance);
+                this.addNewPlayer(player, newPosition, player.mobViewDistance); //Paper ticket level pp-view-dist
             } else {
-                this.updatePlayer(player, oldPosition, newPosition, oldViewDistance, newViewDistance);
+                this.updatePlayer(player, oldPosition, newPosition, player.oldMobViewDistance, player.mobViewDistance); //Paper ticket level pp-view-dist
+
             }
             //this.validatePlayer(player, newViewDistance); // debug only
         }
@@ -60,7 +66,7 @@ public final class PlayerMobDistanceMap {
         for (final EntityPlayer player : gone) {
             final SectionPosition oldPosition = this.players.remove(player);
             if (oldPosition != null) {
-                this.removePlayer(player, oldPosition, oldViewDistance);
+                this.removePlayer(player, oldPosition, player.oldMobViewDistance); //Paper ticket level pp-view-dist
             }
         }
     }
diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index 63a68872..a24eaefc 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -43,6 +43,7 @@ public abstract class ChunkMapDistance {
     private final LongSet l = new LongOpenHashSet();
     private final Executor m;
     private long currentTick;
+    private ChunkMapDistance.c getPlayerTicketTracker() {return this.g;} //Paper OBFHELPER
 
     protected ChunkMapDistance(Executor executor, Executor executor1) {
         executor1.getClass();
@@ -234,6 +235,7 @@ public abstract class ChunkMapDistance {
         ((ObjectSet) this.c.computeIfAbsent(i, (j) -> {
             return new ObjectOpenHashSet();
         })).add(entityplayer);
+        this.getPlayerTicketTracker().update(entityplayer, i); //Paper ticket level pp-view-dist
         this.f.b(i, 0, true);
         this.g.b(i, 0, true);
     }
@@ -251,6 +253,10 @@ public abstract class ChunkMapDistance {
 
     }
 
+    public void fullRemove(EntityPlayer player) {
+        this.getPlayerTicketTracker().remove(player); //Paper ticket level pp-view-dist
+    }
+
     protected String c(long i) {
         ObjectSortedSet<Ticket<?>> objectsortedset = (ObjectSortedSet) this.tickets.get(i);
         String s;
@@ -353,6 +359,18 @@ public abstract class ChunkMapDistance {
         private int e = 0;
         private final Long2IntMap f = Long2IntMaps.synchronize(new Long2IntOpenHashMap());
         private final LongSet g = new LongOpenHashSet();
+        //Paper start ticket level pp-view-dist
+        protected static final int ADD = 1;
+        protected static final int REMOVE = -1;
+        protected final it.unimi.dsi.fastutil.ints.Int2ObjectMap<Square> squares = new it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap<>();
+        protected it.unimi.dsi.fastutil.longs.Long2ByteMap update = new it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap();
+        class Square {
+            public int x, z, u, v, action;
+            public Square(int x1, int z1, int u1, int v1, int action1) {
+                x = x1; z = z1; u = u1; v = v1; action = action1;
+            }
+        }
+        //Paper end
 
         protected c(int i) {
             super(i);
@@ -372,20 +390,20 @@ public abstract class ChunkMapDistance {
                 byte b0 = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getByteValue();
                 long j = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getLongKey();
 
-                this.a(j, b0, this.c(b0), b0 <= i - 2);
+                this.a(j, b0, this.c(b0), b0 <= i - 2, i); //Paper ticket level pp-view-dist
             }
 
             this.e = i;
         }
 
-        private void a(long i, int j, boolean flag, boolean flag1) {
+        private void a(long i, int j, boolean flag, boolean flag1, int vd) { //Paper ticket level pp-view-dist
             if (flag != flag1) {
                 Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, ChunkMapDistance.b, new ChunkCoordIntPair(i), ChunkMapDistance.this.currentTick);
 
                 if (flag1) {
                     ChunkMapDistance.this.j.a(ChunkTaskQueueSorter.a(() -> { // Craftbukkit - decompile error
                         ChunkMapDistance.this.m.execute(() -> {
-                            if (this.c(this.c(i))) {
+                            if (this.c(i) <= vd) { //Paper ticket level pp-view-dist
                                 ChunkMapDistance.this.addTicket(i, ticket);
                                 ChunkMapDistance.this.l.add(i);
                             } else {
@@ -430,14 +448,207 @@ public abstract class ChunkMapDistance {
                             }
 
                         });
-                        this.a(i, k, this.c(j), this.c(k));
                     }
-                }
 
+                    //Paper start ticket level pp-view-dist
+                    //attach update queue to default queue
+                    byte f = this.update.remove(i);
+                    if(f == ADD) {
+                        this.a(i, k, false, true, Integer.MAX_VALUE);
+                    } else if (f == REMOVE) {
+                        this.a(i, k, true, false, Integer.MAX_VALUE);
+                    }
+                }
                 this.g.clear();
             }
 
+            /**
+             * base logic note for ticket level pp vdist
+             *
+             * in the default update queue, only changed minimum levels are updated
+             * this poses issues when view distances overlap, as we hit a midpoint barrier
+             *
+             * e.g overlapping levels which do not surpass the peak midpoint
+             * p1 has vd of 8, p2 has vd of 2, p1 and p2 have 9 chunks in between
+             * p1 1 2 3 4 5 4 3 2 1 p2
+             * p1 x x x x x x x y y y
+             * x are tickets added by p1, and y are tickets added by p2, we want the action above.
+             * in reality however this happens as only chunks before the midpoint are updated by mojang's default queue when p1 moves
+             * p1 1 2 3 4 5 4 3 2 1 p2
+             * p1 x x x x _ _ _ y y y
+             * _ represents unloaded chunks without tickets, thus this default model fails and we must use an algorithm to account for overlaps & all cases efficiently
+             *
+             * using coordinate compression we graph overlapping squares & squares that need action to compressed cells accordingly
+             * we extract the corner coordinates of each filled cell that requires an action, loop through the coordinates and add the pos pairs accordingly to our update queue
+             *
+             * in the update queue handling above, we attach all updates to the default queue (before the midpoint)
+             * in the update queue below, we handle everything the default queue does not handle (past the midpoint)
+             *
+             * we must attach updates in this manner to maintain the integrity of the priority queue sorter/throttler by using default level values
+             *
+             * slicklibro
+             **/
+
+            if (!this.update.isEmpty()) {
+                ObjectIterator<it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry> it = this.update.long2ByteEntrySet().iterator();
+
+                while(it.hasNext()) {
+                    it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry e = it.next();
+                    long i = e.getLongKey();
+                    byte f = e.getByteValue();
+                    if(f == ADD) {
+                        this.a(i, this.c(i), false, true, Integer.MAX_VALUE);
+                    } else if (f == REMOVE) {
+                        this.a(i, this.c(i), true, false, Integer.MAX_VALUE);
+                    }
+                }
+
+                this.update.clear();
+            }
+            //Paper end
+
+        }
+
+        //Paper start ticket level pp-view-dist
+        public void update(EntityPlayer entityplayer, long i) {
+            int cx = ChunkCoordIntPair.getX(i);
+            int cz = ChunkCoordIntPair.getZ(i);
+            int pvd = entityplayer.getViewDistance() - 2;
+
+            //algorithm that graphs coordinate compressed map of squares overlapping current player's squares that need to be updated, as well as any squares that need to be purged
+            Square currSqr = new Square(cx - pvd, cz - pvd, cx + pvd + 1, cz + pvd + 1, 0);
+            Square old = this.squares.get(entityplayer.getUniqueID().hashCode());
+            boolean flag = false;
+            this.squares.put(entityplayer.getUniqueID().hashCode(), new Square(cx - pvd, cz - pvd, cx + pvd + 1, cz + pvd + 1, 0));
+
+            if (old == null || old == this.squares.defaultReturnValue()) {  flag = true; old = currSqr; }
+            Square lastSqr = new Square(old.x, old.z, old.u, old.v, old.action);
+
+            //row & col must be sorted to represent cells correctly, treeset to perform headSet().size() to obtain index
+            it.unimi.dsi.fastutil.ints.IntSortedSet row = new it.unimi.dsi.fastutil.ints.IntRBTreeSet(it.unimi.dsi.fastutil.ints.IntComparators.NATURAL_COMPARATOR);
+            it.unimi.dsi.fastutil.ints.IntSortedSet col = new it.unimi.dsi.fastutil.ints.IntRBTreeSet(it.unimi.dsi.fastutil.ints.IntComparators.NATURAL_COMPARATOR);
+            it.unimi.dsi.fastutil.objects.ObjectList<Square> toproc = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+
+            //assign appropriate actions to squares
+            lastSqr.action = REMOVE; currSqr.action = ADD;
+            toproc.add(lastSqr); toproc.add(currSqr);
+            row.add(lastSqr.z); row.add(lastSqr.v); col.add(lastSqr.x); col.add(lastSqr.u);
+            row.add(currSqr.z); row.add(currSqr.v); col.add(currSqr.x); col.add(currSqr.u);
+
+            //if both the player's last square and new square overlap, form intersect square and add that to process
+            if (lastSqr.x < currSqr.u && lastSqr.u > currSqr.x && lastSqr.z < currSqr.v && lastSqr.v > currSqr.z && !flag) {
+                Square ovdsqr = new Square(Math.max(lastSqr.x, currSqr.x), Math.max(lastSqr.z, currSqr.z), Math.min(lastSqr.u, currSqr.u), Math.min(lastSqr.v, currSqr.v), 0);
+                toproc.add(ovdsqr);
+                row.add(ovdsqr.z); row.add(ovdsqr.v); col.add(ovdsqr.x); col.add(ovdsqr.u);
+            }
+
+            //iterate through all squares and only add squares that overlap the last/curr squares to process
+            ObjectIterator<it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry<Square>> sqriterator = this.squares.int2ObjectEntrySet().iterator();
+            while (sqriterator.hasNext()) {
+                it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry<Square> e = sqriterator.next();
+                int uid = e.getIntKey();
+                Square sqr = e.getValue();
+                if (uid == entityplayer.getUniqueID().hashCode()) continue;
+                //check if square overlaps, if so add it to process
+                if ((sqr.x < currSqr.u && sqr.u > currSqr.x && sqr.z < currSqr.v && sqr.v > currSqr.z) ||
+                    (sqr.x < lastSqr.u && sqr.u > lastSqr.x && sqr.z < lastSqr.v && sqr.v > lastSqr.z)) {
+                    toproc.add(sqr);
+                    row.add(sqr.z); row.add(sqr.v); col.add(sqr.x); col.add(sqr.u);
+                }
+            }
+
+            it.unimi.dsi.fastutil.objects.ObjectListIterator<Square> it = toproc.iterator();
+            //coordinate compress & fill map with squares to process (in correct order to form overlapped map)
+            int[][] grid = new int[row.size()][col.size()];
+
+            while (it.hasNext()) {
+                Square sqr = it.next();
+                for (int s = row.headSet(sqr.z).size(); s < row.headSet(sqr.v).size(); s++) {
+                    for (int t = col.headSet(sqr.x).size(); t < col.headSet(sqr.u).size(); t++) {
+                        grid[s][t] = sqr.action;
+                    }
+                }
+            }
+
+            //check against cells on filled map
+            int[] rw = row.toIntArray(); int[] cl = col.toIntArray();
+            for (int s = 0; s < row.size() - 1; s++) {
+                for (int t = 0; t < col.size() - 1; t++) {
+                    if (grid[s][t] == REMOVE) {
+                        //decompress/loop through coordinates and queue to update
+                        for (int x = cl[t]; x < cl[t + 1]; x++) {
+                            for (int z = rw[s]; z < rw[s + 1]; z++) {
+                                long pair = ChunkCoordIntPair.asLong(x, z);
+                                update.put(pair, (byte) REMOVE);
+                            }
+                        }
+
+                    } else if (grid[s][t] == ADD) {
+                        for (int x = cl[t]; x < cl[t + 1]; x++) {
+                            for (int z = rw[s]; z < rw[s + 1]; z++) {
+                                long pair = ChunkCoordIntPair.asLong(x, z);
+                                update.put(pair, (byte) ADD);
+                            }
+                        }
+                    }
+                }
+
+            }
+
+        }
+
+        public void remove(EntityPlayer entityplayer) {
+            //similar to above, this time dealing with full removal
+            Square remSqr = this.squares.remove(entityplayer.getUniqueID().hashCode());
+            if(remSqr != null && remSqr != this.squares.defaultReturnValue()) {
+
+                it.unimi.dsi.fastutil.ints.IntSortedSet row = new it.unimi.dsi.fastutil.ints.IntRBTreeSet(it.unimi.dsi.fastutil.ints.IntComparators.NATURAL_COMPARATOR);
+                it.unimi.dsi.fastutil.ints.IntSortedSet col = new it.unimi.dsi.fastutil.ints.IntRBTreeSet(it.unimi.dsi.fastutil.ints.IntComparators.NATURAL_COMPARATOR);
+                it.unimi.dsi.fastutil.objects.ObjectList<Square> toproc = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+                ObjectIterator<it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry<Square>> sqriterator = this.squares.int2ObjectEntrySet().iterator();
+
+                remSqr.action = REMOVE;
+                toproc.add(remSqr);
+                row.add(remSqr.z); row.add(remSqr.v); col.add(remSqr.x); col.add(remSqr.u);
+
+                while (sqriterator.hasNext()) {
+                    it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry<Square> e = sqriterator.next();
+                    Square sqr = e.getValue();
+                    if (sqr.x < remSqr.u && sqr.u > remSqr.x && sqr.z < remSqr.v && sqr.v > remSqr.z) {
+                        toproc.add(sqr);
+                        row.add(sqr.z); row.add(sqr.v); col.add(sqr.x); col.add(sqr.u);
+                    }
+                }
+
+                it.unimi.dsi.fastutil.objects.ObjectListIterator<Square> it = toproc.iterator();
+
+                int[][] grid = new int[row.size()][col.size()];
+
+                while (it.hasNext()) {
+                    Square sqr = it.next();
+                    for (int s = row.headSet(sqr.z).size(); s < row.headSet(sqr.v).size(); s++) {
+                        for (int t = col.headSet(sqr.x).size(); t < col.headSet(sqr.u).size(); t++) {
+                            grid[s][t] = sqr.action;
+                        }
+                    }
+                }
+
+                int[] rw = row.toIntArray(); int[] cl = col.toIntArray();
+                for (int s = 0; s < row.size() - 1; s++) {
+                    for (int t = 0; t < col.size() - 1; t++) {
+                        if (grid[s][t] == REMOVE) {
+                            for (int x = cl[t]; x < cl[t + 1]; x++) {
+                                for (int z = rw[s]; z < rw[s + 1]; z++) {
+                                    long pair = ChunkCoordIntPair.asLong(x, z);
+                                    update.put(pair, (byte) REMOVE);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
         }
+        //Paper end
 
         private boolean c(int i) {
             return i <= this.e - 2;
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index e7539dd7..da72f2bd 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -560,7 +560,7 @@ public class ChunkProviderServer extends IChunkProvider {
             if (this.playerChunkMap.playerMobDistanceMap != null) {
                 // update distance map
                 this.world.timings.playerMobDistanceMapUpdate.startTiming();
-                this.playerChunkMap.playerMobDistanceMap.update(this.world.players, this.playerChunkMap.viewDistance);
+                this.playerChunkMap.playerMobDistanceMap.update(this.world.players); //Paper ticket level pp-view-dist
                 this.world.timings.playerMobDistanceMapUpdate.stopTiming();
                 // re-set mob counts
                 for (EntityPlayer player : this.world.players) {
diff --git a/src/main/java/net/minecraft/server/EntityEnderDragon.java b/src/main/java/net/minecraft/server/EntityEnderDragon.java
index c8c74f2b..6a84a1a5 100644
--- a/src/main/java/net/minecraft/server/EntityEnderDragon.java
+++ b/src/main/java/net/minecraft/server/EntityEnderDragon.java
@@ -570,9 +570,9 @@ public class EntityEnderDragon extends EntityInsentient implements IMonster {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1028, new BlockPosition(this), 0);
                 // Paper start
-                int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
+                //int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
-                    //final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = player.getTrackViewDistance() * 16; //Paper ticket level pp-view-dist
                     // Paper end
                     double deltaX = this.locX - player.locX;
                     double deltaZ = this.locZ - player.locZ;
diff --git a/src/main/java/net/minecraft/server/EntityHuman.java b/src/main/java/net/minecraft/server/EntityHuman.java
index cd73cde8..f53e7de9 100644
--- a/src/main/java/net/minecraft/server/EntityHuman.java
+++ b/src/main/java/net/minecraft/server/EntityHuman.java
@@ -80,6 +80,40 @@ public abstract class EntityHuman extends EntityLiving {
     public String spawnWorld = "";
     public int oldLevel = -1;
 
+    //Paper start ticket level pp-view-dist
+    private int viewDistance;
+    private int trackViewDistance;
+    public int lastViewDistance;
+    public int lastTrackViewDistance;
+    public int mobViewDistance;
+    public int oldMobViewDistance;
+    public int getViewDistance() { return this.viewDistance; }
+    public int getTicketViewDistance() { return this.viewDistance; }
+    public int getTrackViewDistance() { return this.trackViewDistance; }
+    public void setTrackViewDistance(int trackViewDistance) {
+        this.lastTrackViewDistance = this.trackViewDistance;
+        this.trackViewDistance = MathHelper.clamp(trackViewDistance, this.viewDistance, 33);
+        if(this.lastTrackViewDistance != this.trackViewDistance) this.updateViewDistancePackets();
+    }
+    public void setTicketViewDistance(int ticketViewDistance) {
+        this.lastViewDistance = this.viewDistance;
+        this.viewDistance = MathHelper.clamp(ticketViewDistance, 3, this.trackViewDistance);
+    }
+    public void setViewDistance(int viewDistance) {
+        this.lastViewDistance = this.viewDistance;
+        this.viewDistance = MathHelper.clamp(viewDistance, 3, 33);
+        this.setTrackViewDistance(viewDistance);
+    }
+    public void updateViewDistancePackets() {
+        if(this instanceof EntityPlayer) {
+            if(((EntityPlayer) this).playerConnection != null) {
+                ((EntityPlayer) this).playerConnection.sendPacket(new PacketPlayOutViewDistance(this.trackViewDistance));
+                ((WorldServer) this.world).getChunkProvider().playerChunkMap.updateTrackViewDistance((EntityPlayer) this, this.trackViewDistance);
+            }
+        }
+    }
+    //Paper end
+
     @Override
     public CraftHumanEntity getBukkitEntity() {
         return (CraftHumanEntity) super.getBukkitEntity();
@@ -98,6 +132,9 @@ public abstract class EntityHuman extends EntityLiving {
 
         this.setPositionRotation((double) blockposition.getX() + 0.5D, (double) (blockposition.getY() + 1), (double) blockposition.getZ() + 0.5D, 0.0F, 0.0F);
         this.aX = 180.0F;
+        this.setViewDistance(this.world.spigotConfig.viewDistance); //Paper ticket level pp-view-dist
+        this.mobViewDistance = this.getTrackViewDistance();
+        this.oldMobViewDistance = this.mobViewDistance;
     }
 
     public boolean a(World world, BlockPosition blockposition, EnumGamemode enumgamemode) {
diff --git a/src/main/java/net/minecraft/server/EntityLightning.java b/src/main/java/net/minecraft/server/EntityLightning.java
index 27bf271b..7580f1da 100644
--- a/src/main/java/net/minecraft/server/EntityLightning.java
+++ b/src/main/java/net/minecraft/server/EntityLightning.java
@@ -59,8 +59,9 @@ public class EntityLightning extends Entity {
             // CraftBukkit start - Use relative location for far away sounds
             // this.world.playSound((EntityHuman) null, this.locX, this.locY, this.locZ, SoundEffects.ENTITY_LIGHTNING_BOLT_THUNDER, SoundCategory.WEATHER, 10000.0F, 0.8F + this.random.nextFloat() * 0.2F);
             float pitch = 0.8F + this.random.nextFloat() * 0.2F;
-            int viewDistance = ((WorldServer) this.world).getServer().getViewDistance() * 16;
+            //int viewDistance = ((WorldServer) this.world).getServer().getViewDistance() * 16;
             for (EntityPlayer player : (List<EntityPlayer>) (List) this.world.getPlayers()) {
+                int viewDistance = player.getTrackViewDistance() * 16; //Paper ticket level pp-view-dist
                 double deltaX = this.locX - player.locX;
                 double deltaZ = this.locZ - player.locZ;
                 double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/server/EntityWither.java b/src/main/java/net/minecraft/server/EntityWither.java
index 8b3052b1..dc2ff948 100644
--- a/src/main/java/net/minecraft/server/EntityWither.java
+++ b/src/main/java/net/minecraft/server/EntityWither.java
@@ -208,9 +208,9 @@ public class EntityWither extends EntityMonster implements IRangedEntity {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1023, new BlockPosition(this), 0);
                 // Paper start
-                int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
+                //int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
-                    //final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = player.getTrackViewDistance() * 16; //Paper ticket level pp-view-dist
                     // Paper end
                     double deltaX = this.locX - player.locX;
                     double deltaZ = this.locZ - player.locZ;
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 59e74900..9004c458 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -935,30 +935,33 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     protected void setViewDistance(int i) {
         int j = MathHelper.clamp(i + 1, 3, 33);
+        //Paper start ticket level pp-view-dist
+        this.chunkDistanceManager.a(j);
+        this.viewDistance = j;
 
-        if (j != this.viewDistance) {
-            int k = this.viewDistance;
-
-            this.viewDistance = j;
-            this.chunkDistanceManager.a(this.viewDistance);
-            ObjectIterator objectiterator = this.updatingChunks.values().iterator();
+        if(this.world.players != null && !this.world.players.isEmpty()) {
+            for (EntityPlayer player : this.world.players) {
+                player.setViewDistance(j);
+            }
+        }
+        //Paper end
+    }
 
-            while (objectiterator.hasNext()) {
-                PlayerChunk playerchunk = (PlayerChunk) objectiterator.next();
-                ChunkCoordIntPair chunkcoordintpair = playerchunk.i();
+    //Paper start ticket level pp-view-dist
+    public void updateTrackViewDistance(EntityPlayer player, int i) {
+        for (int x = player.chunkX - i; x <= player.chunkX + i; ++x) {
+            for (int z = player.chunkZ - i; z <= player.chunkZ + i; ++z) {
+                ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(x, z);
                 Packet<?>[] apacket = new Packet[2];
+                int i1 = b(chunkcoordintpair, player, true);
+                boolean flag = i1 <= player.lastTrackViewDistance;
+                boolean flag1 = i1 <= i;
 
-                this.a(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    int l = b(chunkcoordintpair, entityplayer, true);
-                    boolean flag = l <= k;
-                    boolean flag1 = l <= this.viewDistance;
-
-                    this.sendChunk(entityplayer, chunkcoordintpair, apacket, flag, flag1);
-                });
+                this.sendChunk(player, chunkcoordintpair, apacket, flag, flag1);
             }
         }
-
     }
+    //Paper end
 
     protected void sendChunk(EntityPlayer entityplayer, ChunkCoordIntPair chunkcoordintpair, Packet<?>[] apacket, boolean flag, boolean flag1) {
         if (entityplayer.world == this.world) {
@@ -973,6 +976,8 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                     }
 
                     PacketDebug.a(this.world, chunkcoordintpair);
+                } else {
+                    entityplayer.a(chunkcoordintpair); //Paper ticket level pp-view-dist
                 }
             }
 
@@ -1201,21 +1206,21 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     boolean isOutsideOfRange(ChunkCoordIntPair chunkcoordintpair, boolean reducedRange) {
-        int chunkRange = world.spigotConfig.mobSpawnRange;
-        chunkRange = (chunkRange > world.spigotConfig.viewDistance) ? (byte) world.spigotConfig.viewDistance : chunkRange;
-        chunkRange = (chunkRange > 8) ? 8 : chunkRange;
-
-        final int finalChunkRange = chunkRange; // Paper for lambda below
         //double blockRange = (reducedRange) ? Math.pow(chunkRange << 4, 2) : 16384.0D; // Paper - use from event
         // Spigot end
         long i = chunkcoordintpair.pair();
 
         return !this.chunkDistanceManager.d(i) ? true : this.playerMap.a(i).noneMatch((entityplayer) -> {
+            //Paper start ticket level pp-view-dist
+            int playerChunkRange = world.spigotConfig.mobSpawnRange;
+            playerChunkRange = (playerChunkRange > entityplayer.getTrackViewDistance()) ? (byte) entityplayer.getTrackViewDistance() : playerChunkRange;
+            playerChunkRange = (playerChunkRange > 8) ? 8 : playerChunkRange;
+            //Paper end
             // Paper start -
             com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent event;
             double blockRange = 16384.0D;
             if (reducedRange) {
-                event = new com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent(entityplayer.getBukkitEntity(), (byte) finalChunkRange);
+                event = new com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent(entityplayer.getBukkitEntity(), (byte) playerChunkRange); //Paper ticket level pp-view-dist
                 event.callEvent();
                 blockRange = (double) ((event.getSpawnRadius() << 4) * (event.getSpawnRadius() << 4));
                 if (event.isCancelled()) return true;
@@ -1251,8 +1256,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             }
         }
 
-        for (int k = i - this.viewDistance; k <= i + this.viewDistance; ++k) {
-            for (int l = j - this.viewDistance; l <= j + this.viewDistance; ++l) {
+        //Paper start ticket level pp-view-dist
+        int playerViewDistance = entityplayer.getTrackViewDistance();
+        for (int k = i - playerViewDistance; k <= i + playerViewDistance; ++k) {
+            for (int l = j - playerViewDistance; l <= j + playerViewDistance; ++l) {
+                //Paper end
                 ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k, l);
 
                 this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], !flag, flag);
@@ -1320,18 +1328,20 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         int k1;
         int l1;
 
-        if (Math.abs(i1 - i) <= this.viewDistance * 2 && Math.abs(j1 - j) <= this.viewDistance * 2) {
-            k1 = Math.min(i, i1) - this.viewDistance;
-            l1 = Math.min(j, j1) - this.viewDistance;
-            int i2 = Math.max(i, i1) + this.viewDistance;
-            int j2 = Math.max(j, j1) + this.viewDistance;
+        //Paper start ticket level pp-view-dist
+        int playerViewDistance = entityplayer.getTrackViewDistance();
+        if (Math.abs(i1 - i) <= playerViewDistance * 2 && Math.abs(j1 - j) <= playerViewDistance * 2) {
+            k1 = Math.min(i, i1) - playerViewDistance;
+            l1 = Math.min(j, j1) - playerViewDistance;
+            int i2 = Math.max(i, i1) + playerViewDistance;
+            int j2 = Math.max(j, j1) + playerViewDistance;
 
             for (int k2 = k1; k2 <= i2; ++k2) {
                 for (int l2 = l1; l2 <= j2; ++l2) {
                     ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k2, l2);
-                    boolean flag3 = a(chunkcoordintpair, i1, j1) <= this.viewDistance;
-                    boolean flag4 = a(chunkcoordintpair, i, j) <= this.viewDistance;
-
+                    boolean flag3 = a(chunkcoordintpair, i1, j1) <= playerViewDistance;
+                    boolean flag4 = a(chunkcoordintpair, i, j) <= playerViewDistance;
+                    //Paper end
                     this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], flag3, flag4);
                 }
             }
@@ -1340,8 +1350,10 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             boolean flag5;
             boolean flag6;
 
-            for (k1 = i1 - this.viewDistance; k1 <= i1 + this.viewDistance; ++k1) {
-                for (l1 = j1 - this.viewDistance; l1 <= j1 + this.viewDistance; ++l1) {
+            //Paper start ticket level pp-view-dist
+            for (k1 = i1 - playerViewDistance; k1 <= i1 + playerViewDistance; ++k1) {
+                for (l1 = j1 - playerViewDistance; l1 <= j1 + playerViewDistance; ++l1) {
+                    //Paper end
                     chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
                     flag5 = true;
                     flag6 = false;
@@ -1349,8 +1361,10 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 }
             }
 
-            for (k1 = i - this.viewDistance; k1 <= i + this.viewDistance; ++k1) {
-                for (l1 = j - this.viewDistance; l1 <= j + this.viewDistance; ++l1) {
+            //Paper start ticket level pp-view-dist
+            for (k1 = i - playerViewDistance; k1 <= i + playerViewDistance; ++k1) {
+                for (l1 = j - playerViewDistance; l1 <= j + playerViewDistance; ++l1) {
+                    //Paper end
                     chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
                     flag5 = false;
                     flag6 = true;
@@ -1366,7 +1380,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         return this.playerMap.a(chunkcoordintpair.pair()).filter((entityplayer) -> {
             int i = b(chunkcoordintpair, entityplayer, true);
 
-            return i > this.viewDistance ? false : !flag || i == this.viewDistance;
+            return i > entityplayer.getTrackViewDistance() ? false : !flag || i == entityplayer.getTrackViewDistance(); //Paper ticket level pp-view-dist
         });
     }
 
@@ -1411,7 +1425,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         org.spigotmc.AsyncCatcher.catchOp("entity untrack"); // Spigot
         if (entity instanceof EntityPlayer) {
             EntityPlayer entityplayer = (EntityPlayer) entity;
-
+            this.chunkDistanceManager.fullRemove((EntityPlayer) entity); //Paper ticket level pp-view-dist
             this.a(entityplayer, false);
             ObjectIterator objectiterator = this.trackedEntities.values().iterator();
 
@@ -1612,23 +1626,22 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
         }
 
-        public void updatePlayer(EntityPlayer entityplayer) {
+            public void updatePlayer(EntityPlayer entityplayer) {
             org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
             if (entityplayer != this.tracker) {
                 Vec3D vec3d = (new Vec3D(entityplayer.locX, entityplayer.locY, entityplayer.locZ)).d(this.tracker.getPositionVector()); // MC-155077, SPIGOT-5113
-                int i = Math.min(this.trackingDistance, (PlayerChunkMap.this.viewDistance - 1) * 16);
+                //Paper start ticket level pp-view-dist
+                int i = Math.min(this.trackingDistance, (entityplayer.getTrackViewDistance() - 1) * 16);
                 boolean flag = vec3d.x >= (double) (-i) && vec3d.x <= (double) i && vec3d.z >= (double) (-i) && vec3d.z <= (double) i && this.tracker.a(entityplayer);
+                ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(this.tracker.chunkX, this.tracker.chunkZ);
+                PlayerChunk playerchunk = PlayerChunkMap.this.getVisibleChunk(chunkcoordintpair.pair());
 
-                if (flag) {
+                if (flag && playerchunk != null && playerchunk.getChunk() != null) {
                     boolean flag1 = this.tracker.attachedToPlayer;
 
                     if (!flag1) {
-                        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(this.tracker.chunkX, this.tracker.chunkZ);
-                        PlayerChunk playerchunk = PlayerChunkMap.this.getVisibleChunk(chunkcoordintpair.pair());
-
-                        if (playerchunk != null && playerchunk.getChunk() != null) {
-                            flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= PlayerChunkMap.this.viewDistance;
-                        }
+                        flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= entityplayer.getTrackViewDistance();
+                        //Paper end
                     }
 
                     // CraftBukkit start - respect vanish API
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 3cb443c4..476da855 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -155,7 +155,7 @@ public abstract class PlayerList {
 
         // CraftBukkit - getType()
         // Spigot - view distance
-        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), worldserver.spigotConfig.viewDistance, worldserver.getGameRules().getBoolean(GameRules.REDUCED_DEBUG_INFO)));
+        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), entityplayer.getTrackViewDistance(), worldserver.getGameRules().getBoolean(GameRules.REDUCED_DEBUG_INFO))); //Paper ticket level pp-view-dist
         entityplayer.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.sendPacket(new PacketPlayOutCustomPayload(PacketPlayOutCustomPayload.a, (new PacketDataSerializer(Unpooled.buffer())).a(this.getServer().getServerModName())));
         playerconnection.sendPacket(new PacketPlayOutServerDifficulty(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
@@ -699,7 +699,7 @@ public abstract class PlayerList {
         WorldData worlddata = worldserver.getWorldData();
 
         entityplayer1.playerConnection.sendPacket(new PacketPlayOutRespawn(worldserver.worldProvider.getDimensionManager().getType(), worldserver.getWorldData().getType(), entityplayer1.playerInteractManager.getGameMode()));
-        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(worldserver.spigotConfig.viewDistance)); // Spigot
+        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(entityplayer1.getTrackViewDistance())); // Spigot //Paper ticket level pp-view-dist
         entityplayer1.spawnIn(worldserver);
         entityplayer1.dead = false;
         entityplayer1.playerConnection.teleport(new Location(worldserver.getWorld(), entityplayer1.locX, entityplayer1.locY, entityplayer1.locZ, entityplayer1.yaw, entityplayer1.pitch));
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index e920545d..6c05f0be 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1986,12 +1986,28 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public int getViewDistance() {
-        throw new NotImplementedException("Per-Player View Distance APIs need further understanding to properly implement"); // TODO
+        return getHandle().getViewDistance(); //Paper ticket level pp-view-dist
     }
 
     @Override
     public void setViewDistance(int viewDistance) {
-        throw new NotImplementedException("Per-Player View Distance APIs need further understanding to properly implement"); // TODO
+        getHandle().setViewDistance(viewDistance); //Paper ticket level pp-view-dist
+    }
+
+    public void setTicketViewDistance(int ticketViewDistance) {
+        getHandle().setTicketViewDistance(ticketViewDistance); //Paper ticket level pp-view-dist
+    }
+
+    public int getTrackViewDistance() {
+        return getHandle().getTrackViewDistance(); //Paper ticket level pp-view-dist
+    }
+
+    public int getTicketViewDistance() {
+        return getHandle().getTicketViewDistance(); //Paper ticket level pp-view-dist
+    }
+
+    public void setTrackViewDistance(int trackViewDistance) {
+        getHandle().setTrackViewDistance(trackViewDistance); //Paper ticket level pp-view-dist
     }
     //Paper end
 
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index 92601c58..84fc6bfc 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -122,13 +122,14 @@ public class ActivationRange
         int maxRange = Math.max( monsterActivationRange, animalActivationRange );
         maxRange = Math.max( maxRange, raiderActivationRange );
         maxRange = Math.max( maxRange, miscActivationRange );
-        maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange );
+        //maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange ); //Paper ticket level pp-view-dist
 
         for ( EntityHuman player : world.getPlayers() )
         {
 
+            int playerMaxRange = maxRange = Math.min( ( player.getTrackViewDistance() << 4 ) - 8, maxRange ); //Paper ticket level pp-view-dist
             player.activatedTick = MinecraftServer.currentTick;
-            maxBB = player.getBoundingBox().grow( maxRange, 256, maxRange );
+            maxBB = player.getBoundingBox().grow( playerMaxRange, 256, playerMaxRange ); //Paper ticket level pp-view-dist
             ActivationType.MISC.boundingBox = player.getBoundingBox().grow( miscActivationRange, 256, miscActivationRange );
             ActivationType.RAIDER.boundingBox = player.getBoundingBox().grow( raiderActivationRange, 256, raiderActivationRange );
             ActivationType.ANIMAL.boundingBox = player.getBoundingBox().grow( animalActivationRange, 256, animalActivationRange );
-- 
2.20.1.windows.1

