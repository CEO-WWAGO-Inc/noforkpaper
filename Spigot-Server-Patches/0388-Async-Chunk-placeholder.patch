From 0a9b3722a090de5a8c1c69c11616823e249971cb Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Mon, 6 May 2019 12:29:24 -0700
Subject: [PATCH] Async Chunk placeholder

Until we figure out Mojang's ticket system.

diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 421e92cfa5..e438cef0b2 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -118,6 +118,89 @@ public class ChunkProviderServer extends IChunkProvider {
         }
     }
 
+    // Paper start - async chunk api
+    public void getChunkAtAsynchronously(int x, int z, boolean gen, boolean addPluginTicket, java.util.function.Consumer<Chunk> onLoad) {
+        if (Thread.currentThread() != this.serverThread) {
+            this.serverThreadQueue.execute(() -> {
+                this.getChunkAtAsynchronously(x, z, gen, addPluginTicket, onLoad);
+            });
+            return;
+        }
+        ChunkCoordIntPair chunkcoord = new ChunkCoordIntPair(x, z);
+        // on main thread
+        // copied from above
+        // if the chunk doesn't exist and we don't want to gen we return immediately
+        try {
+            if (!gen && !this.isLoaded(x, z) && !this.playerChunkMap.chunkExists(chunkcoord)) {
+                onLoad.accept(null);
+                return;
+            }
+        } catch (IOException ex) {
+            throw new RuntimeException(ex);
+        }
+        long k = ChunkCoordIntPair.pair(x, z);
+
+        IChunkAccess ichunkaccess;
+
+        // search cache
+        for (int l = 0; l < 4; ++l) {
+            if (k == this.n[l] && ChunkStatus.FULL == this.o[l]) {
+                ichunkaccess = this.p[l];
+
+                // move the chunk to first in cache
+                for (int i1 = 3; i1 > 0; --i1) {
+                    this.n[i1] = this.n[i1 - 1];
+                    this.o[i1] = this.o[i1 - 1];
+                    this.p[i1] = this.p[i1 - 1];
+                }
+
+                this.n[0] = k;
+                this.o[0] = ChunkStatus.FULL;
+                this.p[0] = ichunkaccess;
+
+                if (addPluginTicket) {
+                    this.addTicket(TicketType.PLUGIN, chunkcoord, 1, Unit.INSTANCE);
+                }
+
+                onLoad.accept((Chunk)ichunkaccess);
+                return;
+            }
+        }
+
+        this.addTicket(TicketType.ASYNC_LOAD, chunkcoord, 1, Unit.INSTANCE);
+
+        CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> completablefuture = this.getChunkFutureMainThread(x, z, ChunkStatus.FULL, true);
+
+        completablefuture.whenComplete((either, throwable) -> {
+            this.serverThreadQueue.execute(() -> {
+                // either left -> success
+                // either right -> failure
+
+                if (throwable != null) {
+                    throw new RuntimeException(throwable);
+                }
+
+                if (addPluginTicket) {
+                    this.addTicket(TicketType.PLUGIN, chunkcoord, 1, Unit.INSTANCE);
+                }
+
+                this.removeTicket(TicketType.ASYNC_LOAD, chunkcoord, 1, Unit.INSTANCE);
+                this.addTicket(TicketType.UNKNOWN, chunkcoord, 1, chunkcoord); // allows it to be unloaded
+
+                Optional<PlayerChunk.Failure> didWeFail = either.right();
+                if (didWeFail.isPresent()) {
+                    // we failed
+                    throw new IllegalStateException("Chunk failed to load: " + didWeFail.get().toString());
+                } else {
+                    // did not fail
+                    onLoad.accept((Chunk)either.left().get());
+                }
+            });
+        });
+        return;
+    }
+    // Paper end
+
     private void l() {
         Arrays.fill(this.n, ChunkCoordIntPair.a);
         Arrays.fill(this.o, (Object) null);
diff --git a/src/main/java/net/minecraft/server/TicketType.java b/src/main/java/net/minecraft/server/TicketType.java
index 3b1e4ff252..72eb917cf9 100644
--- a/src/main/java/net/minecraft/server/TicketType.java
+++ b/src/main/java/net/minecraft/server/TicketType.java
@@ -18,6 +18,7 @@ public class TicketType<T> {
     public static final TicketType<BlockPosition2D> PORTAL = a("portal", Comparator.comparingLong(BlockPosition2D::b));
     public static final TicketType<ChunkCoordIntPair> UNKNOWN = a("unknown", Comparator.comparingLong(ChunkCoordIntPair::pair));
     public static final TicketType<Unit> PLUGIN = a("plugin", (a, b) -> 0); // CraftBukkit
+    public static final TicketType<Unit> ASYNC_LOAD = a("async_load", (a, b) -> 0); // Paper - Async chunk loading api
 
     public static <T> TicketType<T> a(String s, Comparator<T> comparator) {
         return new TicketType<>(s, comparator);
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index e18ae24bf8..927e028f65 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -14,6 +14,7 @@ import java.util.Objects;
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
 import java.util.function.Predicate;
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.BiomeBase;
@@ -2118,6 +2119,26 @@ public class CraftWorld implements World {
         return (nearest == null) ? null : new Location(this, nearest.getX(), nearest.getY(), nearest.getZ());
     }
 
+    // Paper start
+    @Override
+    public CompletableFuture<Chunk> getChunkAtAsync(int x, int z, boolean gen) {
+        CompletableFuture<Chunk> ret = new CompletableFuture<>();
+        this.world.getChunkProvider().getChunkAtAsynchronously(x, z, gen, false, (nmsChunk) -> {
+            ret.complete(nmsChunk == null ? null : nmsChunk.bukkitChunk);
+        });
+        return ret;
+    }
+
+    @Override
+    public CompletableFuture<Chunk> loadChunkAtAsync(int x, int z, boolean gen) {
+        CompletableFuture<Chunk> ret = new CompletableFuture<>();
+        this.world.getChunkProvider().getChunkAtAsynchronously(x, z, gen, true, (nmsChunk) -> {
+            ret.complete(nmsChunk == null ? null : nmsChunk.bukkitChunk);
+        });
+        return ret;
+    }
+    // Paper end
+
     // Spigot start
     private final Spigot spigot = new Spigot()
     {
-- 
2.21.0

