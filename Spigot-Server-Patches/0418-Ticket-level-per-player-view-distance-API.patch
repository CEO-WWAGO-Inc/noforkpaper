From eefdd671cd06807ee582b324a8fd31be7cd0708a Mon Sep 17 00:00:00 2001
From: slicklibro <slicklibro@gmail.com>
Date: Fri, 20 Sep 2019 17:16:14 +1200
Subject: [PATCH] Ticket level per-player view distance API

This PR implements the per-player view distance API at the ticket level.
This somewhat clean solution comes from the result of many complicated ones (and research).
The view distance will determine how far the player can add tickets to chunks.
The tracking view distance will determine how far the player can see/load chunks with tickets.
All chunks with player tickets within this range will also be served by the server, allowing shared view distance from other players without impacting performance.

diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index 63a688725..5fecd9601 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -1,7 +1,6 @@
 package net.minecraft.server;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Sets;
 import com.mojang.datafixers.util.Either;
 import it.unimi.dsi.fastutil.longs.Long2ByteMap;
 import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
@@ -20,7 +19,7 @@ import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ObjectSet;
 import it.unimi.dsi.fastutil.objects.ObjectSortedSet;
-import java.util.Set;
+
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import javax.annotation.Nullable;
@@ -43,6 +42,19 @@ public abstract class ChunkMapDistance {
     private final LongSet l = new LongOpenHashSet();
     private final Executor m;
     private long currentTick;
+    //Paper start ticket level pp-view-dist
+    protected static final int ADD = 1;
+    protected static final int REMOVE = -1;
+    protected static final int FULL_REMOVE = -1;
+    protected final it.unimi.dsi.fastutil.  ints.Int2ObjectMap<Square> squares = new it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap<>();
+    protected it.unimi.dsi.fastutil.longs.Long2ByteMap update = new it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap();
+    class Square {
+        public int x, z, u, v, action;
+        public Square(int x1, int z1, int u1, int v1, int action1) {
+            x = x1; z = z1; u = u1; v = v1; action = action1;
+        }
+    }
+    //Paper end
 
     protected ChunkMapDistance(Executor executor, Executor executor1) {
         executor1.getClass();
@@ -234,6 +246,94 @@ public abstract class ChunkMapDistance {
         ((ObjectSet) this.c.computeIfAbsent(i, (j) -> {
             return new ObjectOpenHashSet();
         })).add(entityplayer);
+
+        //Paper start ticket level pp-view-dist
+        int cx = ChunkCoordIntPair.getX(i);
+        int cz = ChunkCoordIntPair.getZ(i);
+
+        int pvd = entityplayer.getViewDistance() - 2;
+
+        Square currSqr = new Square(cx - pvd, cz - pvd, cx + pvd + 1, cz + pvd + 1, 0);
+        Square temp = this.squares.get(entityplayer.getUniqueID().hashCode());
+        this.squares.put(entityplayer.getUniqueID().hashCode(), new Square(cx - pvd, cz - pvd, cx + pvd + 1, cz + pvd + 1, 0));
+
+        if(temp == null) temp = currSqr;
+        Square lastSqr = new Square(temp.x, temp.z, temp.u, temp.v, temp.action);
+
+        it.unimi.dsi.fastutil.ints.IntSortedSet row = new it.unimi.dsi.fastutil.ints.IntRBTreeSet(it.unimi.dsi.fastutil.ints.IntComparators.NATURAL_COMPARATOR);
+        it.unimi.dsi.fastutil.ints.IntSortedSet col = new it.unimi.dsi.fastutil.ints.IntRBTreeSet(it.unimi.dsi.fastutil.ints.IntComparators.NATURAL_COMPARATOR);
+        it.unimi.dsi.fastutil.objects.ObjectList<Square> toproc = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+
+        currSqr.action = ADD; lastSqr.action = REMOVE;
+        toproc.add(lastSqr); toproc.add(currSqr);
+
+        if(lastSqr.x < currSqr.u && lastSqr.u > currSqr.x && lastSqr.z < currSqr.v && lastSqr.v > currSqr.z && !temp.equals(currSqr)) {
+            Square ovdsqr = new Square(Math.max(lastSqr.x, currSqr.x), Math.max(lastSqr.z, currSqr.z), Math.min(lastSqr.u, currSqr.u), Math.min(lastSqr.v, currSqr.v), 0);
+            toproc.add(ovdsqr);
+        }
+
+        ObjectIterator<it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry<Square>> sqriterator = this.squares.int2ObjectEntrySet().iterator();
+        while(sqriterator.hasNext()) {
+            it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry<Square> e = sqriterator.next();
+            int uid = e.getIntKey();
+            Square sqr = e.getValue();
+            if(uid == entityplayer.getUniqueID().hashCode()) continue;
+            if(sqr.action == FULL_REMOVE) {
+                toproc.add(0, sqr);
+                this.squares.remove(uid);
+                continue;
+            }
+            if ((sqr.x < currSqr.u && sqr.u > currSqr.x && sqr.z < currSqr.v && sqr.v > currSqr.z) ||
+                (sqr.x < lastSqr.u && sqr.u > lastSqr.x && sqr.z < lastSqr.v && sqr.v > lastSqr.z )) {
+                toproc.add(sqr);
+            }
+        }
+
+        it.unimi.dsi.fastutil.objects.ObjectListIterator<Square> it = toproc.iterator();
+        //coordinate compression
+
+        while(it.hasNext()) {
+            Square sqr = it.next();
+            row.add(sqr.z); row.add(sqr.v); col.add(sqr.x); col.add(sqr.u);
+        }
+
+        int[][] grid = new int[row.size()][col.size()];
+        it = toproc.iterator();
+
+        while(it.hasNext()) {
+            Square sqr = it.next();
+            for(int s = row.headSet(sqr.z).size(); s < row.headSet(sqr.v).size(); s++) {
+                for(int t = col.headSet(sqr.x).size(); t < col.headSet(sqr.u).size(); t++) {
+                    grid[s][t] = sqr.action;
+                }
+            }
+        }
+
+        int[] rw = row.toIntArray(); int[] cl = col.toIntArray();
+        for(int s = 0; s < row.size() - 1; s++) {
+            for(int t = 0; t < col.size() - 1; t++){
+                if(grid[s][t] == REMOVE || grid[s][t] == FULL_REMOVE) {
+                    for(int x = cl[t]; x < cl[t+1]; x++) {
+                        for(int z = rw[s]; z < rw[s+1]; z++) {
+                            long pair = ChunkCoordIntPair.asLong(x, z);
+                            update.put(pair, (byte) REMOVE);
+                        }
+                    }
+
+                } else if(grid[s][t] == 1) {
+                    for(int x = cl[t]; x < cl[t+1]; x++) {
+                        for(int z = rw[s]; z < rw[s+1]; z++) {
+                            long pair = ChunkCoordIntPair.asLong(x, z);
+                            update.put(pair, (byte) ADD);
+                        }
+                    }
+                }
+            }
+
+
+        }
+        //Paper end
+
         this.f.b(i, 0, true);
         this.g.b(i, 0, true);
     }
@@ -241,7 +341,8 @@ public abstract class ChunkMapDistance {
     public void b(SectionPosition sectionposition, EntityPlayer entityplayer) {
         long i = sectionposition.u().pair();
         ObjectSet<EntityPlayer> objectset = (ObjectSet) this.c.get(i);
-
+        Square sqr = this.squares.get(entityplayer.getUniqueID().hashCode()); //Paper ticket level pp-view-dist
+        this.squares.put(entityplayer.getUniqueID().hashCode(), new Square(sqr.x, sqr.z, sqr.u, sqr.v, FULL_REMOVE)); //Paper ticket level pp-view-dist
         objectset.remove(entityplayer);
         if (objectset.isEmpty()) {
             this.c.remove(i);
@@ -372,20 +473,20 @@ public abstract class ChunkMapDistance {
                 byte b0 = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getByteValue();
                 long j = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getLongKey();
 
-                this.a(j, b0, this.c(b0), b0 <= i - 2);
+                this.a(j, b0, this.c(b0), b0 <= i - 2, i); //Paper ticket level pp-view-dist
             }
 
             this.e = i;
         }
 
-        private void a(long i, int j, boolean flag, boolean flag1) {
+        private void a(long i, int j, boolean flag, boolean flag1, int vd) { //Paper ticket level pp-view-dist
             if (flag != flag1) {
                 Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, ChunkMapDistance.b, new ChunkCoordIntPair(i), ChunkMapDistance.this.currentTick);
 
                 if (flag1) {
                     ChunkMapDistance.this.j.a(ChunkTaskQueueSorter.a(() -> { // Craftbukkit - decompile error
                         ChunkMapDistance.this.m.execute(() -> {
-                            if (this.c(this.c(i))) {
+                            if (this.c(i) <= vd) { //Paper ticket level pp-view-dist
                                 ChunkMapDistance.this.addTicket(i, ticket);
                                 ChunkMapDistance.this.l.add(i);
                             } else {
@@ -430,13 +531,37 @@ public abstract class ChunkMapDistance {
                             }
 
                         });
-                        this.a(i, k, this.c(j), this.c(k));
                     }
-                }
 
+                    //Paper start ticket level pp-view-dist
+                    byte f = ChunkMapDistance.this.update.remove(i);
+                    if(f == ChunkMapDistance.ADD) {
+                        this.a(i, k, false, true, Integer.MAX_VALUE);
+                    } else if (f == ChunkMapDistance.REMOVE) {
+                        this.a(i, k, true, false, Integer.MAX_VALUE);
+                    }
+                }
                 this.g.clear();
             }
 
+            if (!ChunkMapDistance.this.update.isEmpty()) {
+                ObjectIterator<it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry> it = ChunkMapDistance.this.update.long2ByteEntrySet().iterator();
+
+                while(it.hasNext()) {
+                    it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry e = it.next();
+                    long i = e.getLongKey();
+                    byte f = e.getByteValue();
+                    if(f == ChunkMapDistance.ADD) {
+                        this.a(i, this.c(i), false, true, Integer.MAX_VALUE);
+                    } else if (f == ChunkMapDistance.REMOVE) {
+                        this.a(i, this.c(i), true, false, Integer.MAX_VALUE);
+                    }
+                }
+
+                ChunkMapDistance.this.update.clear();
+            }
+            //Paper end
+
         }
 
         private boolean c(int i) {
diff --git a/src/main/java/net/minecraft/server/EntityEnderDragon.java b/src/main/java/net/minecraft/server/EntityEnderDragon.java
index c8c74f2b3..6a84a1a58 100644
--- a/src/main/java/net/minecraft/server/EntityEnderDragon.java
+++ b/src/main/java/net/minecraft/server/EntityEnderDragon.java
@@ -570,9 +570,9 @@ public class EntityEnderDragon extends EntityInsentient implements IMonster {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1028, new BlockPosition(this), 0);
                 // Paper start
-                int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
+                //int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
-                    //final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = player.getTrackViewDistance() * 16; //Paper ticket level pp-view-dist
                     // Paper end
                     double deltaX = this.locX - player.locX;
                     double deltaZ = this.locZ - player.locZ;
diff --git a/src/main/java/net/minecraft/server/EntityHuman.java b/src/main/java/net/minecraft/server/EntityHuman.java
index cd73cde8d..ca8063c6b 100644
--- a/src/main/java/net/minecraft/server/EntityHuman.java
+++ b/src/main/java/net/minecraft/server/EntityHuman.java
@@ -80,6 +80,32 @@ public abstract class EntityHuman extends EntityLiving {
     public String spawnWorld = "";
     public int oldLevel = -1;
 
+    //Paper start ticket level pp-view-dist
+    private int viewDistance;
+    private int trackViewDistance;
+    public int lastViewDistance;
+    public int lastTrackViewDistance;
+    public int getViewDistance() { return this.viewDistance; }
+    public int getTicketViewDistance() { return this.viewDistance; }
+    public int getTrackViewDistance() { return this.trackViewDistance; }
+    public void setTrackViewDistance(int trackViewDistance) {
+        this.lastTrackViewDistance = this.trackViewDistance;
+        this.trackViewDistance = MathHelper.clamp(trackViewDistance, 3, 33);
+        //set pcm vd to highest vd to respect other processes.
+        if (this.trackViewDistance > ((WorldServer) this.world).getChunkProvider().playerChunkMap.viewDistance)
+            ((WorldServer) this.world).getChunkProvider().playerChunkMap.viewDistance = this.trackViewDistance;
+    }
+    public void setViewDistance(int viewDistance) {
+        this.setTrackViewDistance(viewDistance);
+        this.lastViewDistance = this.viewDistance;
+        this.viewDistance = MathHelper.clamp(viewDistance, 3, this.trackViewDistance);
+    }
+    public void setTicketViewDistance(int ticketViewDistance) {
+        this.lastViewDistance = this.viewDistance;
+        this.viewDistance = MathHelper.clamp(ticketViewDistance, 3, this.trackViewDistance);
+    }
+    //Paper end
+
     @Override
     public CraftHumanEntity getBukkitEntity() {
         return (CraftHumanEntity) super.getBukkitEntity();
@@ -98,6 +124,12 @@ public abstract class EntityHuman extends EntityLiving {
 
         this.setPositionRotation((double) blockposition.getX() + 0.5D, (double) (blockposition.getY() + 1), (double) blockposition.getZ() + 0.5D, 0.0F, 0.0F);
         this.aX = 180.0F;
+        //Paper start ticket level pp-view-dist
+        this.setTrackViewDistance(this.world.spigotConfig.viewDistance);
+        this.setViewDistance(this.getTrackViewDistance());
+        this.lastTrackViewDistance = this.getTrackViewDistance();
+        this.lastViewDistance = this.getViewDistance();
+        //Paper end
     }
 
     public boolean a(World world, BlockPosition blockposition, EnumGamemode enumgamemode) {
diff --git a/src/main/java/net/minecraft/server/EntityWither.java b/src/main/java/net/minecraft/server/EntityWither.java
index 8b3052b11..dc2ff9482 100644
--- a/src/main/java/net/minecraft/server/EntityWither.java
+++ b/src/main/java/net/minecraft/server/EntityWither.java
@@ -208,9 +208,9 @@ public class EntityWither extends EntityMonster implements IRangedEntity {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1023, new BlockPosition(this), 0);
                 // Paper start
-                int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
+                //int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
-                    //final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = player.getTrackViewDistance() * 16; //Paper ticket level pp-view-dist
                     // Paper end
                     double deltaX = this.locX - player.locX;
                     double deltaZ = this.locZ - player.locZ;
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 95ee33513..6659bc736 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -935,28 +935,33 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
 
     protected void setViewDistance(int i) {
         int j = MathHelper.clamp(i + 1, 3, 33);
+        //Paper start ticket level pp-view-dist
+        this.chunkDistanceManager.a(j);
+        this.viewDistance = j;
+        ObjectIterator objectiterator = this.updatingChunks.values().iterator();
+
+        if(this.world.players != null && !this.world.players.isEmpty()) {
+            for (EntityPlayer player : this.world.players) {
+                //no need to perform anything more complex, as all logic is handled live at the ticket level
+                player.setTrackViewDistance(j);
+                player.setViewDistance(j);
+            }
+        }
+        while (objectiterator.hasNext()) {
+            PlayerChunk playerchunk = (PlayerChunk) objectiterator.next();
+            ChunkCoordIntPair chunkcoordintpair = playerchunk.i();
+            Packet<?>[] apacket = new Packet[2];
 
-        if (j != this.viewDistance) {
-            int k = this.viewDistance;
-
-            this.viewDistance = j;
-            this.chunkDistanceManager.a(this.viewDistance);
-            ObjectIterator objectiterator = this.updatingChunks.values().iterator();
+            this.a(chunkcoordintpair, false).forEach((entityplayer) -> {
+                int l = b(chunkcoordintpair, entityplayer, true);
+                boolean flag = l <= entityplayer.lastTrackViewDistance;
+                boolean flag1 = l <= entityplayer.getTrackViewDistance();
 
-            while (objectiterator.hasNext()) {
-                PlayerChunk playerchunk = (PlayerChunk) objectiterator.next();
-                ChunkCoordIntPair chunkcoordintpair = playerchunk.i();
-                Packet<?>[] apacket = new Packet[2];
-
-                this.a(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    int l = b(chunkcoordintpair, entityplayer, true);
-                    boolean flag = l <= k;
-                    boolean flag1 = l <= this.viewDistance;
-
-                    this.sendChunk(entityplayer, chunkcoordintpair, apacket, flag, flag1);
-                });
-            }
+                this.sendChunk(entityplayer, chunkcoordintpair, apacket, flag, flag1);
+            });
         }
+        //Paper end
+
 
     }
 
@@ -1201,21 +1206,21 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     boolean isOutsideOfRange(ChunkCoordIntPair chunkcoordintpair, boolean reducedRange) {
-        int chunkRange = world.spigotConfig.mobSpawnRange;
-        chunkRange = (chunkRange > world.spigotConfig.viewDistance) ? (byte) world.spigotConfig.viewDistance : chunkRange;
-        chunkRange = (chunkRange > 8) ? 8 : chunkRange;
-
-        final int finalChunkRange = chunkRange; // Paper for lambda below
         //double blockRange = (reducedRange) ? Math.pow(chunkRange << 4, 2) : 16384.0D; // Paper - use from event
         // Spigot end
         long i = chunkcoordintpair.pair();
 
         return !this.chunkDistanceManager.d(i) ? true : this.playerMap.a(i).noneMatch((entityplayer) -> {
+            //Paper start ticket level pp-view-dist
+            int playerChunkRange = world.spigotConfig.mobSpawnRange;
+            playerChunkRange = (playerChunkRange > entityplayer.getTrackViewDistance()) ? (byte) entityplayer.getTrackViewDistance() : playerChunkRange;
+            playerChunkRange = (playerChunkRange > 8) ? 8 : playerChunkRange;
+            //Paper end
             // Paper start -
             com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent event;
             double blockRange = 16384.0D;
             if (reducedRange) {
-                event = new com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent(entityplayer.getBukkitEntity(), (byte) finalChunkRange);
+                event = new com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent(entityplayer.getBukkitEntity(), (byte) playerChunkRange); //Paper ticket level pp-view-dist
                 event.callEvent();
                 blockRange = (double) ((event.getSpawnRadius() << 4) * (event.getSpawnRadius() << 4));
                 if (event.isCancelled()) return true;
@@ -1251,8 +1256,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             }
         }
 
-        for (int k = i - this.viewDistance; k <= i + this.viewDistance; ++k) {
-            for (int l = j - this.viewDistance; l <= j + this.viewDistance; ++l) {
+        //Paper start ticket level pp-view-dist
+        int playerViewDistance = entityplayer.getTrackViewDistance();
+        for (int k = i - playerViewDistance; k <= i + playerViewDistance; ++k) {
+            for (int l = j - playerViewDistance; l <= j + playerViewDistance; ++l) {
+                //Paper end
                 ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k, l);
 
                 this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], !flag, flag);
@@ -1320,18 +1328,20 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         int k1;
         int l1;
 
-        if (Math.abs(i1 - i) <= this.viewDistance * 2 && Math.abs(j1 - j) <= this.viewDistance * 2) {
-            k1 = Math.min(i, i1) - this.viewDistance;
-            l1 = Math.min(j, j1) - this.viewDistance;
-            int i2 = Math.max(i, i1) + this.viewDistance;
-            int j2 = Math.max(j, j1) + this.viewDistance;
+        //Paper start ticket level pp-view-dist
+        int playerViewDistance = entityplayer.getTrackViewDistance();
+        if (Math.abs(i1 - i) <= playerViewDistance * 2 && Math.abs(j1 - j) <= playerViewDistance * 2) {
+            k1 = Math.min(i, i1) - playerViewDistance;
+            l1 = Math.min(j, j1) - playerViewDistance;
+            int i2 = Math.max(i, i1) + playerViewDistance;
+            int j2 = Math.max(j, j1) + playerViewDistance;
 
             for (int k2 = k1; k2 <= i2; ++k2) {
                 for (int l2 = l1; l2 <= j2; ++l2) {
                     ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k2, l2);
-                    boolean flag3 = a(chunkcoordintpair, i1, j1) <= this.viewDistance;
-                    boolean flag4 = a(chunkcoordintpair, i, j) <= this.viewDistance;
-
+                    boolean flag3 = a(chunkcoordintpair, i1, j1) <= playerViewDistance;
+                    boolean flag4 = a(chunkcoordintpair, i, j) <= playerViewDistance;
+                    //Paper end
                     this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], flag3, flag4);
                 }
             }
@@ -1340,8 +1350,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             boolean flag5;
             boolean flag6;
 
-            for (k1 = i1 - this.viewDistance; k1 <= i1 + this.viewDistance; ++k1) {
-                for (l1 = j1 - this.viewDistance; l1 <= j1 + this.viewDistance; ++l1) {
+            //Paper start ticket level pp-view-dist
+            for (k1 = i1 - playerViewDistance; k1 <= i1 + playerViewDistance; ++k1) {
+                for (l1 = j1 - playerViewDistance; l1 <= j1 + playerViewDistance; ++l1) {
+                    //Paper end
+
                     chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
                     flag5 = true;
                     flag6 = false;
@@ -1349,8 +1362,10 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 }
             }
 
-            for (k1 = i - this.viewDistance; k1 <= i + this.viewDistance; ++k1) {
-                for (l1 = j - this.viewDistance; l1 <= j + this.viewDistance; ++l1) {
+            //Paper start ticket level pp-view-dist
+            for (k1 = i - playerViewDistance; k1 <= i + playerViewDistance; ++k1) {
+                for (l1 = j - playerViewDistance; l1 <= j + playerViewDistance; ++l1) {
+                    //Paper end
                     chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
                     flag5 = false;
                     flag6 = true;
@@ -1366,7 +1381,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         return this.playerMap.a(chunkcoordintpair.pair()).filter((entityplayer) -> {
             int i = b(chunkcoordintpair, entityplayer, true);
 
-            return i > this.viewDistance ? false : !flag || i == this.viewDistance;
+            return i > entityplayer.getTrackViewDistance() ? false : !flag || i == entityplayer.getTrackViewDistance(); //Paper ticket level pp-view-dist
         });
     }
 
@@ -1616,7 +1631,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
             if (entityplayer != this.tracker) {
                 Vec3D vec3d = (new Vec3D(entityplayer.locX, entityplayer.locY, entityplayer.locZ)).d(this.tracker.getPositionVector()); // MC-155077, SPIGOT-5113
-                int i = Math.min(this.trackingDistance, (PlayerChunkMap.this.viewDistance - 1) * 16);
+                int i = Math.min(this.trackingDistance, (entityplayer.getViewDistance() - 1) * 16); //Paper ticket level pp-view-dist
                 boolean flag = vec3d.x >= (double) (-i) && vec3d.x <= (double) i && vec3d.z >= (double) (-i) && vec3d.z <= (double) i && this.tracker.a(entityplayer);
 
                 if (flag) {
@@ -1627,7 +1642,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                         PlayerChunk playerchunk = PlayerChunkMap.this.getVisibleChunk(chunkcoordintpair.pair());
 
                         if (playerchunk != null && playerchunk.getChunk() != null) {
-                            flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= PlayerChunkMap.this.viewDistance;
+                            flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= entityplayer.getTrackViewDistance(); //Paper ticket level pp-view-dist
                         }
                     }
 
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 3cb443c4f..476da855d 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -155,7 +155,7 @@ public abstract class PlayerList {
 
         // CraftBukkit - getType()
         // Spigot - view distance
-        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), worldserver.spigotConfig.viewDistance, worldserver.getGameRules().getBoolean(GameRules.REDUCED_DEBUG_INFO)));
+        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), entityplayer.getTrackViewDistance(), worldserver.getGameRules().getBoolean(GameRules.REDUCED_DEBUG_INFO))); //Paper ticket level pp-view-dist
         entityplayer.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.sendPacket(new PacketPlayOutCustomPayload(PacketPlayOutCustomPayload.a, (new PacketDataSerializer(Unpooled.buffer())).a(this.getServer().getServerModName())));
         playerconnection.sendPacket(new PacketPlayOutServerDifficulty(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
@@ -699,7 +699,7 @@ public abstract class PlayerList {
         WorldData worlddata = worldserver.getWorldData();
 
         entityplayer1.playerConnection.sendPacket(new PacketPlayOutRespawn(worldserver.worldProvider.getDimensionManager().getType(), worldserver.getWorldData().getType(), entityplayer1.playerInteractManager.getGameMode()));
-        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(worldserver.spigotConfig.viewDistance)); // Spigot
+        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(entityplayer1.getTrackViewDistance())); // Spigot //Paper ticket level pp-view-dist
         entityplayer1.spawnIn(worldserver);
         entityplayer1.dead = false;
         entityplayer1.playerConnection.teleport(new Location(worldserver.getWorld(), entityplayer1.locX, entityplayer1.locY, entityplayer1.locZ, entityplayer1.yaw, entityplayer1.pitch));
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index e920545df..6c05f0be5 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1986,12 +1986,28 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public int getViewDistance() {
-        throw new NotImplementedException("Per-Player View Distance APIs need further understanding to properly implement"); // TODO
+        return getHandle().getViewDistance(); //Paper ticket level pp-view-dist
     }
 
     @Override
     public void setViewDistance(int viewDistance) {
-        throw new NotImplementedException("Per-Player View Distance APIs need further understanding to properly implement"); // TODO
+        getHandle().setViewDistance(viewDistance); //Paper ticket level pp-view-dist
+    }
+
+    public void setTicketViewDistance(int ticketViewDistance) {
+        getHandle().setTicketViewDistance(ticketViewDistance); //Paper ticket level pp-view-dist
+    }
+
+    public int getTrackViewDistance() {
+        return getHandle().getTrackViewDistance(); //Paper ticket level pp-view-dist
+    }
+
+    public int getTicketViewDistance() {
+        return getHandle().getTicketViewDistance(); //Paper ticket level pp-view-dist
+    }
+
+    public void setTrackViewDistance(int trackViewDistance) {
+        getHandle().setTrackViewDistance(trackViewDistance); //Paper ticket level pp-view-dist
     }
     //Paper end
 
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index 92601c581..84fc6bfc4 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -122,13 +122,14 @@ public class ActivationRange
         int maxRange = Math.max( monsterActivationRange, animalActivationRange );
         maxRange = Math.max( maxRange, raiderActivationRange );
         maxRange = Math.max( maxRange, miscActivationRange );
-        maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange );
+        //maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange ); //Paper ticket level pp-view-dist
 
         for ( EntityHuman player : world.getPlayers() )
         {
 
+            int playerMaxRange = maxRange = Math.min( ( player.getTrackViewDistance() << 4 ) - 8, maxRange ); //Paper ticket level pp-view-dist
             player.activatedTick = MinecraftServer.currentTick;
-            maxBB = player.getBoundingBox().grow( maxRange, 256, maxRange );
+            maxBB = player.getBoundingBox().grow( playerMaxRange, 256, playerMaxRange ); //Paper ticket level pp-view-dist
             ActivationType.MISC.boundingBox = player.getBoundingBox().grow( miscActivationRange, 256, miscActivationRange );
             ActivationType.RAIDER.boundingBox = player.getBoundingBox().grow( raiderActivationRange, 256, raiderActivationRange );
             ActivationType.ANIMAL.boundingBox = player.getBoundingBox().grow( animalActivationRange, 256, animalActivationRange );
-- 
2.20.1.windows.1

