From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Byteflux <byte@byteflux.net>
Date: Wed, 2 Mar 2016 02:17:54 -0600
Subject: [PATCH] Flat bedrock generator settings

== AT ==
public net.minecraft.world.level.levelgen.SurfaceRules$Condition
public net.minecraft.world.level.levelgen.SurfaceRules$Context
public net.minecraft.world.level.levelgen.SurfaceRules$Context blockX
public net.minecraft.world.level.levelgen.SurfaceRules$Context blockY
public net.minecraft.world.level.levelgen.SurfaceRules$Context blockZ
public net.minecraft.world.level.levelgen.SurfaceRules$Context context
public net.minecraft.world.level.levelgen.SurfaceRules$Context randomState
public net.minecraft.world.level.levelgen.SurfaceRules$LazyYCondition
public net.minecraft.world.level.levelgen.SurfaceRules$LazyCondition
public net.minecraft.world.level.levelgen.SurfaceRules$VerticalGradientConditionSource
public net.minecraft.world.level.levelgen.SurfaceRules$SurfaceRule
public net.minecraft.world.level.levelgen.SurfaceSystem getOrCreateRandomFactory(Lnet/minecraft/resources/ResourceLocation;)Lnet/minecraft/world/level/levelgen/PositionalRandomFactory;
public net.minecraft.world.level.levelgen.SurfaceRules$SequenceRuleSource
public net.minecraft.world.level.levelgen.SurfaceRules$SequenceRuleSource <init>(Ljava/util/List;)V
public net.minecraft.world.level.levelgen.SurfaceRules$TestRuleSource
public net.minecraft.world.level.levelgen.SurfaceRules$TestRuleSource <init>(Lnet/minecraft/world/level/levelgen/SurfaceRules$ConditionSource;Lnet/minecraft/world/level/levelgen/SurfaceRules$RuleSource;)V
public net.minecraft.world.level.levelgen.SurfaceRules$NotConditionSource
public net.minecraft.world.level.levelgen.SurfaceRules$NotConditionSource <init>(Lnet/minecraft/world/level/levelgen/SurfaceRules$ConditionSource;)V

Co-authored-by: Noah van der Aa <ndvdaa@gmail.com>

diff --git a/src/main/java/net/minecraft/data/worldgen/SurfaceRuleData.java b/src/main/java/net/minecraft/data/worldgen/SurfaceRuleData.java
index 06e1774dfbb667aca69bc30c9675ed472cb5728c..b5f8ad923e070dcfaa582fea4a4703691a4a640d 100644
--- a/src/main/java/net/minecraft/data/worldgen/SurfaceRuleData.java
+++ b/src/main/java/net/minecraft/data/worldgen/SurfaceRuleData.java
@@ -53,6 +53,66 @@ public class SurfaceRuleData {
         return overworldLike(true, false, true);
     }
 
+    // Paper start
+    // Taken from SurfaceRules$VerticalGradientConditionSource
+    // isRoof = true if roof, false if floor
+    public record PaperBedrockConditionSource(net.minecraft.resources.ResourceLocation randomName, VerticalAnchor trueAtAndBelow, VerticalAnchor falseAtAndAbove, boolean isRoof) implements SurfaceRules.ConditionSource {
+
+        public static final net.minecraft.util.KeyDispatchDataCodec<PaperBedrockConditionSource> CODEC = net.minecraft.util.KeyDispatchDataCodec.of(com.mojang.serialization.codecs.RecordCodecBuilder.<PaperBedrockConditionSource>mapCodec((instance) -> {
+            return instance.group(
+                net.minecraft.resources.ResourceLocation.CODEC.fieldOf("random_name").forGetter(PaperBedrockConditionSource::randomName),
+                VerticalAnchor.CODEC.fieldOf("true_at_and_below").forGetter(PaperBedrockConditionSource::trueAtAndBelow),
+                VerticalAnchor.CODEC.fieldOf("false_at_and_above").forGetter(PaperBedrockConditionSource::falseAtAndAbove),
+                com.mojang.serialization.Codec.BOOL.fieldOf("roof").forGetter(PaperBedrockConditionSource::isRoof)
+                ).apply(instance, PaperBedrockConditionSource::new);
+        }));
+
+        public PaperBedrockConditionSource(String randomName, net.minecraft.world.level.levelgen.VerticalAnchor trueAtAndBelow, net.minecraft.world.level.levelgen.VerticalAnchor falseAtAndAbove, boolean invert) {
+            this(new net.minecraft.resources.ResourceLocation(randomName), trueAtAndBelow, falseAtAndAbove, invert);
+        }
+
+        @Override
+        public net.minecraft.util.KeyDispatchDataCodec<PaperBedrockConditionSource>codec() {
+            return CODEC;
+        }
+
+        @Override
+        public SurfaceRules.Condition apply(SurfaceRules.Context context) {
+            boolean hasFlatBedrock = context.context.getWorld().paperConfig().environment.generateFlatBedrock;
+            int trueAtY = this.trueAtAndBelow().resolveY(context.context);
+            int falseAtY = this.falseAtAndAbove().resolveY(context.context);
+
+            int y = isRoof ? Math.max(falseAtY, trueAtY) - 1 : Math.min(falseAtY, trueAtY) ;
+            final int i = hasFlatBedrock ? y : trueAtY;
+            final int j = hasFlatBedrock ? y : falseAtY;
+            // TODO access transformer for randomState
+            final net.minecraft.world.level.levelgen.PositionalRandomFactory positionalRandomFactory = context.randomState.getOrCreateRandomFactory(this.randomName());
+
+            class VerticalGradientCondition extends SurfaceRules.LazyYCondition {
+                VerticalGradientCondition(SurfaceRules.Context context) {
+                    super(context);
+                }
+
+                @Override
+                protected boolean compute() {
+                    int y = this.context.blockY;
+                    if (y <= i) {
+                        return true;
+                    } else if (y >= j) {
+                        return false;
+                    } else {
+                        double d = net.minecraft.util.Mth.map((double) y, (double) i, (double) j, 1.0D, 0.0D);
+                        net.minecraft.util.RandomSource randomSource = positionalRandomFactory.at(this.context.blockX, y, this.context.blockZ);
+                        return (double) randomSource.nextFloat() < d;
+                    }
+                }
+            }
+
+            return new VerticalGradientCondition(context);
+        }
+    }
+    // Paper end
+
     public static SurfaceRules.RuleSource overworldLike(boolean surface, boolean bedrockRoof, boolean bedrockFloor) {
         SurfaceRules.ConditionSource conditionSource = SurfaceRules.yBlockCheck(VerticalAnchor.absolute(97), 2);
         SurfaceRules.ConditionSource conditionSource2 = SurfaceRules.yBlockCheck(VerticalAnchor.absolute(256), 0);
diff --git a/src/main/java/net/minecraft/resources/RegistryDataLoader.java b/src/main/java/net/minecraft/resources/RegistryDataLoader.java
index f6cfb0033da9ff9430e1a67a791fb822ac62b224..722718ede58bfafa7a5b7499e8fe4a1c0bfe1b19 100644
--- a/src/main/java/net/minecraft/resources/RegistryDataLoader.java
+++ b/src/main/java/net/minecraft/resources/RegistryDataLoader.java
@@ -127,6 +127,15 @@ public class RegistryDataLoader {
     private static String registryDirPath(ResourceLocation id) {
         return id.getPath();
     }
+    // Paper start
+    private static final java.util.Set<ResourceKey<net.minecraft.world.level.levelgen.NoiseGeneratorSettings>> TO_CHECK = java.util.Set.of(
+        NoiseGeneratorSettings.OVERWORLD,
+        NoiseGeneratorSettings.NETHER
+        // NoiseGeneratorSettings.CAVES, // if you want these 3, we really should just patch the json file
+        // NoiseGeneratorSettings.LARGE_BIOMES,
+        // NoiseGeneratorSettings.AMPLIFIED
+    );
+    // Paper end
 
     static <E> void loadRegistryContents(RegistryOps.RegistryInfoLookup registryInfoGetter, ResourceManager resourceManager, ResourceKey<? extends Registry<E>> registryRef, WritableRegistry<E> newRegistry, Decoder<E> decoder, Map<ResourceKey<?>, Exception> exceptions) {
         String string = registryDirPath(registryRef.location());
@@ -143,6 +152,26 @@ public class RegistryDataLoader {
                 DataResult<E> dataResult = decoder.parse(registryOps, jsonElement);
                 E object = dataResult.getOrThrow(false, (error) -> {
                 });
+                // Paper start - this should really be done as a patch to the data/minecraft/worldgen/noise_settings/overworld|caves|nether|amplified|large_biomes.json files
+                if (resource.isBuiltin() && TO_CHECK.contains(resourceKey)) {
+                    final NoiseGeneratorSettings settings = (NoiseGeneratorSettings) object;
+                    if (settings.surfaceRule() instanceof net.minecraft.world.level.levelgen.SurfaceRules.SequenceRuleSource sequenceRuleSource) {
+                        final List<net.minecraft.world.level.levelgen.SurfaceRules.RuleSource> sources = new java.util.ArrayList<>(sequenceRuleSource.sequence());
+                        boolean changed = false;
+                        if (sources.get(0) instanceof net.minecraft.world.level.levelgen.SurfaceRules.TestRuleSource testRuleSource && testRuleSource.ifTrue() instanceof net.minecraft.world.level.levelgen.SurfaceRules.VerticalGradientConditionSource verticalGradientConditionSource && verticalGradientConditionSource.randomName().getPath().startsWith("bedrock_")) {
+                            sources.set(0, new net.minecraft.world.level.levelgen.SurfaceRules.TestRuleSource(new net.minecraft.data.worldgen.SurfaceRuleData.PaperBedrockConditionSource(verticalGradientConditionSource.randomName(), verticalGradientConditionSource.trueAtAndBelow(), verticalGradientConditionSource.falseAtAndAbove(), verticalGradientConditionSource.randomName().getPath().endsWith("_roof")), testRuleSource.thenRun()));
+                            changed = true;
+                        }
+                        if (changed && sources.get(1) instanceof net.minecraft.world.level.levelgen.SurfaceRules.TestRuleSource testRuleSource && testRuleSource.ifTrue() instanceof net.minecraft.world.level.levelgen.SurfaceRules.NotConditionSource notConditionSource && notConditionSource.target() instanceof net.minecraft.world.level.levelgen.SurfaceRules.VerticalGradientConditionSource verticalGradientConditionSource && verticalGradientConditionSource.randomName().getPath().startsWith("bedrock_")) {
+                            sources.set(1, new net.minecraft.world.level.levelgen.SurfaceRules.TestRuleSource(new net.minecraft.world.level.levelgen.SurfaceRules.NotConditionSource(new net.minecraft.data.worldgen.SurfaceRuleData.PaperBedrockConditionSource(verticalGradientConditionSource.randomName(), verticalGradientConditionSource.trueAtAndBelow(), verticalGradientConditionSource.falseAtAndAbove(), verticalGradientConditionSource.randomName().getPath().endsWith("_roof"))), testRuleSource.thenRun()));
+                        }
+                        if (changed) {
+                            final net.minecraft.world.level.levelgen.SurfaceRules.SequenceRuleSource newSequence = new net.minecraft.world.level.levelgen.SurfaceRules.SequenceRuleSource(sources);
+                            object = (E) new NoiseGeneratorSettings(settings.noiseSettings(), settings.defaultBlock(), settings.defaultFluid(), settings.noiseRouter(), newSequence, settings.spawnTarget(), settings.seaLevel(), settings.disableMobGeneration(), settings.aquifersEnabled(), settings.oreVeinsEnabled(), settings.useLegacyRandomSource());
+                        }
+                    }
+                }
+                // Paper end
                 newRegistry.register(resourceKey, object, resource.isBuiltin() ? Lifecycle.stable() : dataResult.lifecycle());
             } catch (Exception var20) {
                 exceptions.put(resourceKey, new IllegalStateException(String.format(Locale.ROOT, "Failed to parse %s from pack %s", resourceLocation, resource.sourcePackId()), var20));
diff --git a/src/main/java/net/minecraft/server/Bootstrap.java b/src/main/java/net/minecraft/server/Bootstrap.java
index ac2b7b5161eaaca3620268ae865d6f2a80227fde..a1192d1f6b99669f843e8d9a8928ff0e8c030559 100644
--- a/src/main/java/net/minecraft/server/Bootstrap.java
+++ b/src/main/java/net/minecraft/server/Bootstrap.java
@@ -71,6 +71,7 @@ public class Bootstrap {
                     CauldronInteraction.bootStrap();
                     // Paper start
                     BuiltInRegistries.bootStrap(() -> {
+                        net.minecraft.core.Registry.register(net.minecraft.core.registries.BuiltInRegistries.MATERIAL_CONDITION, new net.minecraft.resources.ResourceLocation("paper", "bedrock_condition_source"), net.minecraft.data.worldgen.SurfaceRuleData.PaperBedrockConditionSource.CODEC.codec());
                         io.papermc.paper.plugin.entrypoint.LaunchEntryPointHandler.enterBootstrappers(); // Paper - Entrypoint for bootstrapping
                     });
                     // Paper end
diff --git a/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java b/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
index cdc87f14e5d6336856c74d5089e50ae5ebad9923..6b84633bf6956406d2e2c5dd32fa358f41ccc890 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
@@ -207,7 +207,7 @@ public final class NoiseBasedChunkGenerator extends ChunkGenerator {
     @Override
     public void buildSurface(WorldGenRegion region, StructureManager structures, RandomState noiseConfig, ChunkAccess chunk) {
         if (!SharedConstants.debugVoidTerrain(chunk.getPos())) {
-            WorldGenerationContext worldgenerationcontext = new WorldGenerationContext(this, region);
+            WorldGenerationContext worldgenerationcontext = new WorldGenerationContext(this, region, region.getMinecraftWorld()); // Paper
 
             this.buildSurface(chunk, worldgenerationcontext, noiseConfig, structures, region.getBiomeManager(), region.registryAccess().registryOrThrow(Registries.BIOME), Blender.of(region));
         }
@@ -235,7 +235,7 @@ public final class NoiseBasedChunkGenerator extends ChunkGenerator {
             return this.createNoiseChunk(ichunkaccess1, structureAccessor, Blender.of(chunkRegion), noiseConfig);
         });
         Aquifer aquifer = noisechunk.aquifer();
-        CarvingContext carvingcontext = new CarvingContext(this, chunkRegion.registryAccess(), chunk.getHeightAccessorForGeneration(), noisechunk, noiseConfig, ((NoiseGeneratorSettings) this.settings.value()).surfaceRule());
+        CarvingContext carvingcontext = new CarvingContext(this, chunkRegion.registryAccess(), chunk.getHeightAccessorForGeneration(), noisechunk, noiseConfig, ((NoiseGeneratorSettings) this.settings.value()).surfaceRule(), chunkRegion.getMinecraftWorld()); // Paper
         CarvingMask carvingmask = ((ProtoChunk) chunk).getOrCreateCarvingMask(carverStep);
 
         for (int j = -8; j <= 8; ++j) {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/WorldGenerationContext.java b/src/main/java/net/minecraft/world/level/levelgen/WorldGenerationContext.java
index b99283c31193e2110f6e3f39c23dbfc2442bab2b..1c9d9ecdafb2bd04348045ba0404da052dcd6437 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/WorldGenerationContext.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/WorldGenerationContext.java
@@ -6,10 +6,13 @@ import net.minecraft.world.level.chunk.ChunkGenerator;
 public class WorldGenerationContext {
     private final int minY;
     private final int height;
+    private final @javax.annotation.Nullable net.minecraft.world.level.Level level; // Paper
 
-    public WorldGenerationContext(ChunkGenerator generator, LevelHeightAccessor world) {
+    public WorldGenerationContext(ChunkGenerator generator, LevelHeightAccessor world) { this(generator, world, null); } // Paper
+    public WorldGenerationContext(ChunkGenerator generator, LevelHeightAccessor world, @org.jetbrains.annotations.Nullable net.minecraft.world.level.Level level) { // Paper
         this.minY = Math.max(world.getMinBuildHeight(), generator.getMinY());
         this.height = Math.min(world.getHeight(), generator.getGenDepth());
+        this.level = level; // Paper
     }
 
     public int getMinGenY() {
@@ -19,4 +22,13 @@ public class WorldGenerationContext {
     public int getGenDepth() {
         return this.height;
     }
+
+    // Paper start
+    public net.minecraft.world.level.Level getWorld() {
+        if (this.level == null) {
+            throw new NullPointerException("WorldGenerationContext was initialized without a Level, but WorldGenerationContext#getWorld was called");
+        }
+        return this.level;
+    }
+    // Paper end
 }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/carver/CarvingContext.java b/src/main/java/net/minecraft/world/level/levelgen/carver/CarvingContext.java
index a745458ea3581ea91a68c863e3fd0a0292d73a61..f84ee8afe95f912a972e37fbae7a06ecdd3aba06 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/carver/CarvingContext.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/carver/CarvingContext.java
@@ -21,8 +21,8 @@ public class CarvingContext extends WorldGenerationContext {
     private final RandomState randomState;
     private final SurfaceRules.RuleSource surfaceRule;
 
-    public CarvingContext(NoiseBasedChunkGenerator noiseChunkGenerator, RegistryAccess registryManager, LevelHeightAccessor heightLimitView, NoiseChunk chunkNoiseSampler, RandomState noiseConfig, SurfaceRules.RuleSource materialRule) {
-        super(noiseChunkGenerator, heightLimitView);
+    public CarvingContext(NoiseBasedChunkGenerator noiseChunkGenerator, RegistryAccess registryManager, LevelHeightAccessor heightLimitView, NoiseChunk chunkNoiseSampler, RandomState noiseConfig, SurfaceRules.RuleSource materialRule, @javax.annotation.Nullable net.minecraft.world.level.Level level) { // Paper
+        super(noiseChunkGenerator, heightLimitView, level); // Paper
         this.registryAccess = registryManager;
         this.noiseChunk = chunkNoiseSampler;
         this.randomState = noiseConfig;
diff --git a/src/main/java/net/minecraft/world/level/levelgen/placement/PlacementContext.java b/src/main/java/net/minecraft/world/level/levelgen/placement/PlacementContext.java
index 640c2683c842655bbaee8f293f1c2613ef44844e..53d818b0cc602f827d0b907e293515f6810c6792 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/placement/PlacementContext.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/placement/PlacementContext.java
@@ -18,7 +18,7 @@ public class PlacementContext extends WorldGenerationContext {
     private final Optional<PlacedFeature> topFeature;
 
     public PlacementContext(WorldGenLevel world, ChunkGenerator generator, Optional<PlacedFeature> placedFeature) {
-        super(generator, world);
+        super(generator, world, world.getLevel()); // Paper
         this.level = world;
         this.generator = generator;
         this.topFeature = placedFeature;
