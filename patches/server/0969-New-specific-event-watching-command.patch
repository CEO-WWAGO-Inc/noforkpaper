From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: RyGuy <TheRealRyGuy@users.noreply.github.com>
Date: Tue, 21 Mar 2023 20:38:44 -0400
Subject: [PATCH] New specific event watching command


diff --git a/src/main/java/io/papermc/paper/command/PaperCommand.java b/src/main/java/io/papermc/paper/command/PaperCommand.java
index 53c54fa19fbb3760515a5cb161cdda989d29a70a..32a2e1c3be4ae879796fc8d9a88964c295f4a606 100644
--- a/src/main/java/io/papermc/paper/command/PaperCommand.java
+++ b/src/main/java/io/papermc/paper/command/PaperCommand.java
@@ -46,6 +46,7 @@ public final class PaperCommand extends Command {
         commands.put(Set.of("mobcaps", "playermobcaps"), new MobcapsCommand());
         commands.put(Set.of("dumplisteners"), new DumpListenersCommand());
         commands.put(Set.of("logevents"), LogEventsCommand.get());
+        commands.put(Set.of("logevent"), LogEventCommand.get());
 
         return commands.entrySet().stream()
             .flatMap(entry -> entry.getKey().stream().map(s -> Map.entry(s, entry.getValue())))
diff --git a/src/main/java/io/papermc/paper/command/subcommands/LogEventCommand.java b/src/main/java/io/papermc/paper/command/subcommands/LogEventCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..ac04ab6b332c939445b699478e970d2a88259cbb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/subcommands/LogEventCommand.java
@@ -0,0 +1,145 @@
+package io.papermc.paper.command.subcommands;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import com.google.gson.internal.Streams;
+import com.google.gson.stream.JsonWriter;
+import io.papermc.paper.command.PaperSubcommand;
+import io.papermc.paper.util.misc.LoggedEvent;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.CommandSender;
+import org.bukkit.event.Event;
+import org.bukkit.event.Listener;
+import org.bukkit.plugin.EventExecutor;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.io.IOException;
+import java.io.PrintStream;
+import java.io.StringWriter;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.time.LocalDateTime;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Collections;
+import java.util.concurrent.ConcurrentHashMap;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.GREEN;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+
+@DefaultQualifier(NonNull.class)
+public class LogEventCommand implements PaperSubcommand {
+
+    @Nullable
+    private static LogEventCommand instance; //will be null if called before command reg
+
+    private final Map<Class<? extends Event>, List<Wrapper>> watching = new ConcurrentHashMap<>(); //only concurrent in the rare case that multiple people are debugging, should be unnecessary
+    private final Path parent = Path.of("event-debug");
+    private LogEventCommand() {
+    }
+
+    public static synchronized LogEventCommand get() {
+        if (instance == null)
+            instance = new LogEventCommand();
+        return instance;
+    }
+
+    public void tryLog(Event event, @Nullable Listener listener, @Nullable EventExecutor executor) { //listener should only be null on the initial event call
+        List<Wrapper> wrappers = watching.get(event.getClass());
+        if (wrappers != null)
+            wrappers.add(new Wrapper(event, listener, executor));
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String subCommand, String[] args) {
+        if (args.length < 1) {
+            sender.sendMessage(text("Invalid Usage! /paper watchevent <event name>", RED));
+            return true;
+        }
+        Class<? extends Event> clazz;
+        try {
+            clazz = (Class<? extends Event>) Class.forName(args[0]);
+        } catch (ClassNotFoundException | ClassCastException ex) {
+            sender.sendMessage(text("Invalid event class " + args[0], RED));
+            return true;
+        }
+        List<Wrapper> wrappers = watching.get(clazz);
+        if (wrappers != null) {
+            try {
+                dumpToFile(sender, clazz, wrappers);
+            } catch (IOException ex) {
+                sender.sendMessage(text("Failed to log event information! See the console for more info.", RED));
+                MinecraftServer.LOGGER.warn("Error occurred while logging event information", ex);
+            }
+        } else {
+            watching.put(clazz, new ArrayList<>());
+            sender.sendMessage(text("Now watching event " + args[0] + "!", GREEN));
+        }
+        return true;
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String subCommand, String[] args) {
+        return switch (args.length) {
+            case 0 -> new ArrayList<>(DumpListenersCommand.eventClassNames());
+            case 1 -> DumpListenersCommand.eventClassNames().stream()
+                .filter(clazz -> clazz.toLowerCase(Locale.ROOT).contains(args[0].toLowerCase(Locale.ROOT)))
+                .toList();
+            default -> Collections.emptyList();
+        };
+    }
+
+    private void dumpToFile(CommandSender sender, Class<? extends Event> event, List<Wrapper> wrappers) throws IOException {
+        JsonArray array = new JsonArray();
+        wrappers.forEach(w -> array.add(w.serialize()));
+
+        StringWriter stringWriter = new StringWriter();
+        JsonWriter jsonWriter = new JsonWriter(stringWriter);
+        jsonWriter.setIndent(" ");
+        jsonWriter.setLenient(false);
+        Streams.write(array, jsonWriter);
+
+        Path parent = this.parent.resolve(event.getSimpleName());
+        Path path = parent.resolve(LoggedEvent.FORMATTER.format(LocalDateTime.now()) + ".txt");
+        Files.createDirectories(parent);
+        Path file = Files.createFile(path);
+
+        try (PrintStream out = new PrintStream(Files.newOutputStream(file), false, StandardCharsets.UTF_8)) {
+            out.print(stringWriter);
+        }
+        sender.sendMessage(text("Successfully dumped event information to " + file, GREEN));
+        watching.remove(event);
+    }
+
+    /**
+     * EventWrapper subclass to apply listener information to our Json object
+     */
+    @DefaultQualifier(Nullable.class)
+    private static final class Wrapper extends LoggedEvent {
+        private final Listener listener;
+        private final EventExecutor executor;
+
+        public Wrapper(Event event, @Nullable Listener listener, EventExecutor executor) {
+            super(event);
+            this.listener = listener;
+            this.executor = executor;
+        }
+
+        public JsonObject serialize() {
+            JsonObject obj = super.serialize();
+            if (obj == null)
+                return null;
+            if (listener != null)
+                obj.addProperty("listener", listener.getClass().getCanonicalName());
+            if (executor != null)
+                obj.addProperty("executor", executor.getClass().getCanonicalName());
+            return obj;
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
index b658a79664edb1a677398c291e22dc29f7bad261..7b7498437e2c20ea3b3575bf57ea3808ab018d64 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
@@ -5,6 +5,7 @@ import com.destroystokyo.paper.event.server.ServerExceptionEvent;
 import com.destroystokyo.paper.exception.ServerEventException;
 import com.google.common.collect.Sets;
 import io.papermc.paper.command.subcommands.LogEventsCommand;
+import io.papermc.paper.command.subcommands.LogEventCommand;
 import org.bukkit.Server;
 import org.bukkit.Warning;
 import org.bukkit.event.Event;
@@ -43,6 +44,7 @@ class PaperEventManager {
             throw new IllegalStateException(event.getEventName() + " may only be triggered synchronously.");
         }
         LogEventsCommand.get().tryLogEvent(event);
+        LogEventCommand.get().tryLog(event, null, null);
 
         HandlerList handlers = event.getHandlers();
         RegisteredListener[] listeners = handlers.getRegisteredListeners();
@@ -54,6 +56,7 @@ class PaperEventManager {
 
             try {
                 registration.callEvent(event);
+                LogEventCommand.get().tryLog(event, registration.getListener(), registration.getExecutor());
             } catch (AuthorNagException ex) {
                 Plugin plugin = registration.getPlugin();
 
