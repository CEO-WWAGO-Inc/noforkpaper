From 8517a764f242036476d022c796f9cfeb27a0db8e Mon Sep 17 00:00:00 2001
From: Antony Riley <antony@cyberiantiger.org>
Date: Mon, 4 Apr 2016 23:52:55 +0300
Subject: [PATCH] Add an iostat command to show disk usage stats per world.


diff --git a/src/main/java/com/destroystokyo/paper/IostatCommand.java b/src/main/java/com/destroystokyo/paper/IostatCommand.java
new file mode 100644
index 0000000..c3e9b65
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/IostatCommand.java
@@ -0,0 +1,57 @@
+package com.destroystokyo.paper;
+
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.chunkio2.PersistenceCounters;
+import org.bukkit.craftbukkit.chunkio2.WorldPersistence;
+
+public class IostatCommand extends Command {
+
+    public IostatCommand(String name) {
+        super(name);
+        this.description = "Get statistics on disk utilisation per world.";
+        this.usageMessage = "/iostat";
+        setPermission("bukkit.command.iostat");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        if ( !testPermission(sender) ) {
+            return true;
+        }
+
+        if ( !PaperConfig.usePaperIO ) {
+            sender.sendMessage(ChatColor.RED + "Please enable settings.use-paper-io in order to use iostat.");
+            return true;
+        }
+
+        if ( !PaperConfig.paperIOStats ) {
+            sender.sendMessage(ChatColor.RED + "Please enable settings.paper-io-stats in order to use iostat.");
+            return true;
+        }
+
+        Bukkit.getServer().getWorlds().stream().map((w) -> w.getName()).sorted().forEach((w) -> {
+            WorldPersistence persistence = ((CraftWorld)Bukkit.getWorld(w)).getHandle().getDataManager().getPersistence();
+            sender.sendMessage(ChatColor.GREEN + w + ":");
+            if (persistence != null) {
+                PersistenceCounters counters = persistence.getCounters();
+                if (persistence.hasPlayerPersistence()) {
+                    sender.sendMessage(ChatColor.GOLD + "    Players loaded: " + counters.getPlayersRead());
+                    sender.sendMessage(ChatColor.GOLD + "    Players saved: " + counters.getPlayersWritten());
+                }
+                sender.sendMessage(ChatColor.GOLD + "    Chunks loaded: " + counters.getChunksRead());
+                sender.sendMessage(ChatColor.GOLD + "    Chunks saved: " + counters.getChunksWritten());
+                sender.sendMessage(ChatColor.GOLD + "    Bytes read: " + counters.getBytesRead());
+                sender.sendMessage(ChatColor.GOLD + "    Bytes written: " + counters.getBytesWritten());
+            } else {
+                sender.sendMessage(ChatColor.RED + "    (No stats)");
+            }
+        });
+
+        return true;
+    }
+    
+}
\ No newline at end of file
diff --git a/src/main/java/com/destroystokyo/paper/PaperConfig.java b/src/main/java/com/destroystokyo/paper/PaperConfig.java
index 8f3bfe6..a5f9082 100644
--- a/src/main/java/com/destroystokyo/paper/PaperConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperConfig.java
@@ -195,6 +195,7 @@ public class PaperConfig {
     public static int paperIORegionFileCacheSize = 256;
     public static int paperIOAsyncChunkSaveQueueSize = 0;
     public static int paperIOAsyncChunkSaveQueueThreads = 1;
+    public static boolean paperIOStats = true;
     private static void paperIO() {
         usePaperIO = getBoolean("settings.paper-io", false);
         // Region file cache size (per world). 
@@ -211,5 +212,10 @@ public class PaperConfig {
         if (paperIOAsyncChunkSaveQueueSize < 1) {
             paperIOAsyncChunkSaveQueueSize = 1;
         }
+        paperIOStats = getBoolean("settings.paper-io-stats", true);
+
+        if (usePaperIO && paperIOStats) {
+            commands.put("iostat", new IostatCommand("iostat"));
+        }
     }
 }
diff --git a/src/main/java/net/minecraft/server/IDataManager.java b/src/main/java/net/minecraft/server/IDataManager.java
index 44ac431..1aa58c5 100644
--- a/src/main/java/net/minecraft/server/IDataManager.java
+++ b/src/main/java/net/minecraft/server/IDataManager.java
@@ -1,8 +1,12 @@
 package net.minecraft.server;
 
-import java.io.Closeable;
 import java.io.File;
 
+// Paper - Start
+import java.io.Closeable;
+import org.bukkit.craftbukkit.chunkio2.WorldPersistence;
+// Paper - End
+
 public interface IDataManager extends Closeable { // Paper - Closing worlds would be nice!
 
     WorldData getWorldData();
@@ -25,5 +29,7 @@ public interface IDataManager extends Closeable { // Paper - Closing worlds woul
 
     DefinedStructureManager h();
 
+    WorldPersistence getPersistence(); // Paper - expose WorldPersistence
+
     java.util.UUID getUUID(); // CraftBukkit
 }
diff --git a/src/main/java/net/minecraft/server/WorldNBTStorage.java b/src/main/java/net/minecraft/server/WorldNBTStorage.java
index 820a815..649b15d 100644
--- a/src/main/java/net/minecraft/server/WorldNBTStorage.java
+++ b/src/main/java/net/minecraft/server/WorldNBTStorage.java
@@ -20,6 +20,7 @@ import org.bukkit.craftbukkit.entity.CraftPlayer;
 import java.util.Arrays;
 import java.util.List;
 import java.util.stream.Collectors;
+import org.bukkit.craftbukkit.chunkio2.WorldPersistence;
 // Paper end
 
 public class WorldNBTStorage implements IDataManager, IPlayerFileData {
@@ -335,6 +336,10 @@ public class WorldNBTStorage implements IDataManager, IPlayerFileData {
     public void close() throws IOException {
         a(); // This is more like flush() than close()
     }
+
+    public WorldPersistence getPersistence() {
+        return null;
+    }
     // Paper end
 
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio2/AtomicPersistenceCounters.java b/src/main/java/org/bukkit/craftbukkit/chunkio2/AtomicPersistenceCounters.java
new file mode 100644
index 0000000..200f8b6
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio2/AtomicPersistenceCounters.java
@@ -0,0 +1,87 @@
+package org.bukkit.craftbukkit.chunkio2;
+
+import java.util.concurrent.atomic.AtomicLong;
+
+public class AtomicPersistenceCounters implements PersistenceCounters {
+
+    private final AtomicLong bytesRead;
+    private final AtomicLong bytesWritten;
+    private final AtomicLong chunksRead;
+    private final AtomicLong chunksWritten;
+    private final AtomicLong playersRead;
+    private final AtomicLong playersWritten;
+
+    public AtomicPersistenceCounters() {
+        this(0L, 0L, 0L, 0L, 0L, 0L);
+    }
+
+    public AtomicPersistenceCounters(long bytesRead, long bytesWritten, long chunksRead, long chunksWritten, long playersRead, long playersWritten) {
+        this.bytesRead = new AtomicLong(bytesRead);
+        this.bytesWritten = new AtomicLong(bytesWritten);
+        this.chunksRead = new AtomicLong(chunksRead);
+        this.chunksWritten = new AtomicLong(chunksWritten);
+        this.playersRead = new AtomicLong(playersRead);
+        this.playersWritten = new AtomicLong(playersWritten);
+    }
+
+    @Override
+    public void bytesRead(long bytes) {
+        bytesRead.addAndGet(bytes);
+    }
+
+    @Override
+    public void bytesWritten(long bytes) {
+        bytesWritten.addAndGet(bytes);
+    }
+
+    @Override
+    public void chunksRead(long chunks) {
+        chunksRead.addAndGet(chunks);
+    }
+
+    @Override
+    public void chunksWritten(long chunks) {
+        chunksWritten.addAndGet(chunks);
+    }
+
+    @Override
+    public void playersRead(long players) {
+        playersRead.addAndGet(players);
+    }
+
+    @Override
+    public void playersWritten(long players) {
+        playersWritten.addAndGet(players);
+    }
+
+    @Override
+    public long getBytesRead() {
+        return bytesRead.get();
+    }
+
+    @Override
+    public long getBytesWritten() {
+        return bytesWritten.get();
+    }
+
+    @Override
+    public long getChunksRead() {
+        return chunksRead.get();
+    }
+
+    @Override
+    public long getChunksWritten() {
+        return chunksWritten.get();
+    }
+
+    @Override
+    public long getPlayersRead() {
+        return playersRead.get();
+    }
+
+    @Override
+    public long getPlayersWritten() {
+        return playersWritten.get();
+    }
+    
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio2/CountingInputStream.java b/src/main/java/org/bukkit/craftbukkit/chunkio2/CountingInputStream.java
new file mode 100644
index 0000000..560333d
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio2/CountingInputStream.java
@@ -0,0 +1,49 @@
+package org.bukkit.craftbukkit.chunkio2;
+
+import java.io.FilterInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+public final class CountingInputStream extends FilterInputStream {
+    private final PersistenceCounters counters;
+    private long counter = 0L;
+
+    public CountingInputStream(InputStream in, PersistenceCounters counters) {
+        super(in);
+        this.counters = counters;
+    }
+
+    @Override
+    public int read(byte[] b, int off, int len) throws IOException {
+        int result = super.read(b, off, len);
+        if (result > 0) {
+            counter += result;
+        }
+        return result;
+    }
+
+    @Override
+    public int read(byte[] b) throws IOException {
+        int result = super.read(b);
+        if (result > 0) {
+            counter += result;
+        }
+        return result;
+    }
+
+    @Override
+    public int read() throws IOException {
+        int result = super.read();
+        if (result >= 0) {
+            counter++;
+        }
+        return result;
+    }
+
+    @Override
+    public void close() throws IOException {
+        counters.bytesRead(counter);
+        super.close();
+    }
+    
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio2/CountingOutputStream.java b/src/main/java/org/bukkit/craftbukkit/chunkio2/CountingOutputStream.java
new file mode 100644
index 0000000..40774dd
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio2/CountingOutputStream.java
@@ -0,0 +1,49 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.bukkit.craftbukkit.chunkio2;
+
+import java.io.FilterOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ *
+ * @author antony
+ */
+public final class CountingOutputStream extends FilterOutputStream {
+    private final PersistenceCounters counters;
+    private long counter = 0L;
+
+    public CountingOutputStream(OutputStream out, PersistenceCounters counters) {
+        super(out);
+        this.counters = counters;
+    }
+
+    @Override
+    public void close() throws IOException {
+        counters.bytesWritten(counter);
+        super.close();
+    }
+
+    @Override
+    public void write(byte[] b, int off, int len) throws IOException {
+        super.write(b, off, len);
+        counter += len;
+    }
+
+    @Override
+    public void write(byte[] b) throws IOException {
+        super.write(b);
+        counter += b.length;
+    }
+
+    @Override
+    public void write(int b) throws IOException {
+        super.write(b);
+        counter++;
+    }
+    
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio2/NullPersistenceCounters.java b/src/main/java/org/bukkit/craftbukkit/chunkio2/NullPersistenceCounters.java
new file mode 100644
index 0000000..402ec5d
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio2/NullPersistenceCounters.java
@@ -0,0 +1,68 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.bukkit.craftbukkit.chunkio2;
+
+/**
+ *
+ * @author antony
+ */
+public class NullPersistenceCounters implements PersistenceCounters {
+
+    @Override
+    public void bytesRead(long bytes) {
+    }
+
+    @Override
+    public void bytesWritten(long bytes) {
+    }
+
+    @Override
+    public void chunksRead(long chunks) {
+    }
+
+    @Override
+    public void chunksWritten(long chunks) {
+    }
+
+    @Override
+    public void playersRead(long players) {
+    }
+
+    @Override
+    public void playersWritten(long players) {
+    }
+
+    @Override
+    public long getBytesRead() {
+        return 0L;
+    }
+
+    @Override
+    public long getBytesWritten() {
+        return 0L;
+    }
+
+    @Override
+    public long getChunksRead() {
+        return 0L;
+    }
+
+    @Override
+    public long getChunksWritten() {
+        return 0L;
+    }
+
+    @Override
+    public long getPlayersRead() {
+        return 0L;
+    }
+
+    @Override
+    public long getPlayersWritten() {
+        return 0L;
+    }
+    
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio2/PersistenceCounters.java b/src/main/java/org/bukkit/craftbukkit/chunkio2/PersistenceCounters.java
index 104c93a..33d1029 100644
--- a/src/main/java/org/bukkit/craftbukkit/chunkio2/PersistenceCounters.java
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio2/PersistenceCounters.java
@@ -3,9 +3,30 @@ package org.bukkit.craftbukkit.chunkio2;
 /**
  * Intended to become public API
  */
-public class PersistenceCounters {
+public interface PersistenceCounters {
 
-    // TODO
-    // Counters pertaining to world saving, so we can get per world stats on chunk io
+    public void bytesRead(long bytes);
+
+    public void bytesWritten(long bytes);
+
+    public void chunksRead(long chunks);
+
+    public void chunksWritten(long chunks);
+
+    public void playersRead(long players);
+
+    public void playersWritten(long players);
+
+    public long getBytesRead();
+
+    public long getBytesWritten();
+
+    public long getChunksRead();
+
+    public long getChunksWritten();
+
+    public long getPlayersRead();
+
+    public long getPlayersWritten();
     
 }
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio2/WorldPersistence.java b/src/main/java/org/bukkit/craftbukkit/chunkio2/WorldPersistence.java
index 42c392c..ff0098b 100644
--- a/src/main/java/org/bukkit/craftbukkit/chunkio2/WorldPersistence.java
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio2/WorldPersistence.java
@@ -104,7 +104,7 @@ public interface WorldPersistence extends ChunkPersistence {
      * This includes bytes and chunks read/written, and is intended for
      * monitoring disk usage per world.
      * 
-     * @return A copy of the current counters
+     * @return The current counters
      */
     @Nonnull
     public PersistenceCounters getCounters();
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio2/anvil/AnvilRegionFile.java b/src/main/java/org/bukkit/craftbukkit/chunkio2/anvil/AnvilRegionFile.java
index 5cc3db5..2ef1e43 100644
--- a/src/main/java/org/bukkit/craftbukkit/chunkio2/anvil/AnvilRegionFile.java
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio2/anvil/AnvilRegionFile.java
@@ -30,10 +30,10 @@ import java.util.zip.InflaterInputStream;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.bukkit.craftbukkit.chunkio2.IOConsumer;
+import org.bukkit.craftbukkit.chunkio2.PersistenceCounters;
 
 class AnvilRegionFile implements Closeable {
     private static final Logger LOG = LogManager.getLogger();
-    private final Object LOCK = new Object();
     private static final int BLOCK_SIZE = 4096;
     private static final int HEADER_SIZE = BLOCK_SIZE * 2;
     private static final int CHUNK_COUNT = 1024;
@@ -44,6 +44,8 @@ class AnvilRegionFile implements Closeable {
     private final RandomAccessFile fd;
     private final MappedByteBuffer header;
     private final IntBuffer intHeader;
+    private final PersistenceCounters counters;
+    private final Object LOCK = new Object();
     private final Object REF_LOCK = new Object();
     private int inUseCount = 0;
     private final FreeSpaceMap freeSpaceMap;
@@ -52,7 +54,8 @@ class AnvilRegionFile implements Closeable {
      */
     private final BitSet present = new BitSet(1024);
 
-    public AnvilRegionFile(File file, boolean create) throws IOException {
+    public AnvilRegionFile(File file, boolean create, PersistenceCounters counters) throws IOException {
+        this.counters = counters;
         if (create && !file.exists()) {
             throw new FileNotFoundException();
         }
@@ -61,8 +64,11 @@ class AnvilRegionFile implements Closeable {
         if (this.fd.length() < HEADER_SIZE) {
             this.fd.setLength(HEADER_SIZE);
         }
-        this.header = this.fd.getChannel().map(FileChannel.MapMode.READ_WRITE, 0, 2 * BLOCK_SIZE);
+        this.header = this.fd.getChannel().map(FileChannel.MapMode.READ_WRITE, 0, HEADER_SIZE);
         this.intHeader = header.asIntBuffer();
+        header.load();
+        counters.bytesRead(HEADER_SIZE);
+
         int blockCount = (int) ((this.fd.length() + BLOCK_SIZE - 1) >> 12);
         IntArrayList blockOwner = new IntArrayList(blockCount);
         for (int i = 0; i < blockCount; i++) {
@@ -108,6 +114,7 @@ class AnvilRegionFile implements Closeable {
             }
             
             for (int i = 0; i < CHUNK_COUNT; i++) {
+                int bytesWritten = 0;
                 if (corrupt.get(i)) {
                     // Warn about corrupted overlapping chunks and delete them.
                     int location = intHeader.get(i);
@@ -115,7 +122,9 @@ class AnvilRegionFile implements Closeable {
                     int length = location & 0xFF;
                     LOG.warn("File: " + file.getPath() + " Invalid chunk (data region overlaps other chunks): " + (i&0x1f) + ", " + (i>>5) + " block location: " + length + "@" + offset);
                     intHeader.put(i, 0);
+                    bytesWritten += 4;
                 }
+                counters.bytesWritten(bytesWritten);
             }
         }
         freeSpaceMap = new FreeSpaceMap(blockOwner);
@@ -148,6 +157,7 @@ class AnvilRegionFile implements Closeable {
             intHeader.put(chunkId, location);
             intHeader.put(chunkId + CHUNK_COUNT, (int)(System.currentTimeMillis() / 1000)); // Y2k38 bug
         }
+        counters.bytesWritten(length + 8);
     }
 
     private int allocateChunk(int chunkId, int length) throws IOException {
@@ -192,6 +202,7 @@ class AnvilRegionFile implements Closeable {
             data = new byte[trueLength];
             fd.read(data, 0, trueLength);
         }
+        counters.bytesRead(data.length + 9); // 5 byte header, plus 4 bytes from main region file.
         switch (compressionType) {
             case COMPRESSION_GZIP:
                 try (DataInputStream in = new DataInputStream(new GZIPInputStream(new ByteArrayInputStream(data)))) {
@@ -244,6 +255,7 @@ class AnvilRegionFile implements Closeable {
             if (usedSpace < fd.length()) {
                 fd.setLength(usedSpace);
             }
+            header.force(); // Probably not required.
             fd.close();
         }
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio2/anvil/AnvilWorldPersistence.java b/src/main/java/org/bukkit/craftbukkit/chunkio2/anvil/AnvilWorldPersistence.java
index e34ac05..27eb89d 100644
--- a/src/main/java/org/bukkit/craftbukkit/chunkio2/anvil/AnvilWorldPersistence.java
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio2/anvil/AnvilWorldPersistence.java
@@ -1,5 +1,7 @@
 package org.bukkit.craftbukkit.chunkio2.anvil;
 
+import org.bukkit.craftbukkit.chunkio2.CountingOutputStream;
+import org.bukkit.craftbukkit.chunkio2.CountingInputStream;
 import com.destroystokyo.paper.PaperConfig;
 import java.io.DataInput;
 import java.io.DataInputStream;
@@ -54,6 +56,7 @@ final class AnvilWorldPersistence implements WorldPersistence {
     private final Object SESSION_LOCK = new Object();
     private final File folder;
     private final boolean primary;
+    private final PersistenceCounters counters;
     private final File data;
     private final PlayerPersistence playerPersistence;
     private final File regionData;
@@ -62,10 +65,11 @@ final class AnvilWorldPersistence implements WorldPersistence {
 
     private UUID uuid = null;
 
-    public AnvilWorldPersistence(File folder, String name, World.Environment env, boolean primary) throws IOException {
+    public AnvilWorldPersistence(File folder, String name, World.Environment env, boolean primary, PersistenceCounters counters) throws IOException {
         this.folder = folder;
         this.name = name;
         this.primary = primary;
+        this.counters = counters;
         this.data = getWorldFile("data");
         if (primary) {
             playerPersistence = new AnvilPlayerPersistence();
@@ -93,12 +97,12 @@ final class AnvilWorldPersistence implements WorldPersistence {
         writeSessionLock();
     }
 
-    private static DataInputStream openGzipCompressedStream(InputStream in) throws IOException {
-        return new DataInputStream(new GZIPInputStream(in, 1<<12));
+    private DataInputStream openGzipCompressedStream(InputStream in) throws IOException {
+        return new DataInputStream(new GZIPInputStream(new CountingInputStream(in, counters), 1<<12));
     }
 
-    private static DataOutputStream openGzipCompressedStream(OutputStream out) throws IOException {
-        return new DataOutputStream(new GZIPOutputStream(out, 1<<12));
+    private DataOutputStream openGzipCompressedStream(OutputStream out) throws IOException {
+        return new DataOutputStream(new GZIPOutputStream(new CountingOutputStream(out, counters), 1<<12));
     }
 
     @Override
@@ -120,7 +124,7 @@ final class AnvilWorldPersistence implements WorldPersistence {
             File uuidFile = getWorldFile("uuid.dat");
             if (uuidFile.isFile()) {
                 try {
-                    try (DataInputStream in = new DataInputStream(new FileInputStream(uuidFile))) {
+                    try (DataInputStream in = new DataInputStream(new CountingInputStream(new FileInputStream(uuidFile), counters))) {
                         uuid = new UUID(in.readLong(), in.readLong());
                     }
                 } catch (IOException ex) {
@@ -140,7 +144,7 @@ final class AnvilWorldPersistence implements WorldPersistence {
             this.uuid = uuid;
             File uuidFile = getWorldFile("uuid.dat");
             try {
-                try (DataOutputStream out = new DataOutputStream(new FileOutputStream(uuidFile))) {
+                try (DataOutputStream out = new DataOutputStream(new CountingOutputStream(new FileOutputStream(uuidFile), counters))) {
                     out.writeLong(uuid.getMostSignificantBits());
                     out.writeLong(uuid.getLeastSignificantBits());
                 }
@@ -220,7 +224,7 @@ final class AnvilWorldPersistence implements WorldPersistence {
                 File file = getRegionFile(x, z);
                 regionFile = regionFiles.get(file);
                 if (regionFile == null) {
-                    regionFile = new AnvilRegionFile(file, create);
+                    regionFile = new AnvilRegionFile(file, create, counters);
                     regionFiles.put(file, regionFile);
                 }
                 regionFile.ref();
@@ -265,6 +269,7 @@ final class AnvilWorldPersistence implements WorldPersistence {
             @Override
             public void accept(AnvilRegionFile t) throws IOException {
                 t.loadChunk(x & 0x1f, z & 0x1f, handler);
+                counters.chunksRead(1L);
             }
 
             @Override
@@ -280,6 +285,7 @@ final class AnvilWorldPersistence implements WorldPersistence {
             @Override
             public void accept(AnvilRegionFile t) throws IOException {
                 t.saveChunk(x & 0x1f, z & 0x1f, handler);
+                counters.chunksWritten(1L);
             }
 
             @Override
@@ -295,7 +301,7 @@ final class AnvilWorldPersistence implements WorldPersistence {
 
     @Override
     public PersistenceCounters getCounters() {
-        return new PersistenceCounters();
+        return counters;
     }
 
     @Override
@@ -311,7 +317,7 @@ final class AnvilWorldPersistence implements WorldPersistence {
     private void writeSessionLock() throws IOException {
         synchronized (SESSION_LOCK) {
             try {
-                try (DataOutputStream out = new DataOutputStream(new FileOutputStream(getWorldFile("session.lock")))) {
+                try (DataOutputStream out = new DataOutputStream(new CountingOutputStream(new FileOutputStream(getWorldFile("session.lock")),counters))) {
                     out.writeLong(sessionId);
                 }
             } catch (IOException ex) {
@@ -324,7 +330,7 @@ final class AnvilWorldPersistence implements WorldPersistence {
     public void checkSession() throws WorldConflictException {
         synchronized (SESSION_LOCK) {
             try {
-                try (DataInputStream in = new DataInputStream(new FileInputStream(getWorldFile("session.lock")))) {
+                try (DataInputStream in = new DataInputStream(new CountingInputStream(new FileInputStream(getWorldFile("session.lock")), counters))) {
                     if (sessionId != in.readLong())
                         throw new WorldConflictException("The save for world located at " + getWorldFolder() + " is being accessed from another location, aborting");
                 }
@@ -414,6 +420,7 @@ final class AnvilWorldPersistence implements WorldPersistence {
                     // If this fails, it is non-fatal, so do not throw IOException
                     playerFile.renameTo(getOfflineReadFile(playerFile));
                 }
+                counters.playersRead(1L);
             } catch (IOException ex) {
                 handler.exception(ex);
             }
@@ -437,6 +444,7 @@ final class AnvilWorldPersistence implements WorldPersistence {
                     // This is fatal, so throw an IOException
                     throw new IOException("Could not rename temporary player save: " + playerFileNew + " to: " + playerFile);
                 }
+                counters.playersWritten(1L);
             } catch (IOException ex) {
                 handler.exception(ex);
             }
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio2/anvil/AnvilWorldPersistenceFactory.java b/src/main/java/org/bukkit/craftbukkit/chunkio2/anvil/AnvilWorldPersistenceFactory.java
index 9e1ae8d..832767b 100644
--- a/src/main/java/org/bukkit/craftbukkit/chunkio2/anvil/AnvilWorldPersistenceFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio2/anvil/AnvilWorldPersistenceFactory.java
@@ -1,8 +1,11 @@
 package org.bukkit.craftbukkit.chunkio2.anvil;
 
+import com.destroystokyo.paper.PaperConfig;
 import java.io.File;
 import java.io.IOException;
 import org.bukkit.World;
+import org.bukkit.craftbukkit.chunkio2.AtomicPersistenceCounters;
+import org.bukkit.craftbukkit.chunkio2.NullPersistenceCounters;
 import org.bukkit.craftbukkit.chunkio2.WorldPersistence;
 import org.bukkit.craftbukkit.chunkio2.WorldPersistenceFactory;
 
@@ -15,6 +18,6 @@ public final class AnvilWorldPersistenceFactory implements WorldPersistenceFacto
 
     @Override
     public WorldPersistence createWorldPersistence(File folder, String name, World.Environment env, boolean primary) throws IOException {
-        return new AnvilWorldPersistence(folder, name, env, primary);
+        return new AnvilWorldPersistence(folder, name, env, primary, PaperConfig.paperIOStats ? new AtomicPersistenceCounters() : new NullPersistenceCounters() );
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio2/impl/CraftNBTStorage.java b/src/main/java/org/bukkit/craftbukkit/chunkio2/impl/CraftNBTStorage.java
index 160c934..9b4572c 100644
--- a/src/main/java/org/bukkit/craftbukkit/chunkio2/impl/CraftNBTStorage.java
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio2/impl/CraftNBTStorage.java
@@ -201,4 +201,9 @@ public class CraftNBTStorage implements IDataManager, IPlayerFileData {
         a();
         persistence.close();
     }
+
+    @Override
+    public WorldPersistence getPersistence() {
+        return persistence;
+    }
 }
\ No newline at end of file
-- 
1.9.1

