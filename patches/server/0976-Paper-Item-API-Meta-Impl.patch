From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Sat, 18 Mar 2023 01:08:20 -0400
Subject: [PATCH] Paper Item API Meta Impl


diff --git a/src/main/java/io/papermc/paper/item/meta/EnchantmentMap.java b/src/main/java/io/papermc/paper/item/meta/EnchantmentMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..991841eaa8e722ce95b9fcaf395138bef555eabe
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/EnchantmentMap.java
@@ -0,0 +1,115 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.EnchantmentPair;
+import io.papermc.paper.property.MutablePropertyView;
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.types.EnchantmentPairImpl;
+import org.bukkit.enchantments.Enchantment;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+public class EnchantmentMap {
+
+    private final MutablePropertyView propertyHolder;
+    private final PropertyKey<List<EnchantmentPair>> key;
+
+    public EnchantmentMap(MutablePropertyView propertyView, PropertyKey<List<EnchantmentPair>> propertyKey) {
+        this.propertyHolder = propertyView;
+        this.key = propertyKey;
+    }
+
+    public boolean hasEnchant(Enchantment ench) {
+        List<EnchantmentPair> enchantments = this.propertyHolder.getOrDefault(this.key, List.of());
+        for (EnchantmentPair next : enchantments) {
+            if (next.enchantment().equals(ench)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    public int getEnchantLevel(Enchantment ench) {
+        List<EnchantmentPair> enchantmentPairs = this.propertyHolder.getOrDefault(this.key, List.of());
+        for (EnchantmentPair pair : enchantmentPairs) {
+            if (pair.enchantment().equals(ench)) {
+                return pair.level();
+            }
+        }
+
+        return 0;
+    }
+
+    public Map<Enchantment, Integer> getEnchants() {
+        List<EnchantmentPair> pairs = this.propertyHolder.getOrDefault(this.key, List.of());
+        Map<Enchantment, Integer> map = new HashMap<>();
+        for (EnchantmentPair enchantmentPair : pairs) {
+            map.put(enchantmentPair.enchantment(), enchantmentPair.level());
+        }
+
+        return map;
+    }
+
+    public boolean addEnchant(Enchantment ench, int level, boolean ignoreRestrictions) {
+        if (ignoreRestrictions || level >= ench.getStartLevel() && level <= ench.getMaxLevel()) {
+            List<EnchantmentPair> enchantments = this.propertyHolder.getOrCreate(this.key);
+
+            EnchantmentPair oldValue = null;
+            int oldIndex = 0;
+            for (int i = 0; i < enchantments.size(); i++) {
+                EnchantmentPair value = enchantments.get(i);
+                if (value.enchantment().equals(ench)) {
+                    oldValue = value;
+                    oldIndex = i;
+                    break;
+                }
+            }
+
+            if (oldValue == null) {
+                enchantments.add(new EnchantmentPairImpl(ench, level));
+                return true;
+            } else {
+                enchantments.set(oldIndex, new EnchantmentPairImpl(ench, level));
+                return oldValue.level() != level;
+            }
+        }
+
+        return false;
+    }
+
+    public boolean removeEnchant(Enchantment ench) {
+        List<EnchantmentPair> enchantmentMap = this.propertyHolder.getOrDefault(this.key, List.of());
+
+        Iterator<EnchantmentPair> iterator = enchantmentMap.listIterator();
+        while (iterator.hasNext()) {
+            EnchantmentPair next = iterator.next();
+            if (next.enchantment().equals(ench)) {
+                iterator.remove();
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    public boolean hasEnchants() {
+        return !this.propertyHolder.getOrDefault(this.key, List.of()).isEmpty();
+    }
+
+    public boolean hasConflictingEnchant(Enchantment ench) {
+        if (!hasEnchants()) {
+            return false;
+        }
+
+        for (EnchantmentPair enchant : this.propertyHolder.getOrDefault(this.key, List.of())) {
+            if (enchant.enchantment().conflictsWith(ench)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaArmor.java b/src/main/java/io/papermc/paper/item/meta/MetaArmor.java
new file mode 100644
index 0000000000000000000000000000000000000000..aa9142962655b14efaa32a9f008966edaab92c45
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaArmor.java
@@ -0,0 +1,74 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaArmor;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.ArmorMeta;
+import org.bukkit.inventory.meta.trim.ArmorTrim;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Objects;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaArmor extends PaperMeta implements ArmorMeta {
+
+    public MetaArmor(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @Override
+    public boolean hasTrim() {
+        return this.propertyHolder.hasProperty(ItemProperties.ARMOR_TRIM);
+    }
+
+    @Override
+    public void setTrim(@Nullable ArmorTrim trim) {
+        this.propertyHolder.set(ItemProperties.ARMOR_TRIM, trim);
+    }
+
+    @Override
+    public @Nullable ArmorTrim getTrim() {
+        return this.propertyHolder.get(ItemProperties.ARMOR_TRIM);
+    }
+
+    @Override
+    public @NotNull MetaArmor clone() {
+        return new MetaArmor(this.propertyHolder.clone());
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.unsetInPropertyPath(mutable, ItemProperties.DISPLAY, ItemProperties.ARMOR_TRIM);
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaArmor || this.isArmorEmpty());
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta that) {
+        if (!super.equalsCommon(that)) {
+            return false;
+        }
+
+        if (that instanceof MetaArmor armorMeta) {
+            return Objects.equals(this.getTrim(), armorMeta.getTrim());
+        }
+
+        return true;
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isArmorEmpty();
+    }
+
+    private boolean isArmorEmpty() {
+        return !this.hasTrim();
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaAxolotlBucket.java b/src/main/java/io/papermc/paper/item/meta/MetaAxolotlBucket.java
new file mode 100644
index 0000000000000000000000000000000000000000..a28afd898992d2fb58ac91330b22f3e2eef5f3a3
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaAxolotlBucket.java
@@ -0,0 +1,70 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.entity.Axolotl;
+import org.bukkit.inventory.meta.AxolotlBucketMeta;
+import org.jetbrains.annotations.NotNull;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaAxolotlBucket extends PaperMeta implements AxolotlBucketMeta {
+
+    public MetaAxolotlBucket(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @Override
+    public @NotNull Axolotl.Variant getVariant() {
+        return this.propertyHolder.get(ItemProperties.VARIANT);
+    }
+
+    @Override
+    public void setVariant(Axolotl.@NotNull Variant variant) {
+        this.propertyHolder.set(ItemProperties.VARIANT, variant);
+    }
+
+    @Override
+    public boolean hasVariant() {
+        return this.propertyHolder.hasProperty(ItemProperties.VARIANT);
+    }
+
+    @Override
+    public @NotNull MetaAxolotlBucket clone() {
+        return new MetaAxolotlBucket(this.propertyHolder.clone());
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.VARIANT);
+        mutable.unset(ItemProperties.ENTITY_TAG);
+    }
+
+    // Equality logic
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isBucketEmpty();
+    }
+
+    boolean isBucketEmpty() {
+        return !(this.hasVariant() || this.propertyHolder.get(ItemProperties.ENTITY_TAG) != null);
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaAxolotlBucket that) {
+            return (this.hasVariant() ? that.hasVariant() && this.getVariant().equals(that.getVariant()) : !that.hasVariant()) && (this.propertyHolder.get(ItemProperties.ENTITY_TAG) != null ? that.propertyHolder.get(ItemProperties.ENTITY_TAG) != null && this.propertyHolder.get(ItemProperties.ENTITY_TAG).equals(that.propertyHolder.get(ItemProperties.ENTITY_TAG)) : that.propertyHolder.get(ItemProperties.ENTITY_TAG) == null);
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaAxolotlBucket || this.isBucketEmpty());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaBanner.java b/src/main/java/io/papermc/paper/item/meta/MetaBanner.java
new file mode 100644
index 0000000000000000000000000000000000000000..4df86c7c8c829b51fa62f945e403a15787568a9a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaBanner.java
@@ -0,0 +1,155 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import io.papermc.paper.property.nbt.AdapterContext;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.DyeColor;
+import org.bukkit.Material;
+import org.bukkit.block.Banner;
+import org.bukkit.block.banner.Pattern;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.block.CraftBlockEntityState;
+import org.bukkit.craftbukkit.block.CraftBlockStates;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.BannerMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+// It's rather strange that this is just random duplicate api.
+// So, wrap it in a banner and just pass it through the blockstate api
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaBanner extends PaperMeta implements BannerMeta {
+
+    private final Material material;
+
+    public MetaBanner(MutablePropertyView mutable, Material material) {
+        super(mutable);
+        this.material = material;
+    }
+
+    @Override
+    public @NotNull MetaBanner clone() {
+        return new MetaBanner(this.propertyHolder.clone(), material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.BLOCK_ENTITY_TAG);
+    }
+
+    // Hack, but oh well.
+    @Override
+    public @Nullable DyeColor getBaseColor() {
+        return switch (this.material) {
+            case WHITE_BANNER -> DyeColor.WHITE;
+            case ORANGE_BANNER -> DyeColor.ORANGE;
+            case MAGENTA_BANNER -> DyeColor.MAGENTA;
+            case LIGHT_BLUE_BANNER -> DyeColor.LIGHT_BLUE;
+            case YELLOW_BANNER -> DyeColor.YELLOW;
+            case LIME_BANNER -> DyeColor.LIME;
+            case PINK_BANNER -> DyeColor.PINK;
+            case GRAY_BANNER -> DyeColor.GRAY;
+            case LIGHT_GRAY_BANNER -> DyeColor.LIGHT_GRAY;
+            case CYAN_BANNER -> DyeColor.CYAN;
+            case PURPLE_BANNER -> DyeColor.PURPLE;
+            case BLUE_BANNER -> DyeColor.BLUE;
+            case BROWN_BANNER -> DyeColor.BROWN;
+            case GREEN_BANNER -> DyeColor.GREEN;
+            case RED_BANNER -> DyeColor.RED;
+            case BLACK_BANNER -> DyeColor.BLACK;
+            default -> throw new UnsupportedOperationException();
+        };
+    }
+
+    @Override
+    public void setBaseColor(@Nullable DyeColor color) {
+        // This doesn't actually do anything....
+        // Base color depends on the block type...
+    }
+
+    @Override
+    public @NotNull List<Pattern> getPatterns() {
+        return this.getBanner().getPatterns();
+    }
+
+    @Override
+    public void setPatterns(@NotNull List<Pattern> patterns) {
+        Banner banner = this.getBanner();
+        banner.setPatterns(patterns);
+        this.writeBanner(banner);
+    }
+
+    @Override
+    public void addPattern(@NotNull Pattern pattern) {
+        Banner banner = this.getBanner();
+        banner.addPattern(pattern);
+        this.writeBanner(banner);
+    }
+
+    @Override
+    public @NotNull Pattern getPattern(int i) {
+        return this.getBanner().getPattern(i);
+    }
+
+    @Override
+    public @NotNull Pattern removePattern(int i) {
+        Banner banner = this.getBanner();
+        Pattern removed = banner.removePattern(i);
+        this.writeBanner(banner);
+
+        return removed;
+    }
+
+    @Override
+    public void setPattern(int i, @NotNull Pattern pattern) {
+        Banner banner = this.getBanner();
+        banner.setPattern(i, pattern);
+        this.writeBanner(banner);
+    }
+
+    @Override
+    public int numberOfPatterns() {
+        return this.getBanner().numberOfPatterns();
+    }
+
+    // Unlike craft impl, don't include base color...
+    // it's part of the BLOCK
+
+    // Equality logic
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaBanner that) {
+            return this.getPatterns().equals(that.getPatterns());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaBanner || !this.propertyHolder.hasProperty(ItemProperties.BLOCK_ENTITY_TAG));
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && !this.propertyHolder.hasProperty(ItemProperties.BLOCK_ENTITY_TAG);
+    }
+
+    private Banner getBanner() {
+        NbtPropertyHolder nbtPropertyHolder = (NbtPropertyHolder) this.propertyHolder.get(ItemProperties.BLOCK_ENTITY_TAG);
+
+        CompoundTag tag = nbtPropertyHolder == null ? null : nbtPropertyHolder.getCompoundTag();
+        return (Banner) CraftBlockStates.getBlockState(this.material, tag);
+    }
+
+    private void writeBanner(Banner banner) {
+        MutablePropertyView mutable = NbtPropertyHolder.simpleBlob(((CraftBlockEntityState<?>) banner).getSnapshotNBT(), AdapterContext.empty());
+        this.propertyHolder.set(ItemProperties.BLOCK_ENTITY_TAG, mutable);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaBlockState.java b/src/main/java/io/papermc/paper/item/meta/MetaBlockState.java
new file mode 100644
index 0000000000000000000000000000000000000000..3006c6d1fae0f8b31ed13107b6455c4fd7323329
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaBlockState.java
@@ -0,0 +1,83 @@
+package io.papermc.paper.item.meta;
+
+import com.google.common.base.Objects;
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import io.papermc.paper.property.nbt.AdapterContext;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import org.apache.commons.lang.Validate;
+import org.bukkit.Material;
+import org.bukkit.block.BlockState;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.block.CraftBlockEntityState;
+import org.bukkit.craftbukkit.block.CraftBlockStates;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.BlockStateMeta;
+import org.jetbrains.annotations.NotNull;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaBlockState extends PaperMeta implements BlockStateMeta {
+
+    private final Material material;
+
+    public MetaBlockState(MutablePropertyView mutable, Material material) {
+        super(mutable);
+        this.material = material;
+    }
+
+    @Override
+    public boolean hasBlockState() {
+        return this.propertyHolder.hasProperty(ItemProperties.BLOCK_ENTITY_TAG);
+    }
+
+    @Override
+    public BlockState getBlockState() {
+        MutablePropertyView holder = this.propertyHolder.get(ItemProperties.BLOCK_ENTITY_TAG);
+
+        // This is expected to always return a CraftBlockEntityState for the passed material:
+        return CraftBlockStates.getBlockState(this.material, holder == null ? null : ((NbtPropertyHolder) holder).getCompoundTag());
+    }
+
+    @Override
+    public void setBlockState(BlockState blockState) {
+        Validate.notNull(blockState, "blockState must not be null");
+
+        Class<?> blockStateType = CraftBlockStates.getBlockStateType(this.material);
+        Validate.isTrue(blockStateType == blockState.getClass() && blockState instanceof CraftBlockEntityState, "Invalid blockState for " + this.material);
+
+        MutablePropertyView mutable = NbtPropertyHolder.simpleBlob(((CraftBlockEntityState) blockState).getSnapshotNBT(), AdapterContext.empty());
+        this.propertyHolder.set(ItemProperties.BLOCK_ENTITY_TAG, mutable);
+    }
+
+    @Override
+    public @NotNull MetaBlockState clone() {
+        return new MetaBlockState(this.propertyHolder.clone(), this.material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.BLOCK_ENTITY_TAG);
+    }
+
+    // Equality
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaBlockState that) {
+            return Objects.equal(this.propertyHolder.get(ItemProperties.BLOCK_ENTITY_TAG), that.propertyHolder.get(ItemProperties.BLOCK_ENTITY_TAG));
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaBlockState || this.propertyHolder.get(ItemProperties.BLOCK_ENTITY_TAG) == null);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.propertyHolder.get(ItemProperties.BLOCK_ENTITY_TAG) == null;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaBook.java b/src/main/java/io/papermc/paper/item/meta/MetaBook.java
new file mode 100644
index 0000000000000000000000000000000000000000..9677ed01bb6419e45f42b9536716d8f21f0ec65e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaBook.java
@@ -0,0 +1,434 @@
+package io.papermc.paper.item.meta;
+
+import com.google.common.collect.ImmutableList;
+import io.papermc.paper.configuration.GlobalConfiguration;
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.md_5.bungee.chat.ComponentSerializer;
+import org.apache.commons.lang.Validate;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.BookMeta;
+import org.jetbrains.annotations.NotNull;
+import org.spigotmc.ValidateUtils;
+
+import java.util.AbstractList;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+
+// TODO: Cleanup, I hate all of this
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public abstract class MetaBook extends PaperMeta implements BookMeta {
+
+    static final int MAX_PAGES = 100;
+    static final int MAX_PAGE_LENGTH = 320; // 256 limit + 64 characters to allow for psuedo colour codes
+    static final int MAX_TITLE_LENGTH = 32;
+
+    public MetaBook(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    // Simple "raw" implementations
+    @Override
+    public boolean hasAuthor() {
+        return MetaBook.this.propertyHolder.hasProperty(ItemProperties.AUTHOR);
+    }
+
+    @Override
+    public boolean hasTitle() {
+        return MetaBook.this.propertyHolder.hasProperty(ItemProperties.TITLE);
+    }
+
+    @Override
+    public boolean hasPages() {
+        return !this.getPageList().isEmpty();
+    }
+
+    @Override
+    public boolean hasGeneration() {
+        return this.propertyHolder.hasProperty(ItemProperties.GENERATION);
+    }
+
+    @Override
+    public String getTitle() {
+        return limit(MetaBook.this.propertyHolder.get(ItemProperties.TITLE), GlobalConfiguration.get().itemValidation.book.title);
+    }
+
+    @Override
+    public boolean setTitle(final String title) {
+        if (title == null) {
+            MetaBook.this.propertyHolder.unset(ItemProperties.TITLE);
+            return true;
+        } else if (title.length() > MAX_TITLE_LENGTH) {
+            return false;
+        }
+
+        MetaBook.this.propertyHolder.set(ItemProperties.TITLE, title);
+        return true;
+    }
+
+    @Override
+    public String getAuthor() {
+        return limit(MetaBook.this.propertyHolder.get(ItemProperties.AUTHOR), GlobalConfiguration.get().itemValidation.book.author);
+    }
+
+    @Override
+    public void setAuthor(String author) {
+        MetaBook.this.propertyHolder.set(ItemProperties.AUTHOR, limit(author, GlobalConfiguration.get().itemValidation.book.author));
+    }
+
+    @Override
+    public Generation getGeneration() {
+        return MetaBook.this.propertyHolder.get(ItemProperties.GENERATION);
+    }
+
+    @Override
+    public void setGeneration(Generation generation) {
+        MetaBook.this.propertyHolder.set(ItemProperties.GENERATION, generation);
+    }
+
+    // Adventure Implementations
+    @Override
+    public net.kyori.adventure.text.Component title() {
+        String title = this.getTitle();
+        return net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserializeOrNull(title);
+    }
+
+    @Override
+    public org.bukkit.inventory.meta.BookMeta title(net.kyori.adventure.text.Component title) {
+        this.setTitle(title == null ? null : net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().serialize(title));
+        return this;
+    }
+
+    @Override
+    public net.kyori.adventure.text.Component author() {
+        String author = this.getAuthor();
+        return net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserializeOrNull(author);
+    }
+
+    @Override
+    public org.bukkit.inventory.meta.BookMeta author(net.kyori.adventure.text.Component author) {
+        this.setAuthor(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().serializeOrNull(author));
+        return this;
+    }
+
+    @Override
+    public net.kyori.adventure.text.Component page(final int page) {
+        Validate.isTrue(this.isValidPage(page), "Invalid page number " + page + "/" + this.getPageCount());
+        return this.getPageList().get(page - 1);
+    }
+
+    @Override
+    public void page(final int page, net.kyori.adventure.text.Component data) {
+        Validate.isTrue(this.isValidPage(page), "Invalid page number " + page + "/" + this.getPageCount());
+
+        List<Component> pages = this.getPageList();
+        if (data == null) {
+            data = net.kyori.adventure.text.Component.empty();
+        }
+
+        pages.set(page - 1, data);
+    }
+
+    @Override
+    public List<net.kyori.adventure.text.Component> pages() {
+        return Collections.unmodifiableList(this.getPageList());
+    }
+
+    @Override
+    public BookMeta pages(List<net.kyori.adventure.text.Component> pages) {
+        List<Component> pagesPropertyValue = this.getPageListOrCreate();
+        pagesPropertyValue.clear();
+
+        for (Component page : pages) {
+            addPages(page);
+        }
+        this.clearPagesPropertyIfEmpty();
+        return this;
+    }
+
+    @Override
+    public BookMeta pages(net.kyori.adventure.text.Component... pages) {
+        this.getPageListOrCreate().clear();
+        addPages(pages);
+        this.clearPagesPropertyIfEmpty();
+        return this;
+    }
+
+    @Override
+    public void addPages(net.kyori.adventure.text.Component... pages) {
+        List<Component> pageList = this.getPageListOrCreate();
+        for (Component page : pages) {
+            if (pageList.size() >= MAX_PAGES) {
+                return;
+            }
+
+            if (page == null) {
+                page = net.kyori.adventure.text.Component.empty();
+            }
+
+            pageList.add(page);
+        }
+        this.clearPagesPropertyIfEmpty();
+    }
+
+    class PaperMetaBookAdventureBuilder implements BookMetaBuilder {
+        private net.kyori.adventure.text.Component title = null;
+        private net.kyori.adventure.text.Component author = null;
+        private final List<net.kyori.adventure.text.Component> pages = new java.util.ArrayList<>();
+
+        @Override
+        public BookMetaBuilder title(net.kyori.adventure.text.Component title) {
+            this.title = title;
+            return this;
+        }
+
+        @Override
+        public BookMetaBuilder author(net.kyori.adventure.text.Component author) {
+            this.author = author;
+            return this;
+        }
+
+        @Override
+        public BookMetaBuilder addPage(net.kyori.adventure.text.Component page) {
+            this.pages.add(page);
+            return this;
+        }
+
+        @Override
+        public BookMetaBuilder pages(net.kyori.adventure.text.Component... pages) {
+            java.util.Collections.addAll(this.pages, pages);
+            return this;
+        }
+
+        @Override
+        public BookMetaBuilder pages(java.util.Collection<net.kyori.adventure.text.Component> pages) {
+            this.pages.addAll(pages);
+            return this;
+        }
+
+        @Override
+        public BookMeta build() {
+            return MetaBook.this.build(title, author, pages);
+        }
+    }
+
+    @Override
+    public BookMetaBuilder toBuilder() {
+        return new PaperMetaBookAdventureBuilder();
+    }
+
+    // Legacy implementation
+    @Override
+    public String getPage(final int page) {
+        Validate.isTrue(this.isValidPage(page), "Invalid page number");
+
+        return LegacyComponentSerializer.legacySection().serialize(this.getPageList().get(page - 1));
+    }
+
+    @Override
+    public void setPage(final int page, final String text) {
+        Validate.isTrue(this.isValidPage(page), "Invalid page number " + page + "/" + this.getPageCount());
+
+        String newText = this.validatePage(text);
+        this.getPageListOrCreate().set(page - 1, LegacyComponentSerializer.legacySection().deserialize(newText));
+    }
+
+    @Override
+    public void setPages(final String... pages) {
+        this.setPages(Arrays.asList(pages));
+    }
+
+    @Override
+    public void addPage(final String... pages) {
+        for (String page : pages) {
+            page = this.validatePage(page);
+            this.addPages(LegacyComponentSerializer.legacySection().deserializeOr(page, Component.empty()));
+        }
+    }
+
+    @Override
+    public int getPageCount() {
+        return this.getPageList().size();
+    }
+
+    @Override
+    public List<String> getPages() {
+        List<Component> pages = this.getPageList();
+
+        return pages.stream().map((element) -> LegacyComponentSerializer.legacySection().serialize(element)).collect(ImmutableList.toImmutableList());
+    }
+
+    @Override
+    public void setPages(List<String> pages) {
+        List<Component> pagesInternal = this.getPageListOrCreate();
+        pagesInternal.clear();
+        if (pages.isEmpty()) {
+            this.clearPagesPropertyIfEmpty();
+            return;
+        }
+
+        for (String page : pages) {
+            this.addPage(page);
+        }
+    }
+
+    // Legacy Spigot IMPL
+    private final BookMeta.Spigot spigot = new SpigotMeta();
+
+    private class SpigotMeta extends BookMeta.Spigot {
+
+        private String pageToJSON(Component page) {
+            return GsonComponentSerializer.gson().serialize(page);
+        }
+
+        @Override
+        public BaseComponent[] getPage(final int page) {
+            return ComponentSerializer.parse(this.pageToJSON(MetaBook.this.page(page)));
+        }
+
+        @Override
+        public void setPage(final int page, final BaseComponent... text) {
+            BaseComponent[] newText = text == null ? new BaseComponent[0] : text;
+            MetaBook.this.page(page, GsonComponentSerializer.gson().deserialize(ComponentSerializer.toString(newText)));
+        }
+
+        @Override
+        public void setPages(final BaseComponent[]... pages) {
+            this.setPages(Arrays.asList(pages));
+        }
+
+        @Override
+        public void addPage(final BaseComponent[]... pages) {
+            for (BaseComponent[] page : pages) {
+                if (page == null) {
+                    page = new BaseComponent[0];
+                }
+
+                MetaBook.this.addPages(GsonComponentSerializer.gson().deserialize(ComponentSerializer.toString(page)));
+            }
+        }
+
+        @Override
+        public List<BaseComponent[]> getPages() {
+            List<Component> pagesInternal = MetaBook.this.getPageList();
+            if (pagesInternal.isEmpty()) {
+                return List.of();
+            }
+
+            return new AbstractList<BaseComponent[]>() {
+
+                @Override
+                public BaseComponent[] get(int index) {
+                    return ComponentSerializer.parse(MetaBook.SpigotMeta.this.pageToJSON(pagesInternal.get(index - 1)));
+                }
+
+                @Override
+                public int size() {
+                    return pagesInternal.size();
+                }
+            };
+        }
+
+        @Override
+        public void setPages(List<BaseComponent[]> pages) {
+            List<Component> pagesInternal = MetaBook.this.getPageListOrCreate();
+            pagesInternal.clear();
+            if (pages.isEmpty()) {
+                MetaBook.this.clearPagesPropertyIfEmpty();
+                return;
+            }
+
+            for (BaseComponent[] page : pages) {
+                this.addPage(page);
+            }
+        }
+    }
+
+    @Override
+    public BookMeta.Spigot spigot() {
+        return this.spigot;
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.TITLE);
+        mutable.unset(ItemProperties.TITLE_FILTERED);
+        mutable.unset(ItemProperties.AUTHOR);
+        mutable.unset(ItemProperties.PAGES);
+        mutable.unset(ItemProperties.PAGES_FILTERED);
+        mutable.unset(ItemProperties.GENERATION);
+        mutable.unset(ItemProperties.RESOLVED);
+    }
+
+    // Equality
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaBook that) {
+            return (this.hasTitle() ? that.hasTitle() && this.getTitle().equals(that.getTitle()) : !that.hasTitle())
+                && (this.hasAuthor() ? that.hasAuthor() && this.getAuthor().equals(that.getAuthor()) : !that.hasAuthor())
+                && (Objects.equals(this.getPages(), that.getPages()))
+                && (Objects.equals(this.propertyHolder.get(ItemProperties.RESOLVED), that.propertyHolder.get(ItemProperties.RESOLVED)))
+                && (this.hasGeneration() ? that.hasGeneration() && this.getGeneration().equals(that.getGeneration()) : !that.hasGeneration());
+        }
+        return true;
+    }
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaBook || this.isBookEmpty());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isBookEmpty();
+    }
+
+    boolean isBookEmpty() {
+        return !((!this.getPages().isEmpty()) || this.hasAuthor() || this.hasTitle() || this.hasGeneration() || (this.propertyHolder.get(ItemProperties.RESOLVED) != null));
+    }
+
+    // To override
+    @NotNull
+    public abstract List<Component> getPageListOrCreate();
+
+    @NotNull
+    public abstract List<Component> getPageList();
+
+    public abstract void clearPagesPropertyIfEmpty();
+
+    public abstract BookMeta build(Component title, Component author, List<net.kyori.adventure.text.Component> pages);
+
+    public abstract @NotNull MetaBook clone();
+
+    // Utilities
+    private boolean isValidPage(int page) {
+        return page > 0 && page <= this.getPageCount();
+    }
+
+    private static String limit(String str, int limit) {
+        if (str == null) {
+            return null;
+        }
+
+        return ValidateUtils.limit(str, limit);
+    }
+
+    String validatePage(String page) {
+        if (page == null) {
+            page = "";
+        } else if (page.length() > MAX_PAGE_LENGTH) {
+            page = page.substring(0, MAX_PAGE_LENGTH);
+        }
+        return page;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaBookSigned.java b/src/main/java/io/papermc/paper/item/meta/MetaBookSigned.java
new file mode 100644
index 0000000000000000000000000000000000000000..488d86a24046bdad9743ac9acc00afffea75fc77
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaBookSigned.java
@@ -0,0 +1,70 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.item.property.ItemPropertyRegistration;
+import io.papermc.paper.property.MutablePropertyView;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import net.kyori.adventure.text.Component;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.BookMeta;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaBookSigned extends MetaBook implements BookMeta {
+
+    public MetaBookSigned(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @NotNull
+    public List<Component> getPageListOrCreate() {
+        return this.propertyHolder.getOrCreate(ItemProperties.PAGES);
+    }
+
+    @NotNull
+    public List<Component> getPageList() {
+        return this.propertyHolder.getOrDefault(ItemProperties.PAGES, List.of());
+    }
+
+    @Override
+    public BookMeta build(Component title, Component author, List<Component> pages) {
+        MetaBook metaBook = new MetaBookSigned(NbtPropertyHolder.simpleBlob(new CompoundTag(), ItemPropertyRegistration.ITEM_CONTEXT));
+        metaBook.title(title);
+        metaBook.author(author);
+        metaBook.pages(pages);
+
+        return metaBook;
+    }
+
+    // Don't save pages if empty
+    public void clearPagesPropertyIfEmpty() {
+        if (this.getPageList().isEmpty()) {
+            this.propertyHolder.unset(ItemProperties.PAGES);
+        }
+    }
+
+    @Override
+    public @NotNull MetaBookSigned clone() {
+        return new MetaBookSigned(this.propertyHolder.clone());
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        return super.equalsCommon(meta);
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaBookSigned || isBookEmpty());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty();
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaBookWriteable.java b/src/main/java/io/papermc/paper/item/meta/MetaBookWriteable.java
new file mode 100644
index 0000000000000000000000000000000000000000..e7b0fca142169be0820e8877eba17105f60862ab
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaBookWriteable.java
@@ -0,0 +1,86 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.item.property.ItemPropertyRegistration;
+import io.papermc.paper.property.MutablePropertyView;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.util.TransformingRandomAccessList;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.BookMeta;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaBookWriteable extends MetaBook implements BookMeta {
+
+    public MetaBookWriteable(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @Override
+    public @NotNull MetaBookWriteable clone() {
+        return new MetaBookWriteable(this.propertyHolder.clone());
+    }
+
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        return super.equalsCommon(meta);
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaBookWriteable || isBookEmpty());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty();
+    }
+
+    @NotNull
+    public List<Component> getPageListOrCreate() {
+        return this.toComponentList(this.propertyHolder.getOrCreate(ItemProperties.PAGES_WRITTEN));
+    }
+
+    @NotNull
+    public List<Component> getPageList() {
+        List<String> writtenPages = this.propertyHolder.get(ItemProperties.PAGES_WRITTEN);
+        if (writtenPages == null) {
+            return List.of();
+        }
+
+        return this.toComponentList(writtenPages);
+    }
+
+    // Don't save pages if empty
+    public void clearPagesPropertyIfEmpty() {
+        if (this.getPageList().isEmpty()) {
+            this.propertyHolder.unset(ItemProperties.PAGES_WRITTEN);
+        }
+    }
+
+    @Override
+    public BookMeta build(Component title, Component author, List<Component> pages) {
+        MetaBook metaBook = new MetaBookWriteable(NbtPropertyHolder.simpleBlob(new CompoundTag(), ItemPropertyRegistration.ITEM_CONTEXT));
+        metaBook.title(title);
+        metaBook.author(author);
+        metaBook.pages(pages);
+
+        return metaBook;
+    }
+
+    // Convert pages supporting the legacy format
+    private List<Component> toComponentList(List<String> strings) {
+        return new TransformingRandomAccessList<>(strings,
+            s -> LegacyComponentSerializer.legacySection().deserialize(s),
+            c -> LegacyComponentSerializer.legacySection().serialize(c)
+        );
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaBundle.java b/src/main/java/io/papermc/paper/item/meta/MetaBundle.java
new file mode 100644
index 0000000000000000000000000000000000000000..3e75d9c9b7d22625efd3824c13fb985c96943305
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaBundle.java
@@ -0,0 +1,78 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.BundleMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collections;
+import java.util.List;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaBundle extends PaperMeta implements BundleMeta {
+
+    public MetaBundle(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @Override
+    public boolean hasItems() {
+        return !this.propertyHolder.getOrDefault(ItemProperties.ITEMS, List.of()).isEmpty();
+    }
+
+    @Override
+    public @NotNull List<ItemStack> getItems() {
+        return Collections.unmodifiableList(this.propertyHolder.getOrDefault(ItemProperties.ITEMS, List.of()));
+    }
+
+    @Override
+    public void setItems(@Nullable List<ItemStack> items) {
+        this.propertyHolder.set(ItemProperties.ITEMS, items);
+    }
+
+    @Override
+    public void addItem(@NotNull ItemStack item) {
+        List<ItemStack> items = this.propertyHolder.getOrCreate(ItemProperties.ITEMS);
+        items.add(item);
+    }
+
+    @Override
+    public @NotNull MetaBundle clone() {
+        return new MetaBundle(this.propertyHolder.clone());
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.ITEMS);
+    }
+
+    // Equality
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isBundleEmpty();
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaBundle that) {
+            return (this.hasItems() ? that.hasItems() && this.getItems().equals(that.getItems()) : !that.hasItems());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaBundle || this.isBundleEmpty());
+    }
+
+    boolean isBundleEmpty() {
+        return !(this.hasItems());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaColorableArmor.java b/src/main/java/io/papermc/paper/item/meta/MetaColorableArmor.java
new file mode 100644
index 0000000000000000000000000000000000000000..82dd60e6af417ffe6f5113001912a02c91a6bd82
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaColorableArmor.java
@@ -0,0 +1,71 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Color;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.ColorableArmorMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaColorableArmor extends MetaArmor implements ColorableArmorMeta {
+
+    // Use a leather armor meta for the color setting logic
+    private final MetaLeatherArmor leatherArmor;
+
+    public MetaColorableArmor(MutablePropertyView mutable) {
+        super(mutable);
+        this.leatherArmor = new MetaLeatherArmor(mutable);
+    }
+
+    @Override
+    public @NotNull Color getColor() {
+        return this.leatherArmor.getColor();
+    }
+
+    @Override
+    public void setColor(@Nullable Color color) {
+        this.leatherArmor.setColor(color);
+    }
+
+    @Override
+    public @NotNull MetaColorableArmor clone() {
+        return new MetaColorableArmor(this.propertyHolder.clone());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isLeatherArmorEmpty();
+    }
+
+    boolean isLeatherArmorEmpty() {
+        return !(this.hasColor());
+    }
+
+    boolean hasColor() {
+        return this.leatherArmor.hasColor();
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaColorableArmor || this.isLeatherArmorEmpty());
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaColorableArmor that) {
+            return this.getColor().equals(that.getColor());
+        }
+        return true;
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        super.migrateFrom(mutable);
+        this.leatherArmor.migrateFrom(mutable);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaCompass.java b/src/main/java/io/papermc/paper/item/meta/MetaCompass.java
new file mode 100644
index 0000000000000000000000000000000000000000..e0b727b8cb1a75aed95d87fb1928854d686245cf
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaCompass.java
@@ -0,0 +1,105 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.math.Position;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.NamespacedKey;
+import org.bukkit.World;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.CompassMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Objects;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaCompass extends PaperMeta implements CompassMeta {
+
+    public MetaCompass(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @Override
+    public boolean hasLodestone() {
+        return this.propertyHolder.hasProperty(ItemProperties.LODESTONE_DIMENSION);
+    }
+
+    @Override
+    public @Nullable Location getLodestone() {
+        NamespacedKey dimension = this.propertyHolder.get(ItemProperties.LODESTONE_DIMENSION);
+        if (dimension == null) {
+            return null;
+        }
+
+        World world = Bukkit.getWorld(dimension);
+        Position position = this.propertyHolder.get(ItemProperties.LODESTONE_POS);
+        if (position == null) {
+            return null;
+        }
+
+        return position.toLocation(world);
+    }
+
+    @Override
+    public void setLodestone(@Nullable Location lodestone) {
+        this.propertyHolder.set(ItemProperties.LODESTONE_POS, lodestone);
+        this.propertyHolder.set(ItemProperties.LODESTONE_DIMENSION, lodestone.getWorld().getKey());
+    }
+
+    @Override
+    public boolean isLodestoneTracked() {
+        return this.propertyHolder.getOrDefault(ItemProperties.LODESTONE_TRACKED, false);
+    }
+
+    @Override
+    public void setLodestoneTracked(boolean tracked) {
+        this.propertyHolder.set(ItemProperties.LODESTONE_TRACKED, tracked);
+    }
+
+    @Override
+    public @NotNull MetaCompass clone() {
+        return new MetaCompass(this.propertyHolder.clone());
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.LODESTONE_DIMENSION);
+        mutable.unset(ItemProperties.LODESTONE_POS);
+        mutable.unset(ItemProperties.LODESTONE_TRACKED);
+    }
+
+    // Equality
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaCompass that) {
+            return (this.hasLodestone() ? that.hasLodestone() && Objects.equals(this.propertyHolder.get(ItemProperties.LODESTONE_DIMENSION), that.propertyHolder.get(ItemProperties.LODESTONE_DIMENSION))
+                && this.getLodestone().equals(that.getLodestone()) : !that.hasLodestone())
+                && this.isLodestoneTracked() == that.isLodestoneTracked();
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaCompass || this.isCompassEmpty());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isCompassEmpty();
+    }
+
+    boolean isCompassEmpty() {
+        return !(this.hasLodestone() || this.hasLodestoneTracked());
+    }
+
+    boolean hasLodestoneTracked() {
+        return this.propertyHolder.hasProperty(ItemProperties.LODESTONE_TRACKED);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaCrossbow.java b/src/main/java/io/papermc/paper/item/meta/MetaCrossbow.java
new file mode 100644
index 0000000000000000000000000000000000000000..6b0f7f0c1b4410db260bee42f1273006aaa4917e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaCrossbow.java
@@ -0,0 +1,101 @@
+package io.papermc.paper.item.meta;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import net.minecraft.world.item.ArrowItem;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.CrossbowMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collections;
+import java.util.List;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaCrossbow extends PaperMeta implements CrossbowMeta {
+
+    public MetaCrossbow(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @Override
+    public boolean hasChargedProjectiles() {
+        return !this.propertyHolder.getOrDefault(ItemProperties.CHARGED_PROJECTILES, List.of()).isEmpty();
+    }
+
+    @Override
+    public @NotNull List<ItemStack> getChargedProjectiles() {
+        return Collections.unmodifiableList(this.propertyHolder.getOrDefault(ItemProperties.CHARGED_PROJECTILES, List.of()));
+    }
+
+    @Override
+    public void setChargedProjectiles(@Nullable List<ItemStack> projectiles) {
+        this.propertyHolder.unset(ItemProperties.CHARGED_PROJECTILES);
+        this.propertyHolder.set(ItemProperties.CHARGED, false);
+
+        if (projectiles == null) {
+            return;
+        }
+
+        for (ItemStack itemStack : projectiles) {
+            this.addChargedProjectile(itemStack);
+        }
+    }
+
+    @Override
+    public void addChargedProjectile(@NotNull ItemStack item) {
+        Preconditions.checkArgument(item != null, "item");
+        Preconditions.checkArgument(item.getType() == Material.FIREWORK_ROCKET || CraftMagicNumbers.getItem(item.getType()) instanceof ArrowItem, "Item %s is not an arrow or firework rocket", item);
+
+        this.propertyHolder.set(ItemProperties.CHARGED, true);
+        this.propertyHolder.getOrCreate(ItemProperties.CHARGED_PROJECTILES).add(item);
+    }
+
+    @Override
+    public @NotNull MetaCrossbow clone() {
+        return new MetaCrossbow(this.propertyHolder.clone());
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.CHARGED);
+        mutable.unset(ItemProperties.CHARGED_PROJECTILES);
+    }
+
+    // Equality
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isCrossbowEmpty();
+    }
+
+    boolean isCrossbowEmpty() {
+        return !(this.hasChargedProjectiles());
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaCrossbow that) {
+            return this.hasChargedProjectiles() == that.hasChargedProjectiles()
+                && (this.charged() ? that.charged() && this.getChargedProjectiles().equals(that.getChargedProjectiles()) : !that.hasChargedProjectiles());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaCrossbow || this.isCrossbowEmpty());
+    }
+
+    public boolean charged() {
+        return this.propertyHolder.getOrDefault(ItemProperties.CHARGED, false);
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaEnchantmentStorage.java b/src/main/java/io/papermc/paper/item/meta/MetaEnchantmentStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..878e3d3ca7123734f67713f23f26105be005681b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaEnchantmentStorage.java
@@ -0,0 +1,92 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.enchantments.Enchantment;
+import org.bukkit.inventory.meta.EnchantmentStorageMeta;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Map;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaEnchantmentStorage extends PaperMeta implements EnchantmentStorageMeta {
+
+    private final EnchantmentMap enchantmentMap;
+
+    public MetaEnchantmentStorage(MutablePropertyView mutable) {
+        super(mutable);
+        this.enchantmentMap = new EnchantmentMap(mutable, ItemProperties.STORED_ENCHANTMENTS);
+    }
+
+    @Override
+    public boolean hasStoredEnchant(Enchantment ench) {
+        return this.enchantmentMap.hasEnchant(ench);
+    }
+
+    @Override
+    public int getStoredEnchantLevel(Enchantment ench) {
+        return this.enchantmentMap.getEnchantLevel(ench);
+    }
+
+    @Override
+    public Map<Enchantment, Integer> getStoredEnchants() {
+        return this.enchantmentMap.getEnchants();
+    }
+
+    @Override
+    public boolean addStoredEnchant(Enchantment ench, int level, boolean ignoreRestrictions) {
+        return this.enchantmentMap.addEnchant(ench, level, ignoreRestrictions);
+    }
+
+    @Override
+    public boolean removeStoredEnchant(Enchantment ench) {
+        return this.enchantmentMap.removeEnchant(ench);
+    }
+
+    @Override
+    public boolean hasStoredEnchants() {
+        return this.enchantmentMap.hasEnchants();
+    }
+
+    @Override
+    public boolean hasConflictingStoredEnchant(Enchantment ench) {
+        return this.enchantmentMap.hasConflictingEnchant(ench);
+    }
+
+    @Override
+    public @NotNull MetaEnchantmentStorage clone() {
+        return new MetaEnchantmentStorage(this.propertyHolder.clone());
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.STORED_ENCHANTMENTS);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isEnchantedEmpty();
+    }
+
+    boolean isEnchantedEmpty() {
+        return !this.hasStoredEnchants();
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaEnchantmentStorage that) {
+            return (this.hasStoredEnchants() ? that.hasStoredEnchants() && this.getStoredEnchants().equals(that.getStoredEnchants()) : !that.hasStoredEnchants());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaEnchantmentStorage || this.isEnchantedEmpty());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaFirework.java b/src/main/java/io/papermc/paper/item/meta/MetaFirework.java
new file mode 100644
index 0000000000000000000000000000000000000000..87adc67bb81aca484a3df2a1f6c9f0df6fc63819
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaFirework.java
@@ -0,0 +1,130 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.apache.commons.lang.Validate;
+import org.bukkit.FireworkEffect;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.FireworkMeta;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collections;
+import java.util.List;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaFirework extends PaperMeta implements FireworkMeta {
+
+    public MetaFirework(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @Override
+    public boolean hasEffects() {
+        List<FireworkEffect> effects = this.getFromPropertyPathOrElse(ItemProperties.FIREWORKS, ItemProperties.EXPLOSIONS, List.of());
+        return !effects.isEmpty();
+    }
+
+    @Override
+    public void addEffect(FireworkEffect effect) {
+        this.addEffects(List.of(effect));
+    }
+
+    @Override
+    public void addEffects(FireworkEffect... effects) {
+        if (effects.length == 0) {
+            return;
+        }
+
+        this.addEffects(List.of(effects));
+    }
+
+    @Override
+    public void addEffects(Iterable<FireworkEffect> effects) {
+        List<FireworkEffect> explosions = this.getOrCreateFromPropertyPath(ItemProperties.FIREWORKS, ItemProperties.EXPLOSIONS);
+        for (FireworkEffect fireworkEffect : effects) {
+            explosions.add(fireworkEffect);
+        }
+    }
+
+    @Override
+    public List<FireworkEffect> getEffects() {
+        return Collections.unmodifiableList(this.getFromPropertyPathOrElse(ItemProperties.FIREWORKS, ItemProperties.EXPLOSIONS, List.of()));
+    }
+
+    @Override
+    public int getEffectsSize() {
+        List<FireworkEffect> effects = this.getFromPropertyPathOrElse(ItemProperties.FIREWORKS, ItemProperties.EXPLOSIONS, List.of());
+        return effects.size();
+    }
+
+    @Override
+    public void removeEffect(int index) {
+        List<FireworkEffect> effects = this.getFromPropertyPathOrElse(ItemProperties.FIREWORKS, ItemProperties.EXPLOSIONS, List.of());
+        if (effects.isEmpty()) {
+            throw new IndexOutOfBoundsException("Index: " + index + ", Size: 0");
+        } else {
+            effects.remove(index);
+        }
+    }
+
+    @Override
+    public void clearEffects() {
+        this.unsetInPropertyPath(ItemProperties.FIREWORKS, ItemProperties.EXPLOSIONS);
+    }
+
+    @Override
+    public int getPower() {
+        return this.getFromPropertyPathOrElse(ItemProperties.FIREWORKS, ItemProperties.FLIGHT, (byte) 0);
+    }
+
+    @Override
+    public void setPower(int power) {
+        Validate.isTrue(power >= 0, "Power cannot be less than zero: ", power);
+        Validate.isTrue(power < 0x80, "Power cannot be more than 127: ", power);
+        this.setFromPropertyPath(ItemProperties.FIREWORKS, ItemProperties.FLIGHT, (byte) power);
+    }
+
+    @Override
+    public @NotNull MetaFirework clone() {
+        return new MetaFirework(this.propertyHolder.clone());
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.FIREWORKS);
+    }
+
+    // Equality
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isFireworkEmpty();
+    }
+
+    boolean isFireworkEmpty() {
+        return !(this.hasEffects() || this.hasPower());
+    }
+
+    boolean hasPower() {
+        return this.getPower() != 0;
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+
+        if (meta instanceof MetaFirework that) {
+            return (this.hasPower() ? that.hasPower() && this.getPower() == that.getPower() : !that.hasPower())
+                && (this.hasEffects() ? that.hasEffects() && this.getEffects().equals(that.getEffects()) : !that.hasEffects());
+        }
+
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaFirework || this.isFireworkEmpty());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaFireworkEffect.java b/src/main/java/io/papermc/paper/item/meta/MetaFireworkEffect.java
new file mode 100644
index 0000000000000000000000000000000000000000..efa25d916b15e6e4341b494c8e5828d144fcf6dd
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaFireworkEffect.java
@@ -0,0 +1,71 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.FireworkEffect;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.FireworkEffectMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaFireworkEffect extends PaperMeta implements FireworkEffectMeta {
+
+    public MetaFireworkEffect(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @Override
+    public void setEffect(@Nullable FireworkEffect effect) {
+        this.propertyHolder.set(ItemProperties.EXPLOSION, effect);
+    }
+
+    @Override
+    public boolean hasEffect() {
+        return this.propertyHolder.hasProperty(ItemProperties.EXPLOSION);
+    }
+
+    @Override
+    public @Nullable FireworkEffect getEffect() {
+        return this.propertyHolder.get(ItemProperties.EXPLOSION);
+    }
+
+    @Override
+    public @NotNull MetaFireworkEffect clone() {
+        return new MetaFireworkEffect(this.propertyHolder.clone());
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.EXPLOSION);
+    }
+
+    // Equality
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && !this.hasChargeMeta();
+    }
+
+    boolean hasChargeMeta() {
+        return this.hasEffect();
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaFireworkEffect that) {
+            return (this.hasEffect() ? that.hasEffect() && this.getEffect().equals(that.getEffect()) : !that.hasEffect());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaFireworkEffect || !this.hasChargeMeta());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaKnowledgeBook.java b/src/main/java/io/papermc/paper/item/meta/MetaKnowledgeBook.java
new file mode 100644
index 0000000000000000000000000000000000000000..45e80e91890a010d23bbc3cfa64785d244c377af
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaKnowledgeBook.java
@@ -0,0 +1,86 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Material;
+import org.bukkit.NamespacedKey;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.KnowledgeBookMeta;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collections;
+import java.util.List;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaKnowledgeBook extends PaperMeta implements KnowledgeBookMeta {
+
+    static final int MAX_RECIPES = Short.MAX_VALUE;
+
+    public MetaKnowledgeBook(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @Override
+    public boolean hasRecipes() {
+       return !this.propertyHolder.getOrDefault(ItemProperties.RECIPES, List.of()).isEmpty();
+    }
+
+    @Override
+    public @NotNull List<NamespacedKey> getRecipes() {
+        return Collections.unmodifiableList(this.propertyHolder.getOrDefault(ItemProperties.RECIPES, List.of()));
+    }
+
+    @Override
+    public void setRecipes(@NotNull List<NamespacedKey> recipes) {
+        this.propertyHolder.set(ItemProperties.RECIPES, recipes);
+    }
+
+    @Override
+    public void addRecipe(@NotNull NamespacedKey... recipes) {
+        List<NamespacedKey> keys = this.propertyHolder.getOrCreate(ItemProperties.RECIPES);
+        for (NamespacedKey key : recipes) {
+            if (keys.size() > MAX_RECIPES) {
+                break;
+            }
+
+            keys.add(key);
+        }
+    }
+
+    @Override
+    public @NotNull MetaKnowledgeBook clone() {
+        return new MetaKnowledgeBook(this.propertyHolder.clone());
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.RECIPES);
+    }
+
+    // Equality
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isBookEmpty();
+    }
+
+    boolean isBookEmpty() {
+        return !(this.hasRecipes());
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaKnowledgeBook that) {
+            return (this.hasRecipes() ? that.hasRecipes() && this.getRecipes().equals(that.getRecipes()) : !that.hasRecipes());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaKnowledgeBook || this.isBookEmpty());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaLeatherArmor.java b/src/main/java/io/papermc/paper/item/meta/MetaLeatherArmor.java
new file mode 100644
index 0000000000000000000000000000000000000000..afde33f98908c91abf619e59204370408c4b4f3b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaLeatherArmor.java
@@ -0,0 +1,72 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Color;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.LeatherArmorMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaLeatherArmor extends PaperMeta implements LeatherArmorMeta {
+
+    private static final Color DEFAULT_LEATHER_COLOR = Color.fromRGB(0xA06540);
+
+    public MetaLeatherArmor(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @Override
+    public @NotNull Color getColor() {
+        return this.getFromPropertyPathOrElse(ItemProperties.DISPLAY, ItemProperties.COLOR, DEFAULT_LEATHER_COLOR);
+    }
+
+    @Override
+    public void setColor(@Nullable Color color) {
+        this.setFromPropertyPath(ItemProperties.DISPLAY, ItemProperties.COLOR, color);
+    }
+
+    @Override
+    public @NotNull MetaLeatherArmor clone() {
+        return new MetaLeatherArmor(this.propertyHolder.clone());
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.unsetInPropertyPath(mutable, ItemProperties.DISPLAY, ItemProperties.COLOR);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isLeatherArmorEmpty();
+    }
+
+    boolean isLeatherArmorEmpty() {
+        return !(this.hasColor());
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaLeatherArmor that) {
+            return this.getColor().equals(that.getColor());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaLeatherArmor || this.isLeatherArmorEmpty());
+    }
+
+    boolean hasColor() {
+        Color color = this.getColor();
+        // LEGACY
+        return !DEFAULT_LEATHER_COLOR.equals(color);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaMap.java b/src/main/java/io/papermc/paper/item/meta/MetaMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..11804b864d41578cf52484909756f9750c2114fa
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaMap.java
@@ -0,0 +1,141 @@
+package io.papermc.paper.item.meta;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Bukkit;
+import org.bukkit.Color;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.MapMeta;
+import org.bukkit.map.MapView;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaMap extends PaperMeta implements MapMeta {
+
+    public MetaMap(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @Override
+    public boolean hasMapId() {
+        return this.propertyHolder.hasProperty(ItemProperties.MAP_ID);
+    }
+
+    @Override
+    public int getMapId() {
+        Integer mapId = this.propertyHolder.get(ItemProperties.MAP_ID);
+        Preconditions.checkState(mapId != null, "Item does not have map associated - check hasMapView() first!");
+
+        return mapId.intValue();
+    }
+
+    @Override
+    public void setMapId(int id) {
+        this.propertyHolder.set(ItemProperties.MAP_ID, id);
+    }
+
+    @Override
+    public boolean hasMapView() {
+        return this.hasMapId();
+    }
+
+    @Override
+    public MapView getMapView() {
+        return Bukkit.getMap(this.getMapId());
+    }
+
+    @Override
+    public void setMapView(MapView map) {
+        this.propertyHolder.set(ItemProperties.MAP_ID, (map != null) ? map.getId() : null);
+    }
+
+    @Override
+    public boolean isScaling() {
+        return this.propertyHolder.getOrDefault(ItemProperties.MAP_SCALE_DIRECTION, (byte) 0) > 0;
+    }
+
+    @Override
+    public void setScaling(boolean value) {
+        this.propertyHolder.set(ItemProperties.MAP_SCALE_DIRECTION, (byte) (value ? 1 : 0));
+    }
+
+    boolean hasScaling() {
+        return this.isScaling();
+    }
+
+    // isn't wrapped in a display tag....
+    // Stupid legacy!
+    @Override
+    public boolean hasLocationName() {
+        return this.propertyHolder.hasProperty(PaperMeta.LOC_NAME);
+    }
+
+    @Override
+    public @Nullable String getLocationName() {
+        return this.propertyHolder.get(PaperMeta.LOC_NAME);
+    }
+
+    @Override
+    public void setLocationName(@Nullable String name) {
+        this.propertyHolder.set(PaperMeta.LOC_NAME, name);
+    }
+
+    @Override
+    public boolean hasColor() {
+        return this.hasInPropertyPath(ItemProperties.DISPLAY, ItemProperties.MAP_COLOR);
+    }
+
+    @Override
+    public @Nullable Color getColor() {
+        return this.getFromPropertyPath(ItemProperties.DISPLAY, ItemProperties.MAP_COLOR);
+    }
+
+    @Override
+    public void setColor(@Nullable Color color) {
+        this.setFromPropertyPath(ItemProperties.DISPLAY, ItemProperties.MAP_COLOR, color);
+    }
+
+    @Override
+    public @NotNull MetaMap clone() {
+        return new MetaMap(this.propertyHolder.clone());
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.MAP_ID);
+        this.unsetInPropertyPath(mutable, ItemProperties.DISPLAY, ItemProperties.MAP_COLOR);
+        mutable.unset(ItemProperties.MAP_SCALE_DIRECTION);
+    }
+
+    // equality
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isMapEmpty();
+    }
+
+    boolean isMapEmpty() {
+        return !(this.hasMapId() || this.hasScaling() | this.hasLocationName() || this.hasColor());
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaMap that) {
+            return (this.isScaling() == that.isScaling())
+                && (this.hasMapId() ? that.hasMapId() && this.getMapId() == that.getMapId() : !that.hasMapId())
+                && (this.hasLocationName() ? that.hasLocationName() && this.getLocationName().equals(that.getLocationName()) : !that.hasLocationName())
+                && (this.hasColor() ? that.hasColor() && this.getColor().equals(that.getColor()) : !that.hasColor());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaMap || this.isMapEmpty());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaMusicInstrument.java b/src/main/java/io/papermc/paper/item/meta/MetaMusicInstrument.java
new file mode 100644
index 0000000000000000000000000000000000000000..964e9b9cd749ed63b7ef4e4cae0940aaac56393b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaMusicInstrument.java
@@ -0,0 +1,65 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Material;
+import org.bukkit.MusicInstrument;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.MusicInstrumentMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaMusicInstrument extends PaperMeta implements MusicInstrumentMeta {
+
+    public MetaMusicInstrument(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @Override
+    public void setInstrument(@Nullable MusicInstrument instrument) {
+        this.propertyHolder.set(ItemProperties.INSTRUMENT, instrument);
+    }
+
+    @Override
+    public @Nullable MusicInstrument getInstrument() {
+        return this.propertyHolder.get(ItemProperties.INSTRUMENT);
+    }
+
+    @Override
+    public @NotNull MetaMusicInstrument clone() {
+        return new MetaMusicInstrument(this.propertyHolder.clone());
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.INSTRUMENT);
+    }
+
+    // Equality
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaMusicInstrument that) {
+            return this.getInstrument() == that.getInstrument();
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaMusicInstrument || this.isInstrumentEmpty());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isInstrumentEmpty();
+    }
+
+    boolean isInstrumentEmpty() {
+        return this.getInstrument() == null;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaPlayerHead.java b/src/main/java/io/papermc/paper/item/meta/MetaPlayerHead.java
new file mode 100644
index 0000000000000000000000000000000000000000..75a7096950ccd4860ecc3b421dd021a8536d52fd
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaPlayerHead.java
@@ -0,0 +1,191 @@
+package io.papermc.paper.item.meta;
+
+import com.destroystokyo.paper.profile.CraftPlayerProfile;
+import com.destroystokyo.paper.profile.PlayerProfile;
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Bukkit;
+import org.bukkit.NamespacedKey;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.meta.SkullMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Objects;
+
+// Ignores the STRING "SkullOwner" property, as that is temporary
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaPlayerHead extends PaperMeta implements SkullMeta {
+
+    static final int MAX_OWNER_LENGTH = 16;
+
+    public MetaPlayerHead(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @Override
+    public boolean hasOwner() {
+        PlayerProfile profile = this.propertyHolder.get(ItemProperties.SKULL_OWNER);
+        String name = this.propertyHolder.get(ItemProperties.SKULL_OWNER_NAME);
+
+        return profile != null || name != null;
+    }
+
+    @Override
+    public String getOwner() {
+        PlayerProfile profile = this.propertyHolder.get(ItemProperties.SKULL_OWNER);
+        String name = this.propertyHolder.get(ItemProperties.SKULL_OWNER_NAME);
+        if (profile != null && profile.getName() != null) {
+            return profile.getName();
+        }
+
+        return name;
+    }
+
+    // Paper start
+    @Override
+    public void setPlayerProfile(@org.jetbrains.annotations.Nullable com.destroystokyo.paper.profile.PlayerProfile profile) {
+        this.propertyHolder.set(ItemProperties.SKULL_OWNER, profile);
+    }
+
+    @org.jetbrains.annotations.Nullable
+    @Override
+    public com.destroystokyo.paper.profile.PlayerProfile getPlayerProfile() {
+        return this.propertyHolder.get(ItemProperties.SKULL_OWNER);
+    }
+    // Paper end
+
+    @Override
+    public OfflinePlayer getOwningPlayer() {
+        if (this.hasOwner()) {
+            PlayerProfile profile = this.propertyHolder.get(ItemProperties.SKULL_OWNER);
+            String name = this.propertyHolder.get(ItemProperties.SKULL_OWNER_NAME);
+            if (name != null) {
+                return Bukkit.getOfflinePlayer(name);
+            }
+
+            if (profile.getId() != null) {
+                return Bukkit.getOfflinePlayer(profile.getId());
+            }
+
+            if (profile.getName() != null) {
+                return Bukkit.getOfflinePlayer(profile.getName());
+            }
+        }
+
+        return null;
+    }
+
+    @Override
+    public boolean setOwner(String name) {
+        if (name != null && name.length() > MAX_OWNER_LENGTH) {
+            return false;
+        }
+
+        if (name == null) {
+            this.setProfile(null);
+        } else {
+            this.setProfile(Bukkit.createProfile(name));
+        }
+
+        return true;
+    }
+
+    @Override
+    public boolean setOwningPlayer(OfflinePlayer owner) {
+        if (owner == null) {
+            this.setProfile(null);
+        } else if (owner instanceof Player player) {
+            this.setProfile(player.getPlayerProfile());
+        } else {
+            this.setProfile(Bukkit.createProfile(owner.getUniqueId(), owner.getName()));
+        }
+
+        return true;
+    }
+
+    @Override
+    @Deprecated // Paper
+    public org.bukkit.profile.PlayerProfile getOwnerProfile() {
+        if (!this.hasOwner()) {
+            return null;
+        }
+
+        return this.propertyHolder.get(ItemProperties.SKULL_OWNER);
+    }
+
+    @Override
+    @Deprecated // Paper
+    public void setOwnerProfile(org.bukkit.profile.PlayerProfile profile) {
+        this.setProfile(profile);
+    }
+
+    @Override
+    public void setNoteBlockSound(@Nullable NamespacedKey noteBlockSound) {
+        this.setFromPropertyPath(ItemProperties.BLOCK_ENTITY_TAG, ItemProperties.NOTE_BLOCK_SOUND, noteBlockSound);
+    }
+
+    @Override
+    public @Nullable NamespacedKey getNoteBlockSound() {
+        return this.getFromPropertyPath(ItemProperties.BLOCK_ENTITY_TAG, ItemProperties.NOTE_BLOCK_SOUND);
+    }
+
+    @Override
+    public @NotNull MetaPlayerHead clone() {
+        return new MetaPlayerHead(this.propertyHolder.clone());
+    }
+
+    private void setProfile(org.bukkit.profile.PlayerProfile gameProfile) {
+        if (gameProfile == null) {
+            this.propertyHolder.set(ItemProperties.SKULL_OWNER, null);
+            return;
+        }
+
+        PlayerProfile paperProfile;
+        if (gameProfile instanceof PlayerProfile paper) {
+            paperProfile = paper;
+        } else {
+            paperProfile = new CraftPlayerProfile(((org.bukkit.craftbukkit.profile.CraftPlayerProfile) gameProfile).buildGameProfile());
+        }
+
+        // Convert bukkit -> paper
+        this.propertyHolder.set(ItemProperties.SKULL_OWNER, paperProfile);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.SKULL_OWNER);
+        mutable.unset(ItemProperties.SKULL_OWNER_NAME);
+        mutable.unset(ItemProperties.BLOCK_ENTITY_TAG);
+    }
+
+    // Equality
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaPlayerHead that) {
+            // SPIGOT-5403: equals does not check properties
+            return (this.getPlayerProfile() != null ? that.getPlayerProfile() != null && this.getPlayerProfile().equals(that.getPlayerProfile()) : that.getPlayerProfile() == null) && Objects.equals(this.getNoteBlockSound(), that.getNoteBlockSound());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaPlayerHead || this.isSkullEmpty());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isSkullEmpty();
+    }
+
+    boolean isSkullEmpty() {
+        return this.getPlayerProfile() == null && this.getNoteBlockSound() == null;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaPotion.java b/src/main/java/io/papermc/paper/item/meta/MetaPotion.java
new file mode 100644
index 0000000000000000000000000000000000000000..c7ffa1b4ab31c77bcec3d0c30bbb863a0f2dde7f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaPotion.java
@@ -0,0 +1,184 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Color;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.PotionMeta;
+import org.bukkit.potion.PotionData;
+import org.bukkit.potion.PotionEffect;
+import org.bukkit.potion.PotionEffectType;
+import org.bukkit.potion.PotionType;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaPotion extends PaperMeta implements PotionMeta {
+
+    private static final PotionData DEFAULT_TYPE = new PotionData(PotionType.UNCRAFTABLE, false, false);
+
+    public MetaPotion(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @Override
+    public void setBasePotionData(@NotNull PotionData data) {
+        this.propertyHolder.set(ItemProperties.DEFAULT_POTION_TYPE, data);
+    }
+
+    @Override
+    public @NotNull PotionData getBasePotionData() {
+        return this.propertyHolder.getOrDefault(ItemProperties.DEFAULT_POTION_TYPE, DEFAULT_TYPE);
+    }
+
+    @Override
+    public boolean hasCustomEffects() {
+        return !this.propertyHolder.getOrDefault(ItemProperties.CUSTOM_POTION_EFFECTS, List.of()).isEmpty();
+    }
+
+    @Override
+    public @NotNull List<PotionEffect> getCustomEffects() {
+        return Collections.unmodifiableList(this.propertyHolder.getOrDefault(ItemProperties.CUSTOM_POTION_EFFECTS, List.of()));
+    }
+
+    @Override
+    public boolean addCustomEffect(@NotNull PotionEffect effect, boolean overwrite) {
+        List<PotionEffect> effects = this.propertyHolder.getOrCreate(ItemProperties.CUSTOM_POTION_EFFECTS);
+        int i = 0;
+        for (PotionEffect old : effects) {
+            if (old.getType() == effect.getType()) {
+                if (!overwrite) {
+                    return false;
+                } else if (old.getAmplifier() == effect.getAmplifier() && old.getDuration() == effect.getDuration() && old.isAmbient() == effect.isAmbient()) {
+                    return false;
+                }
+
+                break;
+            }
+            i++;
+        }
+
+        effects.add(i, effect);
+        return true;
+    }
+
+    @Override
+    public boolean removeCustomEffect(@NotNull PotionEffectType type) {
+        List<PotionEffect> effects = this.propertyHolder.getOrCreate(ItemProperties.CUSTOM_POTION_EFFECTS);
+
+        boolean changed = false;
+        Iterator<PotionEffect> iterator = effects.iterator();
+        while (iterator.hasNext()) {
+            PotionEffect next = iterator.next();
+            if (next.getType() == type) {
+                iterator.remove();
+                changed = true;
+            }
+        }
+
+        return changed;
+    }
+
+    @Override
+    public boolean hasCustomEffect(@NotNull PotionEffectType type) {
+        List<PotionEffect> effects = this.propertyHolder.getOrDefault(ItemProperties.CUSTOM_POTION_EFFECTS, List.of());
+        for (PotionEffect old : effects) {
+            if (old.getType() == type) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean clearCustomEffects() {
+        boolean changed = this.hasCustomEffects();
+        this.propertyHolder.unset(ItemProperties.CUSTOM_POTION_EFFECTS);
+        return changed;
+    }
+
+    @Override
+    public boolean setMainEffect(@NotNull PotionEffectType type) {
+        List<PotionEffect> effects = this.propertyHolder.getOrCreate(ItemProperties.CUSTOM_POTION_EFFECTS);
+        PotionEffect found = null;
+        int i = 0;
+        for (PotionEffect old : effects) {
+            if (old.getType() == type) {
+                found = old;
+                break;
+            }
+            i++;
+        }
+
+        if (i == 0 || found == null) {
+            return false;
+        }
+
+        PotionEffect old = effects.get(0);
+        effects.set(0, found);
+        effects.set(i, old);
+
+        return true;
+    }
+
+    @Override
+    public boolean hasColor() {
+        return this.propertyHolder.hasProperty(ItemProperties.CUSTOM_POTION_COLOR);
+    }
+
+    @Override
+    public @Nullable Color getColor() {
+        return this.propertyHolder.get(ItemProperties.CUSTOM_POTION_COLOR);
+    }
+
+    @Override
+    public void setColor(@Nullable Color color) {
+        this.propertyHolder.set(ItemProperties.CUSTOM_POTION_COLOR, color);
+    }
+
+    @Override
+    public @NotNull MetaPotion clone() {
+        return new MetaPotion(this.propertyHolder.clone());
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.CUSTOM_POTION_COLOR);
+        mutable.unset(ItemProperties.DEFAULT_POTION_TYPE);
+        mutable.unset(ItemProperties.CUSTOM_POTION_EFFECTS);
+    }
+
+    // Equality
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaPotion that) {
+            return this.getBasePotionData().equals(that.getBasePotionData())
+                && (this.hasCustomEffects() ? that.hasCustomEffects() && this.getCustomEffects().equals(that.getCustomEffects()) : !that.hasCustomEffects())
+                && (this.hasColor() ? that.hasColor() && this.getColor().equals(that.getColor()) : !that.hasColor());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaPotion || this.isPotionEmpty());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isPotionEmpty();
+    }
+
+    boolean isPotionEmpty() {
+        return (this.getBasePotionData().getType() == PotionType.UNCRAFTABLE) && !(this.hasCustomEffects() || this.hasColor());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaShield.java b/src/main/java/io/papermc/paper/item/meta/MetaShield.java
new file mode 100644
index 0000000000000000000000000000000000000000..f967680c1bacc273b310953e1e8e57faef527516
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaShield.java
@@ -0,0 +1,113 @@
+package io.papermc.paper.item.meta;
+
+import com.google.common.base.Objects;
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import io.papermc.paper.property.nbt.AdapterContext;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import org.apache.commons.lang.Validate;
+import org.bukkit.DyeColor;
+import org.bukkit.Material;
+import org.bukkit.block.BlockState;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.block.CraftBanner;
+import org.bukkit.craftbukkit.block.CraftBlockEntityState;
+import org.bukkit.craftbukkit.block.CraftBlockStates;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.BlockStateMeta;
+import org.jetbrains.annotations.NotNull;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaShield extends PaperMeta implements BlockStateMeta {
+
+    public MetaShield(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @Override
+    public boolean hasBlockState() {
+        return this.propertyHolder.hasProperty(ItemProperties.BLOCK_ENTITY_TAG);
+    }
+
+    @Override
+    public BlockState getBlockState() {
+        MutablePropertyView holder = this.propertyHolder.get(ItemProperties.BLOCK_ENTITY_TAG);
+        DyeColor colorValue = holder == null ? null : holder.get(ItemProperties.SHIELD_BANNER_BASE);
+        // Convert the base to be used in the banner material type
+        Material stateMaterial = convertBaseToBanner(colorValue);
+
+        return CraftBlockStates.getBlockState(stateMaterial, ((NbtPropertyHolder) holder).getCompoundTag());
+    }
+
+    @Override
+    public void setBlockState(BlockState blockState) {
+        MutablePropertyView holder = this.propertyHolder.get(ItemProperties.BLOCK_ENTITY_TAG);
+        DyeColor colorValue = holder == null ? null : holder.get(ItemProperties.SHIELD_BANNER_BASE);
+        Material stateMaterial = convertBaseToBanner(colorValue);
+        Class<?> blockStateType = CraftBlockStates.getBlockStateType(stateMaterial);
+
+        Validate.isTrue(blockStateType == blockState.getClass() && blockState instanceof CraftBlockEntityState, "Invalid blockState for banner");
+
+        MutablePropertyView mutable = NbtPropertyHolder.simpleBlob(((CraftBlockEntityState) blockState).getSnapshotNBT(), AdapterContext.empty());
+        // Set the base banner property of the banner
+        mutable.set(ItemProperties.SHIELD_BANNER_BASE, ((CraftBanner) blockState).getBaseColor());
+        this.propertyHolder.set(ItemProperties.BLOCK_ENTITY_TAG, mutable);
+    }
+
+    private static Material convertBaseToBanner(DyeColor dyeColor) {
+        if (dyeColor == null) {
+            return Material.WHITE_BANNER;
+        }
+
+        return switch (dyeColor) {
+            case WHITE -> Material.WHITE_BANNER;
+            case ORANGE -> Material.ORANGE_BANNER;
+            case MAGENTA -> Material.MAGENTA_BANNER;
+            case LIGHT_BLUE -> Material.LIGHT_BLUE_BANNER;
+            case YELLOW -> Material.YELLOW_BANNER;
+            case LIME -> Material.LIME_BANNER;
+            case PINK -> Material.PINK_BANNER;
+            case GRAY -> Material.GRAY_BANNER;
+            case LIGHT_GRAY -> Material.LIGHT_GRAY_BANNER;
+            case CYAN -> Material.CYAN_BANNER;
+            case PURPLE -> Material.PURPLE_BANNER;
+            case BLUE -> Material.BLUE_BANNER;
+            case BROWN -> Material.BROWN_BANNER;
+            case GREEN -> Material.GREEN_BANNER;
+            case RED -> Material.RED_BANNER;
+            case BLACK -> Material.BLACK_BANNER;
+        };
+    }
+
+    @Override
+    public @NotNull MetaShield clone() {
+        return new MetaShield(this.propertyHolder.clone());
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.BLOCK_ENTITY_TAG);
+    }
+
+    // Equality
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaShield that) {
+            return Objects.equal(this.propertyHolder.get(ItemProperties.BLOCK_ENTITY_TAG), that.propertyHolder.get(ItemProperties.BLOCK_ENTITY_TAG));
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaShield || this.propertyHolder.get(ItemProperties.BLOCK_ENTITY_TAG) == null);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.propertyHolder.get(ItemProperties.BLOCK_ENTITY_TAG) == null;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaSpawnEgg.java b/src/main/java/io/papermc/paper/item/meta/MetaSpawnEgg.java
new file mode 100644
index 0000000000000000000000000000000000000000..5055b707b7416732b63b781066db97d39baab0c5
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaSpawnEgg.java
@@ -0,0 +1,82 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.entity.EntityType;
+import org.bukkit.inventory.meta.SpawnEggMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaSpawnEgg extends PaperMeta implements SpawnEggMeta {
+
+    public MetaSpawnEgg(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @Override
+    public EntityType getSpawnedType() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setSpawnedType(EntityType type) {
+        throw new UnsupportedOperationException();
+    }
+
+    // TODO:
+    @Override
+    public @Nullable EntityType getCustomSpawnedType() {
+        return null;
+    }
+
+    @Override
+    public void setCustomSpawnedType(@Nullable EntityType type) {
+
+    }
+
+    @Override
+    public @NotNull MetaSpawnEgg clone() {
+        return new MetaSpawnEgg(this.propertyHolder.clone());
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.ENTITY_TAG);
+    }
+
+    // Equality
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isSpawnEggEmpty();
+    }
+
+    boolean isSpawnEggEmpty() {
+        return !(this.hasSpawnedType() || this.propertyHolder.get(ItemProperties.ENTITY_TAG) != null);
+    }
+
+    boolean hasSpawnedType() {
+        return false;
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaSpawnEgg that) {
+
+            return this.hasSpawnedType() ? that.hasSpawnedType() : !that.hasSpawnedType()
+                && this.propertyHolder.get(ItemProperties.ENTITY_TAG) != null ? that.propertyHolder.get(ItemProperties.ENTITY_TAG) != null && this.propertyHolder.get(ItemProperties.ENTITY_TAG).equals(that.propertyHolder.get(ItemProperties.ENTITY_TAG)) : this.propertyHolder.get(ItemProperties.ENTITY_TAG) == null;
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaSpawnEgg || this.isSpawnEggEmpty());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaSuspiciousStew.java b/src/main/java/io/papermc/paper/item/meta/MetaSuspiciousStew.java
new file mode 100644
index 0000000000000000000000000000000000000000..def1ad06a79b95f959099b6ce15d8d0cd99b07cc
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaSuspiciousStew.java
@@ -0,0 +1,139 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.inventory.item.properties.StewEffect;
+import io.papermc.paper.property.MutablePropertyView;
+import io.papermc.paper.property.nbt.types.StewEffectsListNbt;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.SuspiciousStewMeta;
+import org.bukkit.potion.PotionEffect;
+import org.bukkit.potion.PotionEffectType;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaSuspiciousStew extends PaperMeta implements SuspiciousStewMeta {
+
+    public MetaSuspiciousStew(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @Override
+    public boolean hasCustomEffects() {
+        return !this.propertyHolder.getOrDefault(ItemProperties.STEW_EFFECTS, List.of()).isEmpty();
+    }
+
+    @Override
+    public @NotNull List<PotionEffect> getCustomEffects() {
+        List<PotionEffect> effects = new ArrayList<>();
+        for (StewEffect effect : this.propertyHolder.getOrDefault(ItemProperties.STEW_EFFECTS, List.of())) {
+            effects.add(new PotionEffect(effect.effect(), effect.duration(), 0));
+        }
+
+        return effects;
+    }
+
+    @Override
+    public boolean addCustomEffect(@NotNull PotionEffect effect, boolean overwrite) {
+        List<StewEffect> effects = this.propertyHolder.getOrCreate(ItemProperties.STEW_EFFECTS);
+        int i = 0;
+        for (StewEffect old : effects) {
+            if (old.effect() == effect.getType()) {
+                if (!overwrite) {
+                    return false;
+                }
+                if (old.duration() == effect.getDuration()) {
+                    return false;
+                }
+
+                effects.set(i, new StewEffectsListNbt.StewEffectImpl(effect.getType(), effect.getDuration()));
+                return true;
+            }
+            i++;
+        }
+        // Just add it
+        effects.add(new StewEffectsListNbt.StewEffectImpl(effect.getType(), effect.getDuration()));
+
+        return true;
+    }
+
+    @Override
+    public boolean removeCustomEffect(@NotNull PotionEffectType type) {
+        List<StewEffect> effects = this.propertyHolder.get(ItemProperties.STEW_EFFECTS);
+        if (effects == null) {
+            return false;
+        }
+
+        boolean changed = false;
+        Iterator<StewEffect> iterator = effects.iterator();
+        while (iterator.hasNext()) {
+            StewEffect next = iterator.next();
+            if (next.effect() == type) {
+                iterator.remove();
+                changed = true;
+            }
+        }
+
+        return changed;
+    }
+
+    @Override
+    public boolean hasCustomEffect(@NotNull PotionEffectType type) {
+        List<StewEffect> effects = this.propertyHolder.getOrDefault(ItemProperties.STEW_EFFECTS, List.of());
+        for (StewEffect old : effects) {
+            if (old.effect() == type) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean clearCustomEffects() {
+        boolean changed = this.hasCustomEffects();
+        this.propertyHolder.get(ItemProperties.STEW_EFFECTS).isEmpty();
+        return changed;
+    }
+
+    @Override
+    public @NotNull MetaSuspiciousStew clone() {
+        return new MetaSuspiciousStew(this.propertyHolder.clone());
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.STEW_EFFECTS);
+    }
+
+    // Equality
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isStewEmpty();
+    }
+
+    boolean isStewEmpty() {
+        return !this.hasCustomEffects();
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaSuspiciousStew that) {
+            return (this.hasCustomEffects() ? that.hasCustomEffects() && this.getCustomEffects().equals(that.getCustomEffects()) : !that.hasCustomEffects());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaSuspiciousStew || this.isStewEmpty());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaTropicalFishBucket.java b/src/main/java/io/papermc/paper/item/meta/MetaTropicalFishBucket.java
new file mode 100644
index 0000000000000000000000000000000000000000..c06dc874c9a76b2f164256e27826d7a691b118ae
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaTropicalFishBucket.java
@@ -0,0 +1,104 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.inventory.item.properties.TropicalFishVariant;
+import io.papermc.paper.property.MutablePropertyView;
+import io.papermc.paper.property.nbt.types.TropicalFishVariantNbt;
+import org.bukkit.DyeColor;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.entity.TropicalFish;
+import org.bukkit.inventory.meta.TropicalFishBucketMeta;
+import org.jetbrains.annotations.NotNull;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaTropicalFishBucket extends PaperMeta implements TropicalFishBucketMeta {
+
+    private static final TropicalFishVariant DEFAULT = new TropicalFishVariantNbt.TropicalFishVariantImpl(DyeColor.WHITE, DyeColor.WHITE, TropicalFish.Pattern.KOB);
+
+    public MetaTropicalFishBucket(MutablePropertyView mutable) {
+        super(mutable);
+    }
+
+    @Override
+    public @NotNull DyeColor getPatternColor() {
+        return this.propertyHolder.getOrDefault(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, DEFAULT).patternColor();
+    }
+
+    @Override
+    public void setPatternColor(@NotNull DyeColor color) {
+        TropicalFishVariant variant = this.propertyHolder.getOrDefault(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, DEFAULT);
+        this.set(new TropicalFishVariantNbt.TropicalFishVariantImpl(color, variant.bodyColor(), variant.type()));
+    }
+
+    @Override
+    public @NotNull DyeColor getBodyColor() {
+        TropicalFishVariant variant = this.propertyHolder.getOrDefault(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, DEFAULT);
+        return variant.bodyColor();
+    }
+
+    @Override
+    public void setBodyColor(@NotNull DyeColor color) {
+        TropicalFishVariant variant = this.propertyHolder.getOrDefault(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, DEFAULT);
+        this.set(new TropicalFishVariantNbt.TropicalFishVariantImpl(variant.patternColor(), color, variant.type()));
+    }
+
+    @Override
+    public @NotNull TropicalFish.Pattern getPattern() {
+        TropicalFishVariant variant = this.propertyHolder.getOrDefault(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, DEFAULT);
+        return variant.type();
+    }
+
+    @Override
+    public void setPattern(TropicalFish.@NotNull Pattern pattern) {
+        TropicalFishVariant variant = this.propertyHolder.getOrDefault(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, DEFAULT);
+        this.set(new TropicalFishVariantNbt.TropicalFishVariantImpl(variant.patternColor(), variant.bodyColor(), pattern));
+    }
+
+    @Override
+    public boolean hasVariant() {
+        return this.propertyHolder.hasProperty(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT);
+    }
+
+    private void set(TropicalFishVariant variant) {
+        this.propertyHolder.set(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, variant);
+    }
+
+    @Override
+    public @NotNull MetaTropicalFishBucket clone() {
+        return new MetaTropicalFishBucket(this.propertyHolder.clone());
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        mutable.unset(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT);
+        mutable.unset(ItemProperties.ENTITY_TAG);
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaTropicalFishBucket that) {
+            return (this.hasVariant() ? that.hasVariant() && this.propertyHolder.get(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT).equals(that.propertyHolder.get(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT)) : !that.hasVariant())
+                && (this.propertyHolder.get(ItemProperties.ENTITY_TAG) != null ? that.propertyHolder.get(ItemProperties.ENTITY_TAG) != null && this.propertyHolder.get(ItemProperties.ENTITY_TAG).equals(that.propertyHolder.get(ItemProperties.ENTITY_TAG)) : that.propertyHolder.get(ItemProperties.ENTITY_TAG) == null);
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaTropicalFishBucket || this.isBucketEmpty());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isBucketEmpty();
+    }
+
+    boolean isBucketEmpty() {
+        return !(this.hasVariant() || this.propertyHolder.get(ItemProperties.ENTITY_TAG) != null);
+    }
+}
