From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Bjarne Koll <lynxplay101@gmail.com>
Date: Fri, 27 Jan 2023 18:39:19 +0100
Subject: [PATCH] Paper plugin api docs improvements


diff --git a/src/main/java/io/papermc/paper/plugin/PermissionManager.java b/src/main/java/io/papermc/paper/plugin/PermissionManager.java
index ddfe0db2afb380643db92c9700f253e551a0cdbb..cdbc93b317b3bab47bf6552c29cfbb2c27846933 100644
--- a/src/main/java/io/papermc/paper/plugin/PermissionManager.java
+++ b/src/main/java/io/papermc/paper/plugin/PermissionManager.java
@@ -10,7 +10,8 @@ import java.util.List;
 import java.util.Set;
 
 /**
- * Allows plugins to override permission logic.
+ * A permission manager implementation to keep backwards compatibility partially alive with existing plugins that used
+ * the bukkit one before.
  */
 @ApiStatus.Experimental
 public interface PermissionManager {
diff --git a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrap.java b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrap.java
index 52785ef4958738bca5d3d8af3e0ba543f325e252..ea84b11e8682e73fcd563fec65e76b707546a99e 100644
--- a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrap.java
+++ b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrap.java
@@ -20,17 +20,19 @@ import org.jetbrains.annotations.NotNull;
 public interface PluginBootstrap {
 
     /**
-     * Called by the server, allowing you to bootstrap with context that provides things like a logger and your shared plugin configuration file.
+     * Called by the server, allowing you to bootstrap the plugin with a context that provides things like a logger and your shared plugin configuration file.
      *
-     * @param context server provided context
+     * @param context the server provided context
      */
     void bootstrap(@NotNull PluginProviderContext context);
 
     /**
-     * Called by the server, allows you to create your own java plugin instance inorder to do things such as
-     * pass objects through the constructor.
-     * @param context server created bootstrap object
-     * @return java plugin instance
+     * Called by the server to instantiate your main class.
+     * Plugins may override this logic to define custom creation logic for said instance, like passing addition
+     * constructor arguments.
+     *
+     * @param context the server created bootstrap object
+     * @return the server requested instance of the plugins main class.
      */
     @NotNull
     default JavaPlugin createPlugin(@NotNull PluginProviderContext context) {
diff --git a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginProviderContext.java b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginProviderContext.java
index 5be4c1d7117e5b5805a16666961696f1385093d7..a4467fe1ba0dc348eab681900dbcac1770963591 100644
--- a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginProviderContext.java
+++ b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginProviderContext.java
@@ -8,37 +8,42 @@ import java.nio.file.Path;
 import java.util.logging.Logger;
 
 /**
- * Contains context used for when a plugin's bootstrap class is executed.
+ * Represents the context provided to a {@link PluginBootstrap} during both the bootstrapping and plugin
+ * instanciation logic.
+ * A boostrap context may be used to access data or logic usually provided to {@link org.bukkit.plugin.Plugin} instances
+ * like the plugin's configuration or logger during the plugins bootstrap.
  */
 @ApiStatus.NonExtendable
 @ApiStatus.Experimental
 public interface PluginProviderContext {
 
     /**
-     * Gets the plugin's configuration.
-     * @return configuration
+     * Provides the plugin's configuration.
+     *
+     * @return the plugin's configuration
      */
     @NotNull
     PluginMeta getConfiguration();
 
     /**
-     * Gets the path to the data directory for the plugin.
+     * Provides the path to the data directory of the plugin.
      *
-     * @return plugin
+     * @return the previously described path
      */
     @NotNull
     Path getDataDirectory();
 
     /**
-     * Gets the logger used for this plugin.
+     * Provides the logger used for this plugin.
      *
-     * @return logger
+     * @return the logger instance
      */
     @NotNull
     Logger getLogger();
 
     /**
-     * Gets the SLF4J logger used for this plugin provider.
+     * Provides the SLF4J logger assigned to this plugin.
+     *
      * @return SLF4J logger
      */
     @NotNull
diff --git a/src/main/java/io/papermc/paper/plugin/configuration/PluginMeta.java b/src/main/java/io/papermc/paper/plugin/configuration/PluginMeta.java
index b5cd66c6c0ebc4bd313e26a4414920c3703f8e05..ef393f1f93ca48264fc1b6e3a27787f6a9152e1b 100644
--- a/src/main/java/io/papermc/paper/plugin/configuration/PluginMeta.java
+++ b/src/main/java/io/papermc/paper/plugin/configuration/PluginMeta.java
@@ -18,14 +18,14 @@ import java.util.List;
 public interface PluginMeta {
 
     /**
-     * Gives the name of the plugin. This name is a unique identifier for
-     * plugins.
+     * Provides the name of the plugin. This name uniquely identifies the plugin amongst all loaded plugins on the
+     * server.
      * <ul>
-     * <li>Will only contain alphanumeric characters, underscores, hyphon,
-     *     and period (a-z,A-Z,0-9,_.-).
+     * <li>Will only contain alphanumeric characters, underscores, hyphens,
+     *     and periods: [a-zA-Z0-9_\-\.].
      * <li>Typically used for identifying the plugin data folder.
-     * <li>The is the token referenced in {@link #getPluginDependencies()} ()}, {@link
-     *     #getPluginSoftDependencies()}, and {@link #getLoadBeforePlugins()}.
+     * <li>The name also acts as the token referenced in {@link #getPluginDependencies()},
+     * {@link #getPluginSoftDependencies()}, and {@link #getLoadBeforePlugins()}.
      * </ul>
      * <p>
      * In the plugin.yml, this entry is named <code>name</code>.
@@ -38,7 +38,7 @@ public interface PluginMeta {
     String getName();
 
     /**
-     * Returns the name of a plugin, including the version.
+     * Returns the display name of the plugin, including the version.
      *
      * @return a descriptive name of the plugin and respective version
      */
@@ -48,49 +48,63 @@ public interface PluginMeta {
     }
 
     /**
-     * Gives the fully qualified name of the main class for a plugin.
-     * A {@link JavaPlugin} is expected at this location.
+     * Provides the fully qualified class name of the main class for the plugin.
+     * A subtype of {@link JavaPlugin} is expected at this location.
      *
-     * @return the fully qualified main class for the plugin
+     * @return the fully qualified class name of the plugin's main class.
      */
     @NotNull
     String getMainClass();
 
     /**
-     * Gives the phase of server startup that the plugin should be loaded.
+     * Returns the phase of the server startup logic that the plugin should be loaded.
      *
-     * @return phase
+     * @return the plugin load order
+     * @see PluginLoadOrder for further details regards the available load orders.
      */
     @NotNull
     PluginLoadOrder getLoadOrder();
 
     /**
-     * Gets the version of this plugin
+     * Provides the version of this plugin as defined by the plugin.
+     * There is no inherit format defined/enforced for the version of a plugin, however a common approach
+     * might be schematic versioning.
      *
-     * @return version string
+     * @return the string representation of the plugin's version
      */
     @NotNull
     String getVersion();
 
     /**
-     * Gets the prefix that should be used for the plugin logger.
-     * Null if not specified
+     * Provides the prefix that should be used for the plugin logger.
+     * The logger prefix allows plugins to overwrite the usual default of the logger prefix, which is the name of the
+     * plugin.
      *
-     * @return logger prefix
+     * @return the specific overwrite of the logger prefix as defined by the plugin. If the plugin did not define a
+     *     custom logger prefix, this method will return null
      */
     @Nullable
     String getLoggerPrefix();
 
     /**
-     * Gets a list of dependencies that are required for this plugin to load.
+     * Provides a list of dependencies that are required for this plugin to load.
+     * The list holds the unique identifiers, following the constraints laid out in {@link #getName()}, of the
+     * dependencies.
+     * <p>
+     * If any of the dependencies defined by this list are not installed on the server, this plugin will fail to load.
      *
-     * @return immutable list of required dependencies
+     * @return an immutable list of required dependency names
      */
     @NotNull
     List<String> getPluginDependencies();
 
     /**
-     * Gets a list of dependencies that are used but not required for this plugin to load.
+     * Provides a list of dependencies that are used but not required by this plugin.
+     * The list holds the unique identifiers, following the constraints laid out in {@link #getName()}, of the soft
+     * dependencies.
+     * <p>
+     * If these dependencies are installed on the server, they will be loaded first and supplied as dependencies to this
+     * plugin, however the plugin will load even if these dependencies are not installed.
      *
      * @return immutable list of soft dependencies
      */
@@ -98,15 +112,22 @@ public interface PluginMeta {
     List<String> getPluginSoftDependencies();
 
     /**
-     * Gets a list of dependencies that should be loaded before this plugin is loaded.
+     * Provides a list of plugins that should be loaded before this plugin is loaded.
+     * The list holds the unique identifiers, following the constraints laid out in {@link #getName()}, of the
+     * plugins that should be loaded before the plugin described by this plugin meta.
+     * <p>
+     * The plugins referenced in the list provided by this method are not considered dependencies of this plugin and
+     * are hence not available to the plugin at runtime. They merely load before this plugin.
      *
-     * @return immutable list of dependencies to load before
+     * @return immutable list of plugins to load before this plugin
      */
     @NotNull
     List<String> getLoadBeforePlugins();
 
     /**
-     * Gets a list of plugins/dependencies that this plugin provides.
+     * Returns the list of plugins/dependencies that this plugin provides.
+     * The list holds the unique identifiers, following the constraints laid out in {@link #getName()}, for each plugin
+     * it provides the expected classes for.
      *
      * @return immutable list of provided plugins/dependencies
      */
@@ -114,7 +135,8 @@ public interface PluginMeta {
     List<String> getProvidedPlugins();
 
     /**
-     * Gives a list of authors that created this plugin.
+     * Provides the list of authors that are credited with creating this plugin.
+     * The author names are in no particular format.
      *
      * @return an immutable list of the plugin's authors
      */
@@ -122,7 +144,8 @@ public interface PluginMeta {
     List<String> getAuthors();
 
     /**
-     * Gets a list of contributors that created this plugin.
+     * Provides a list of contributors that contributed to the plugin but are not considered authors.
+     * The names of the contributors are in no particular format.
      *
      * @return an immutable list of the plugin's contributors
      */
@@ -133,21 +156,22 @@ public interface PluginMeta {
      * Gives a human-friendly description of the functionality the plugin
      * provides.
      *
-     * @return description or null if unset
+     * @return description or null if the plugin did not define a human readable description.
      */
     @Nullable
     String getDescription();
 
     /**
-     * Gets the website for the plugin or the plugin's author.
+     * Provides the website for the plugin or the plugin's author.
+     * The defined string value is <b>not guaranteed</b> to be in the form of a url.
      *
-     * @return website or null if unset
+     * @return a string representation of the website that serves as the main hub for this plugin/its author.
      */
     @Nullable
     String getWebsite();
 
     /**
-     * Gets a list of permissions that are registered in this plugin configuration.
+     * Provides the list of permissions that are defined via the plugin meta instance.
      *
      * @return an immutable list of permissions
      */
@@ -156,9 +180,10 @@ public interface PluginMeta {
     List<Permission> getPermissions();
 
     /**
-     * Gets the default permission value for configured permissions.
+     * Provides the default values that apply to the permissions defined in this plugin meta.
      *
-     * @return default permission
+     * @return the bukkit permission default container.
+     * @see #getPermissions()
      */
     // TODO: Do we even want this? Why not just use the bootstrapper
     @NotNull
@@ -169,7 +194,8 @@ public interface PluginMeta {
      * Nullable if this version is not specified, and should be
      * considered legacy (spigot plugins only)
      *
-     * @return version
+     * @return the version string made up of the major and minor version (e.g. 1.18 or 1.19). Minor versions like 1.18.2
+     * are unified to their major release version (in this example 1.18)
      */
     @Nullable
     String getAPIVersion();
diff --git a/src/main/java/io/papermc/paper/plugin/configuration/package-info.java b/src/main/java/io/papermc/paper/plugin/configuration/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..ddb3076124365d0d1a5caa32d4dcb1f4314dd7ae
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/configuration/package-info.java
@@ -0,0 +1,8 @@
+/**
+ * The paper configuration package contains the new java representation of a plugins configuration file.
+ * While most values are described in detail on {@link io.papermc.paper.plugin.configuration.PluginMeta}, a full
+ * entry on the paper contains a full and extensive example of possible configurations of the paper-plugin.yml.
+ * @see <a href="https://docs.papermc.io/paper">Extensive documentation and examples of the paper-plugin.yml</a>
+ * <!--TODO update the documentation link once documentation for this exists and is deployed-->
+ */
+package io.papermc.paper.plugin.configuration;
diff --git a/src/main/java/io/papermc/paper/plugin/loader/PluginClasspathBuilder.java b/src/main/java/io/papermc/paper/plugin/loader/PluginClasspathBuilder.java
index 9380edf3d9d74cb5d80fb87c339113b71290eded..28cbc09b7c1ded1f4515969cef4a669adac85703 100644
--- a/src/main/java/io/papermc/paper/plugin/loader/PluginClasspathBuilder.java
+++ b/src/main/java/io/papermc/paper/plugin/loader/PluginClasspathBuilder.java
@@ -2,11 +2,14 @@ package io.papermc.paper.plugin.loader;
 
 import io.papermc.paper.plugin.bootstrap.PluginProviderContext;
 import io.papermc.paper.plugin.loader.library.ClassPathLibrary;
+import io.papermc.paper.plugin.loader.library.LibraryStore;
 import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Contract;
 import org.jetbrains.annotations.NotNull;
 
 /**
- * Class used for building classpath configurations in plugin loading.
+ * A mutable builder that may be used to collect and register all {@link ClassPathLibrary} instances a
+ * {@link PluginLoader} aims to provide to its plugin at runtime.
  */
 @ApiStatus.NonExtendable
 @ApiStatus.Experimental
@@ -14,23 +17,20 @@ public interface PluginClasspathBuilder {
 
     /**
      * Adds a new classpath library to this classpath builder.
-     * <blockquote><pre>{@code
-     * public void classloader(PluginClasspathBuilder classpathBuilder) {
-     *     classpathBuilder.addLibrary(new JarLibrary(Path.of("bob.jar")));
+     * <p>
+     * As a builder, this method does not invoke {@link ClassPathLibrary#register(LibraryStore)} and
+     * may hence be run without invoking potential IO performed by a {@link ClassPathLibrary} during resolution.
+     * <p>
+     * The paper api provides pre implemented {@link ClassPathLibrary} types that allow easy inclusion of existing
+     * libraries on disk or on remote maven repositories.
      *
-     *     MavenLibraryResolver resolver = new MavenLibraryResolver();
-     *     resolver.addDependency(new Dependency(new DefaultArtifact("namespace:identifier:version"), null));
-     *     resolver.addRepository(new RemoteRepository.Builder("my_repo", "default", "https://repo.mymavenrepo.com/repository/maven-public/").build());
-     *
-     *     classpathBuilder.addLibrary(resolver);
-     * }
-     *
-     * }</pre></blockquote>
-     *
-     * @param classPathLibrary library
+     * @param classPathLibrary the library instance to add to this builder
      * @return self
+     * @see io.papermc.paper.plugin.loader.library.impl.JarLibrary
+     * @see io.papermc.paper.plugin.loader.library.impl.MavenLibraryResolver
      */
     @NotNull
+    @Contract("_ -> this")
     PluginClasspathBuilder addLibrary(@NotNull ClassPathLibrary classPathLibrary);
 
     @NotNull
diff --git a/src/main/java/io/papermc/paper/plugin/loader/PluginLoader.java b/src/main/java/io/papermc/paper/plugin/loader/PluginLoader.java
index b6cebdaf015a12f40ccec761e285511dfe49c8a2..c9e31f78ff6ff969436c6d99755845786c4d383f 100644
--- a/src/main/java/io/papermc/paper/plugin/loader/PluginLoader.java
+++ b/src/main/java/io/papermc/paper/plugin/loader/PluginLoader.java
@@ -6,8 +6,9 @@ import org.jetbrains.annotations.NotNull;
 /**
  * A plugin loader is responsible for creating certain aspects of a plugin before it is created.
  * <p>
- * The goal of this is to allow certain configuration values to be moved and can instead be
- * configured at run time inorder to make plugins a bit more dynamic.
+ * The goal of the plugin loader is the creation of an expected/dynamic environment for the plugin to load into.
+ * This, as of right now, only applies to creating the expected classpath for the plugin, e.g. supplying external
+ * libraries to the plugin.
  * <p>
  * It should be noted that this class will be called from a different classloader, this will cause any static values
  * set in this class/any other classes loaded not to persist when the plugin loads.
@@ -17,11 +18,12 @@ import org.jetbrains.annotations.NotNull;
 public interface PluginLoader {
 
     /**
-     * Called by the server, allows you to configure the classpath that your plugin is run on.
-     * This allows you to configure dependencies for your plugin where jars can be downloaded or
+     * Called by the server to allows plugins to configure the runtime classpath that the plugin is run on.
+     * This allows plugin loaders to configure dependencies for the plugin where jars can be downloaded or
      * provided during runtime.
      *
-     * @param classpathBuilder classpath builder
+     * @param classpathBuilder a mutable classpath builder that may be used to register custom runtime dependencies
+     *                         for the plugin the loader was registered for.
      */
     void classloader(@NotNull PluginClasspathBuilder classpathBuilder);
 
diff --git a/src/main/java/io/papermc/paper/plugin/loader/library/ClassPathLibrary.java b/src/main/java/io/papermc/paper/plugin/loader/library/ClassPathLibrary.java
index 1ac3a1d8ade5f100b3a0f4956a632fa89ceacc15..1347b535d90c2c281c184d0459e7ac59c0350c9f 100644
--- a/src/main/java/io/papermc/paper/plugin/loader/library/ClassPathLibrary.java
+++ b/src/main/java/io/papermc/paper/plugin/loader/library/ClassPathLibrary.java
@@ -3,14 +3,17 @@ package io.papermc.paper.plugin.loader.library;
 import org.jetbrains.annotations.NotNull;
 
 /**
- * Responsible for loading libraries into the LibraryStore.
+ * The classpath library interface represents libraries that are capable of registering themselves via
+ * {@link #register(LibraryStore)} on any given {@link LibraryStore}.
  */
 public interface ClassPathLibrary {
 
     /**
-     * Loads the correct jars into the librarystore.
+     * Called to register the library this class path library represents into the passed library store.
+     * This method may either be implemented by the plugins themselves if they need complex logic, or existing
+     * API exposed implementations of this interface may be used.
      *
-     * @param store library store
+     * @param store the library store instance to register this library into
      * @throws LibraryLoadingException if library loading failed for this classpath library
      */
     void register(@NotNull LibraryStore store) throws LibraryLoadingException;
diff --git a/src/main/java/io/papermc/paper/plugin/loader/library/LibraryStore.java b/src/main/java/io/papermc/paper/plugin/loader/library/LibraryStore.java
index e7138a72294b75cbbd80a0e549ccd056fd7cc9a3..0546fa1e9dcd7155086a8650806a8c086b6fc458 100644
--- a/src/main/java/io/papermc/paper/plugin/loader/library/LibraryStore.java
+++ b/src/main/java/io/papermc/paper/plugin/loader/library/LibraryStore.java
@@ -7,14 +7,19 @@ import java.nio.file.Path;
 
 /**
  * Represents a storage that stores library jars.
+ * <p>
+ * The library store api allows plugins to register specific dependencies into their runtime classloader when their
+ * {@link io.papermc.paper.plugin.loader.PluginLoader} is processed.
+ *
+ * @see io.papermc.paper.plugin.loader.PluginLoader
  */
 @ApiStatus.Internal
 public interface LibraryStore {
 
     /**
-     * Adds the provided library path to the current
-     * library store.
-     * @param library path of library
+     * Adds the provided library path to this library store.
+     *
+     * @param library path to the libraries jar file on the disk
      */
     void addLibrary(@NotNull Path library);
 
diff --git a/src/main/java/io/papermc/paper/plugin/loader/library/impl/JarLibrary.java b/src/main/java/io/papermc/paper/plugin/loader/library/impl/JarLibrary.java
index 4da748e08d4f70e9a8402306326e514837f7e21a..3327595d154700890c862a2ced5eff93da4bd634 100644
--- a/src/main/java/io/papermc/paper/plugin/loader/library/impl/JarLibrary.java
+++ b/src/main/java/io/papermc/paper/plugin/loader/library/impl/JarLibrary.java
@@ -9,16 +9,26 @@ import java.nio.file.Files;
 import java.nio.file.Path;
 
 /**
- * A simple jar library, will error if the jar is not found.
+ * A simple jar library implementation of the {@link ClassPathLibrary} that allows {@link io.papermc.paper.plugin.loader.PluginLoader}s to
+ * append a jar stored on the local file system into their runtime classloader.
+ * <p>
+ * An example creation of the jar library type may look like this:
+ * <pre>{@code
+ *   final JarLibrary customLibrary = new JarLibrary(Path.of("libs/custom-library-1.24.jar"));
+ * }</pre>
+ * resulting in a jar library that provides the jar at {@code libs/custom-library-1.24.jar} to the plugins classloader
+ * at runtime.
+ * <p>
+ * The jar library implementation will error if file exists at the specified path.
  */
 public class JarLibrary implements ClassPathLibrary {
 
     private final Path path;
 
     /**
-     * Creates a jar library with the given path.
+     * Creates a new jar library that references the jar file found at the provided path.
      *
-     * @param path given path
+     * @param path the path, relative to the JVMs start directory.
      */
     public JarLibrary(@NotNull Path path) {
         this.path = path;
diff --git a/src/main/java/io/papermc/paper/plugin/loader/library/impl/MavenLibraryResolver.java b/src/main/java/io/papermc/paper/plugin/loader/library/impl/MavenLibraryResolver.java
index 43e3a6eca1247f313caeca51b3e0aa2d1dce99ef..e3e902a708a760be167cb1bba8e845c5fa5b9141 100644
--- a/src/main/java/io/papermc/paper/plugin/loader/library/impl/MavenLibraryResolver.java
+++ b/src/main/java/io/papermc/paper/plugin/loader/library/impl/MavenLibraryResolver.java
@@ -32,8 +32,21 @@ import java.util.logging.Level;
 import java.util.logging.Logger;
 
 /**
- * A maven library, this allows you to resolve jars from maven repositories.
- * This class will automatically cache resolved libraries when needed into the libraries directory.
+ * The maven library resolver acts as a resolver for yet to be resolved jar libraries that may be pulled from a
+ * remote maven repository.
+ * <p>
+ * Plugins may create and configure a {@link MavenLibraryResolver} by creating a new one and registering both
+ * a dependency artifact that should be resolved to a library at runtime and the repository it is found in.
+ * An example of this would be the inclusion of the jooq library for typesafe SQL queries:
+ * <pre>{@code
+ * MavenLibraryResolver resolver = new MavenLibraryResolver();
+ * resolver.addDependency(new Dependency(new DefaultArtifact("org.jooq:jooq:3.17.7"), null));
+ * resolver.addRepository(new RemoteRepository.Builder(
+ *     "central", "default", "https://repo1.maven.org/maven2/"
+ * ).build());
+ * }</pre>
+ *
+ * Plugins may create and register a {@link MavenLibraryResolver} after configuring it.
  */
 public class MavenLibraryResolver implements ClassPathLibrary {
 
@@ -44,6 +57,14 @@ public class MavenLibraryResolver implements ClassPathLibrary {
     private final List<RemoteRepository> repositories = new ArrayList<>();
     private final List<Dependency> dependencies = new ArrayList<>();
 
+    /**
+     * Creates a new maven library resolver instance.
+     * <p>
+     * The created instance will use the servers {@code libraries} folder to cache fetched libraries in.
+     * Notably, the resolver is created without any repository, not even maven central.
+     * It is hence crucial that plugins which aim to use this api register all required repositories before
+     * submitting the {@link MavenLibraryResolver} to the {@link io.papermc.paper.plugin.loader.PluginClasspathBuilder}.
+     */
     public MavenLibraryResolver() {
         DefaultServiceLocator locator = MavenRepositorySystemUtils.newServiceLocator();
         locator.addService(RepositoryConnectorFactory.class, BasicRepositoryConnectorFactory.class);
@@ -65,9 +86,9 @@ public class MavenLibraryResolver implements ClassPathLibrary {
 
     /**
      * Adds the provided dependency to the library resolver.
-     * The dependency from the first valid repository will be chosen.
+     * The artifact from the first valid repository matching the passed dependency will be chosen.
      *
-     * @param dependency provided dependency
+     * @param dependency the definition of the dependency the maven library resolver should resolve when running
      * @see MavenLibraryResolver#addRepository(RemoteRepository)
      */
     public void addDependency(@NotNull Dependency dependency) {
@@ -79,7 +100,8 @@ public class MavenLibraryResolver implements ClassPathLibrary {
      * The order in which these are added does matter, as dependency resolving will start at the first added
      * repository.
      *
-     * @param remoteRepository provided repository
+     * @param remoteRepository the configuration that defines the maven repository this library resolver should fetch
+     *                         dependencies from
      */
     public void addRepository(@NotNull RemoteRepository remoteRepository) {
         this.repositories.add(remoteRepository);
@@ -88,7 +110,7 @@ public class MavenLibraryResolver implements ClassPathLibrary {
     /**
      * Resolves the provided dependencies and adds them to the library store.
      *
-     * @param store library store
+     * @param store the library store the then resolved and downloaded dependencies are registered into
      * @throws LibraryLoadingException if resolving a dependency failed
      */
     @Override
diff --git a/src/main/java/io/papermc/paper/plugin/provider/classloader/ClassLoaderAccess.java b/src/main/java/io/papermc/paper/plugin/provider/classloader/ClassLoaderAccess.java
index 1adf853dbd7389fdcb9715f21771be3fd64f5be3..64e46fdfa4d404cb08c67a456e5990b729296b98 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/classloader/ClassLoaderAccess.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/classloader/ClassLoaderAccess.java
@@ -1,10 +1,34 @@
 package io.papermc.paper.plugin.provider.classloader;
 
 import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
 
+/**
+ * The class loader access interface is an <b>internal</b> representation of a class accesses' ability to see types
+ * from other {@link ConfiguredPluginClassLoader}.
+ * <p>
+ * An example of this would be a class loader access representing a plugin. The class loader access in that case would
+ * only return {@code true} on calls for {@link #canAccess(ConfiguredPluginClassLoader)} if the passed class loader
+ * is owned by a direct or transitive dependency of the plugin, preventing the plugin for accidentally discovering and
+ * using class types that are supplied by plugins/libraries the plugin did not actively define as a dependency.
+ */
 @ApiStatus.Internal
 public interface ClassLoaderAccess {
 
+    /**
+     * Evaluates if this class loader access is allowed to access types provided by the passed {@link
+     * ConfiguredPluginClassLoader}.
+     * <p>
+     * This interface method does not offer any further contracts on the interface level, as the logic to determine
+     * what class loaders this class loader access is allowed to retrieve types from depends heavily on the type of
+     * access.
+     * Legacy spigot types for example may access any class loader available on the server, while modern paper plugins
+     * are properly limited to their dependency tree.
+     *
+     * @param classLoader the class loader for which access should be evaluated
+     * @return a plain boolean flag, {@code true} indicating that this class loader access is allowed to access types
+     * from the passed configured plugin class loader, {@code false} indicating otherwise.
+     */
     boolean canAccess(ConfiguredPluginClassLoader classLoader);
 
 }
diff --git a/src/main/java/io/papermc/paper/plugin/provider/classloader/ConfiguredPluginClassLoader.java b/src/main/java/io/papermc/paper/plugin/provider/classloader/ConfiguredPluginClassLoader.java
index d86a88a97611092a270aa2f4004cab00780805c8..a15e7474eb8eb1196f69070b7cf7fd5af6100f68 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/classloader/ConfiguredPluginClassLoader.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/classloader/ConfiguredPluginClassLoader.java
@@ -7,13 +7,49 @@ import org.jetbrains.annotations.NotNull;
 
 import java.io.Closeable;
 
+/**
+ * The configured plugin class loader represents an <b>internal</b> abstraction over the classloaders used by the server
+ * to load and access a plugins classes during runtime.
+ * <p>
+ * It implements {@link Closeable} to define the ability to shutdown and close the classloader that implements this
+ * interface.
+ */
 @ApiStatus.Internal
 public interface ConfiguredPluginClassLoader extends Closeable {
 
+    /**
+     * Provides the configuration of the plugin that this plugin classloader provides type access to.
+     *
+     * @return the plugin meta instance, holding all meta information about the plugin instance.
+     */
     PluginMeta getConfiguration();
 
-    Class<?> loadClass(@NotNull String name, boolean resolve, boolean checkGlobal, boolean checkLibraries) throws ClassNotFoundException;
+    /**
+     * Attempts to load a class from this plugin class loader using the passed fully qualified name.
+     * This lookup logic can be configured through the following parameters to define how wide or how narrow the
+     * class lookup should be.
+     *
+     * @param name           the fully qualified name of the class to load
+     * @param resolve        whether the class should be resolved if needed or not
+     * @param checkGlobal    whether this lookup should check transitive dependencies, including either the legacy spigot
+     *                       global class loader or the paper {@link PluginClassLoaderGroup}
+     * @param checkLibraries whether the defined libraries should be checked for the class or not
+     * @return the class found at the fully qualified class name passed under the passed restrictions
+     * @throws ClassNotFoundException if the class could not be found considering the passed restrictions
+     * @see ClassLoader#loadClass(String)
+     * @see Class#forName(String, boolean, ClassLoader)
+     */
+    Class<?> loadClass(@NotNull String name,
+                       boolean resolve,
+                       boolean checkGlobal,
+                       boolean checkLibraries) throws ClassNotFoundException;
 
-    // Called in the constructor, at the very top
+    /**
+     * Initializes both this configured plugin class loader and the java plugin passed to link to each other.
+     * This logic is to be called exactly once when the initial setup between the class loader and the instantiated
+     * {@link JavaPlugin} is loaded.
+     *
+     * @param plugin the {@link JavaPlugin} that should be interlinked with this class loader.
+     */
     void init(JavaPlugin plugin);
 }
diff --git a/src/main/java/io/papermc/paper/plugin/provider/classloader/PaperClassLoaderStorage.java b/src/main/java/io/papermc/paper/plugin/provider/classloader/PaperClassLoaderStorage.java
index 30a6f070f35ff5f21e9c501b89e50993e79132f2..26e30a36676b17d9198987a1a1f5d12005c7c6fe 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/classloader/PaperClassLoaderStorage.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/classloader/PaperClassLoaderStorage.java
@@ -3,21 +3,88 @@ package io.papermc.paper.plugin.provider.classloader;
 import org.bukkit.plugin.java.PluginClassLoader;
 import org.jetbrains.annotations.ApiStatus;
 
+/**
+ * The plugin classloader storage is an <b>internal</b> type that is used to manage existing classloaders on the server.
+ * <p>
+ * The paper classloader storage is also responsible for storing added {@link ConfiguredPluginClassLoader}s into
+ * {@link PluginClassLoaderGroup}s, via {@link #registerOpenGroup(ConfiguredPluginClassLoader)},
+ * {@link #registerSpigotGroup(PluginClassLoader)} and {@link
+ * #registerAccessBackedGroup(ConfiguredPluginClassLoader, ClassLoaderAccess)}.
+ * <p>
+ * Groups are differentiated into the global group or plugin owned groups.
+ * <ul>
+ * <li>The global group holds all registered class loaders and merely exists to maintain backwards compatibility with
+ * spigots legacy classloader handling.</li>
+ * <li>The plugin groups only contains the classloaders that each plugin has access to and hence serves to properly
+ * separates unrelated classloaders.</li>
+ * </ul>
+ */
 @ApiStatus.Internal
 public interface PaperClassLoaderStorage {
 
+    /**
+     * Access to the shared instance of the {@link PaperClassLoaderStorageAccess}.
+     *
+     * @return the singleton instance of the {@link PaperClassLoaderStorage} used throughout the server
+     */
     static PaperClassLoaderStorage instance() {
         return PaperClassLoaderStorageAccess.INSTANCE;
     }
 
+    /**
+     * Registers a legacy spigot {@link PluginClassLoader} into the loader storage, creating a group wrapping
+     * the single plugin class loader with transitive access to the global group.
+     *
+     * @param pluginClassLoader the legacy spigot plugin class loader to register
+     * @return the group the plugin class loader was placed into
+     */
     PluginClassLoaderGroup registerSpigotGroup(PluginClassLoader pluginClassLoader);
 
+    /**
+     * Registers a paper configured plugin classloader into a new open group, with full access to the global
+     * plugin class loader group.
+     * <p>
+     * This method hence allows the configured plugin class loader to access all other class loaders registered in this
+     * storage.
+     *
+     * @param classLoader the configured plugin class loader to register
+     * @return the group the plugin class loader was placed into
+     */
     PluginClassLoaderGroup registerOpenGroup(ConfiguredPluginClassLoader classLoader);
 
+    /**
+     * Registers a paper configured classloader into a new, access backed group.
+     * The access backed classloader group, different from an open group, only has access to the classloaders
+     * the passed {@link ClassLoaderAccess} grants access to.
+     *
+     * @param classLoader the configured plugin class loader to register
+     * @param access      the class loader access that defines what other classloaders the passed plugin class loader
+     *                    should be granted access to.
+     * @return the group the plugin class loader was placed into.
+     */
     PluginClassLoaderGroup registerAccessBackedGroup(ConfiguredPluginClassLoader classLoader, ClassLoaderAccess access);
 
+    /**
+     * Unregisters a configured class loader from this storage.
+     * This removes the passed class loaders from any group it may have been a part of, including the global group.
+     *
+     * @param configuredPluginClassLoader the class loader to remove from this storage.
+     * @apiNote this method is <b>highly</b> discouraged from being used, as mutation of the classloaders at runtime
+     * is not encouraged
+     */
     void unregisterClassloader(ConfiguredPluginClassLoader configuredPluginClassLoader);
 
+    /**
+     * Registers a configured plugin class loader directly into the global group without adding it to
+     * any existing groups.
+     *
+     * @param pluginLoader the configured plugin classloader instance that should be registered directly into the global
+     *                     group.
+     * @return a simple boolean flag, {@code true} if the classloader was registered or {@code false} if the classloader
+     * was already part of the global group.
+     * @apiNote this method unsafely injects the plugin classloader directly into the global group, which bypasses the
+     * group structure paper's plugin API introduced. This method should hence be used with caution.
+     */
     boolean registerUnsafePlugin(ConfiguredPluginClassLoader pluginLoader);
 
 }
diff --git a/src/main/java/io/papermc/paper/plugin/provider/classloader/PaperClassLoaderStorageAccess.java b/src/main/java/io/papermc/paper/plugin/provider/classloader/PaperClassLoaderStorageAccess.java
index 7d3f68f06f84f5b47ab29c3464056c1b16e4e025..2c0e5ba6f8eba7a632180491843071b8a8558e56 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/classloader/PaperClassLoaderStorageAccess.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/classloader/PaperClassLoaderStorageAccess.java
@@ -2,8 +2,16 @@ package io.papermc.paper.plugin.provider.classloader;
 
 import net.kyori.adventure.util.Services;
 
+/**
+ * The paper classloader storage access acts as the holder for the server provided implementation of the
+ * {@link PaperClassLoaderStorage} interface.
+ */
 class PaperClassLoaderStorageAccess {
 
+    /**
+     * The shared instance of the {@link PaperClassLoaderStorage}, supplied through the {@link java.util.ServiceLoader}
+     * by the server.
+     */
     static final PaperClassLoaderStorage INSTANCE = Services.service(PaperClassLoaderStorage.class).orElseThrow();
 
 }
diff --git a/src/main/java/io/papermc/paper/plugin/provider/classloader/PluginClassLoaderGroup.java b/src/main/java/io/papermc/paper/plugin/provider/classloader/PluginClassLoaderGroup.java
index 405011f83f07b40dfe04fc98d1800a0bc49aefb6..885151cb932d9b8c09a7887edc879e154225f416 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/classloader/PluginClassLoaderGroup.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/classloader/PluginClassLoaderGroup.java
@@ -1,19 +1,65 @@
 package io.papermc.paper.plugin.provider.classloader;
 
 import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Contract;
 import org.jetbrains.annotations.Nullable;
 
+/**
+ * A plugin classloader group represents a group of classloaders that a plugins classloader may access.
+ * <p>
+ * An example of this would be a classloader group that holds all direct and transitive dependencies a plugin declared,
+ * allowing a plugins classloader to access classes included in these dependencies via this group.
+ */
 @ApiStatus.Internal
 public interface PluginClassLoaderGroup {
 
+    /**
+     * Attempts to find/load a class from this plugin class loader group using the passed fully qualified name
+     * in any of the classloaders that are part of this group.
+     * <p>
+     * The lookup order across the contained loaders is not defined on the API level and depends purely on the
+     * implementation.
+     *
+     * @param name      the fully qualified name of the class to load
+     * @param resolve   whether the class should be resolved if needed or not
+     * @param requester plugin classloader that is requesting the class from this loader group
+     * @return the class found at the fully qualified class name passed. If the class could not be found, {@code null}
+     * will be returned.
+     * @see ConfiguredPluginClassLoader#loadClass(String, boolean, boolean, boolean)
+     */
     @Nullable
     Class<?> getClassByName(String name, boolean resolve, ConfiguredPluginClassLoader requester);
 
-    // Used for dyanmically updating plugin classloaders... yuck!
+    /**
+     * Removes a configured plugin classloader from this class loader group.
+     * If the classloader is not currently in the list, this method will simply do nothing.
+     *
+     * @param configuredPluginClassLoader the plugin classloader to remove from the group
+     */
+    @Contract(mutates = "this")
     void remove(ConfiguredPluginClassLoader configuredPluginClassLoader);
 
+    /**
+     * Adds the passed plugin classloader to this group, allowing this group to use it during
+     * {@link #getClassByName(String, boolean, ConfiguredPluginClassLoader)} lookups.
+     * <p>
+     * This method does <b>not</b> query the {@link ClassLoaderAccess} (exposed via {@link #getAccess()}) to ensure
+     * if this group has access to the class loader passed.
+     *
+     * @param configuredPluginClassLoader the plugin classloader to add to this group.
+     */
+    @Contract(mutates = "this")
     void add(ConfiguredPluginClassLoader configuredPluginClassLoader);
 
+    /**
+     * Provides the class loader access that guards and defines the content of this classloader group.
+     * While not guaranteed contractually (see {@link #add(ConfiguredPluginClassLoader)}), the access generally is
+     * responsible for defining which {@link ConfiguredPluginClassLoader}s should be part of this group and which ones
+     * should not.
+     *
+     * @return the classloader access governing which classloaders should be part of this group and which ones should
+     * not.
+     */
     ClassLoaderAccess getAccess();
 
 }
diff --git a/src/main/java/io/papermc/paper/plugin/provider/util/DummyBukkitPluginLoader.java b/src/main/java/io/papermc/paper/plugin/provider/util/DummyBukkitPluginLoader.java
index 764d588a4ba2722bde2b5d75100c630ff5dbfa30..552781c77cd61d8d102d5d2f16c2ec20ffc835a8 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/util/DummyBukkitPluginLoader.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/util/DummyBukkitPluginLoader.java
@@ -12,6 +12,12 @@ import java.util.Map;
 import java.util.Set;
 import java.util.regex.Pattern;
 
+/**
+ * A purely internal type that implements the now deprecated {@link PluginLoader} after the implementation
+ * of papers new plugin system.
+ *
+ * @param plugin the loaded plugin that should be wrapped by this NOOP implementation
+ */
 @ApiStatus.Internal
 public record DummyBukkitPluginLoader(Plugin plugin) implements PluginLoader {
 
diff --git a/src/main/java/io/papermc/paper/plugin/provider/util/ProviderUtil.java b/src/main/java/io/papermc/paper/plugin/provider/util/ProviderUtil.java
index 37ee4d9fdcf19ea644d25d29c122ea10d6e2ac95..6bf3d212a6156ad9ab0e82d1ca0a04f83f6e4b83 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/util/ProviderUtil.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/util/ProviderUtil.java
@@ -5,15 +5,44 @@ import org.jetbrains.annotations.ApiStatus;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-import java.util.function.Consumer;
-
+/**
+ * An <b>internal</b> utility type that holds logic for loading a provider-like type from a classloaders.
+ * Provides, at least in the context of this utility, define themselves as implementations of a specific parent
+ * interface/type, e.g. {@link org.bukkit.plugin.java.JavaPlugin} and implement a no-args constructor.
+ */
 @ApiStatus.Internal
 public class ProviderUtil {
 
+    /**
+     * Loads the class found at the provided fully qualified class name from the passed classloader, creates a new
+     * instance of it using the no-args constructor, that should exist as per this method contract, and casts it to the
+     * provided parent type.
+     *
+     * @param clazz     the fully qualified name of the class to load
+     * @param classType the parent type that the created object found at the {@code clazz} name should be cast to
+     * @param loader    the loader from which the class should be loaded
+     * @param <T>       the generic type of the parent class the created object will be cast to
+     * @return the object instantiated from the class found at the provided FQN, cast to the parent type
+     */
+    @NotNull
     public static <T> T loadClass(@NotNull String clazz, @NotNull Class<T> classType, @NotNull ClassLoader loader) {
         return loadClass(clazz, classType, loader, null);
     }
 
+    /**
+     * Loads the class found at the provided fully qualified class name from the passed classloader, creates a new
+     * instance of it using the no-args constructor, that should exist as per this method contract, and casts it to the
+     * provided parent type.
+     *
+     * @param clazz     the fully qualified name of the class to load
+     * @param classType the parent type that the created object found at the {@code clazz} name should be cast to
+     * @param loader    the loader from which the class should be loaded
+     * @param onError   a runnable that is executed before any unknown exception is raised through a sneaky throw.
+     * @param <T>       the generic type of the parent class the created object will be cast to
+     * @return the object instantiated from the class found at the provided fully qualified class name, cast to the
+     * parent type
+     */
+    @NotNull
     public static <T> T loadClass(@NotNull String clazz, @NotNull Class<T> classType, @NotNull ClassLoader loader, @Nullable Runnable onError) {
         try {
             T clazzInstance;
