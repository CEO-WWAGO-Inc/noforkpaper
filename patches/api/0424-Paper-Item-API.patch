From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Mon, 17 Oct 2022 18:00:40 -0400
Subject: [PATCH] Paper Item API


diff --git a/build.gradle.kts b/build.gradle.kts
index 3c4dd6ebc2289c44c2f5723e7920aadffdc51884..f455466089cd36853bdb6fa1366e80e33abdae4e 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -31,6 +31,7 @@ dependencies {
     api("com.googlecode.json-simple:json-simple:1.1.1") {
         isTransitive = false // includes junit
     }
+    api("io.leangen.geantyref:geantyref:1.3.13") // Paper
     api("it.unimi.dsi:fastutil:8.5.6")
     apiAndDocs(platform("net.kyori:adventure-bom:$adventureVersion"))
     apiAndDocs("net.kyori:adventure-api")
diff --git a/src/main/java/io/papermc/paper/inventory/item/ItemStack.java b/src/main/java/io/papermc/paper/inventory/item/ItemStack.java
new file mode 100644
index 0000000000000000000000000000000000000000..098a04271404faa15dcbb8a33cbcf826a6933517
--- /dev/null
+++ b/src/main/java/io/papermc/paper/inventory/item/ItemStack.java
@@ -0,0 +1,37 @@
+package io.papermc.paper.inventory.item;
+
+import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableMap;
+import net.kyori.adventure.text.event.HoverEvent;
+import net.kyori.adventure.text.event.HoverEventSource;
+import net.kyori.adventure.translation.Translatable;
+import org.bukkit.Bukkit;
+import org.bukkit.Material;
+import org.bukkit.enchantments.Enchantment;
+import org.bukkit.inventory.meta.ItemMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Map;
+
+// Temporary, soon will move this to the bukkit itemstack class
+public interface ItemStack extends HoverEventSource<HoverEvent.ShowItem>, Translatable, Cloneable {
+
+    @NotNull
+    Material getMaterial();
+
+    // This is behavior that is not officially supported anymore, and shouldn't be either.
+    @Deprecated
+    void setMaterial(@NotNull Material material);
+
+    int getSize();
+
+    void setSize(int size);
+
+    @Nullable
+    ItemMeta getMeta();
+
+    void setMeta(@Nullable ItemMeta meta);
+
+
+}
diff --git a/src/main/java/io/papermc/paper/inventory/item/properties/ItemProperties.java b/src/main/java/io/papermc/paper/inventory/item/properties/ItemProperties.java
new file mode 100644
index 0000000000000000000000000000000000000000..897b797b3760170ffb740bf05d3e05975a839343
--- /dev/null
+++ b/src/main/java/io/papermc/paper/inventory/item/properties/ItemProperties.java
@@ -0,0 +1,118 @@
+package io.papermc.paper.inventory.item.properties;
+
+import io.papermc.paper.math.Position;
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.StoredPropertyHolder;
+import io.papermc.paper.property.value.ListValue;
+import io.papermc.paper.property.value.MapValue;
+import io.papermc.paper.property.value.MultiMapValue;
+import io.papermc.paper.property.value.SetValue;
+import io.papermc.paper.property.value.Value;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Color;
+import org.bukkit.FireworkEffect;
+import org.bukkit.NamespacedKey;
+import org.bukkit.attribute.Attribute;
+import org.bukkit.attribute.AttributeModifier;
+import org.bukkit.enchantments.Enchantment;
+import org.bukkit.entity.Axolotl;
+import org.bukkit.inventory.ItemFlag;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.potion.PotionData;
+import org.bukkit.potion.PotionEffect;
+
+public interface ItemProperties {
+
+    // COMMON
+    PropertyKey<MapValue<Enchantment, Integer>> ENCHANTMENTS = PropertyKey.ofMap("Enchantments", Enchantment.class, Integer.class);
+    PropertyKey<Value<Boolean>> UNBREAKABLE = PropertyKey.of("Unbreakable", Boolean.class);
+    //PropertyKey<> CAN_DESTROY_BLOCK_LIST = PropertyKey.ofSimpleValue("CanDestroy", );
+    //PropertyKey CAN_PLACE_ON_BLOCK_LIST = PropertyKey.ofSimpleValue("CanPlaceOn", );
+    PropertyKey<SetValue<ItemFlag>> HIDE_FLAGS = PropertyKey.ofSet("HideFlags", ItemFlag.class);
+    PropertyKey<Value<Integer>> REPAIR_COST = PropertyKey.of("RepairCost", Integer.class);
+    PropertyKey<Value<Integer>> CUSTOM_MODEL_DATA = PropertyKey.of("CustomModelData", Integer.class);
+    PropertyKey<Value<Integer>> DAMAGE = PropertyKey.of("damage", Integer.class);
+    PropertyKey<MultiMapValue<Attribute, AttributeModifier>> ATTRIBUTES = PropertyKey.ofMultiMap("AttributeModifiers", Attribute.class, AttributeModifier.class);
+    PropertyKey<StoredPropertyHolder> BLOCK_STATE = PropertyKey.ofPropertyHolder("BlockStateTag");
+    PropertyKey<StoredPropertyHolder> ENTITY_TAG = PropertyKey.ofPropertyHolder("EntityTag");
+
+    // DISPLAY PROPERTIES
+    PropertyKey<StoredPropertyHolder> DISPLAY = PropertyKey.ofPropertyHolder("display");
+
+    PropertyKey<Value<Component>> DISPLAY_NAME = PropertyKey.of("Name", Component.class);
+    PropertyKey<ListValue<Component>> LORE = PropertyKey.ofList("Lore", Component.class);
+    PropertyKey<Value<Color>> COLOR = PropertyKey.of("color", Color.class);
+    PropertyKey<Value<Color>> MAP_COLOR = PropertyKey.of("MapColor", Color.class);
+
+    // CUSTOM
+    PropertyKey<StoredPropertyHolder> PUBLIC_BUKKIT_VALUES = PropertyKey.ofPropertyHolder("PublicBukkitValues");
+    @Deprecated(forRemoval = true)
+    PropertyKey<Value<String>> LOC_NAME = PropertyKey.of("LocName", String.class);
+
+
+    // TropicalFishBucketMeta
+    PropertyKey<Value<TropicalFishVariant>> TROPICAL_FISH_BUCKET_VARIANT = PropertyKey.of("BucketVariantTag", TropicalFishVariant.class);
+
+    // SuspiciousStewMeta
+    PropertyKey<ListValue<StewEffect>> STEW_EFFECTS = PropertyKey.ofList("Effects", StewEffect.class);
+
+    // CraftMetaSkull
+    // Can be a STRING or a skull profile
+    PropertyKey<Value<PlayerHeadPartial>> SKULL_OWNER = PropertyKey.of("SkullOwner", PlayerHeadPartial.class);
+    @Deprecated(forRemoval = true)
+    PropertyKey<Value<org.bukkit.profile.PlayerProfile>> SKULL_OWNER_LEGACY_BUKKIT = PropertyKey.of("SkullOwner", org.bukkit.profile.PlayerProfile.class);
+
+    // PotionMeta
+    PropertyKey<Value<PotionData>> DEFAULT_POTION_TYPE = PropertyKey.of("Potion", PotionData.class);
+    PropertyKey<ListValue<PotionEffect>> CUSTOM_POTION_EFFECTS = PropertyKey.ofList("CustomPotionEffects", PotionEffect.class);
+
+    // MapMeta
+    PropertyKey<Value<Integer>> MAP_ID = PropertyKey.of("map", Integer.class);
+    PropertyKey<Value<Byte>> MAP_SCALE_DIRECTION = PropertyKey.of("map_scale_direction", Byte.class);
+    // Unused, really. Marks the map to be locked when crafted
+    PropertyKey<Value<Boolean>> MAP_TO_LOCK = PropertyKey.of("map_to_lock", Boolean.class);
+
+    // KnowledgeBookMeta
+    PropertyKey<ListValue<NamespacedKey>> RECIPES = PropertyKey.ofList("Recipes", NamespacedKey.class);
+
+    // FireworkMeta
+    PropertyKey<Value<Byte>> FLIGHT = PropertyKey.of("Flight", Byte.class);
+    PropertyKey<ListValue<FireworkEffect>> EXPLOSIONS = PropertyKey.ofList("Explosions", FireworkEffect.class);
+
+    // FireworkEffectMeta
+    PropertyKey<Value<FireworkEffect>> EXPLOSION = PropertyKey.of("Explosion", FireworkEffect.class);
+
+    // EnchantmentStorageMeta
+    PropertyKey<MapValue<Enchantment, Integer>> STORED_ENCHANTMENTS = PropertyKey.ofMap("StoredEnchantments", Enchantment.class, Integer.class);
+
+    // CrossbowMeta
+    PropertyKey<Value<Boolean>> CHARGED = PropertyKey.of("Charged", Boolean.class);
+    PropertyKey<ListValue<ItemStack>> CHARGED_PROJECTILES = PropertyKey.ofList("ChargedProjectiles", ItemStack.class);
+
+    // CompassMeta
+    PropertyKey<Value<Position>> LODESTONE_POS = PropertyKey.of("LodestonePos", Position.class);
+    PropertyKey<Value<NamespacedKey>> LODESTONE_DIMENSION = PropertyKey.of("LodestoneDimension", NamespacedKey.class);
+    PropertyKey<Value<Boolean>> LODESTONE_TRACKED = PropertyKey.of("LodestoneTracked", Boolean.class);
+
+    // BundleMeta
+    PropertyKey<ListValue<ItemStack>> ITEMS = PropertyKey.ofList("Items", ItemStack.class);
+
+    // BookMeta
+    PropertyKey<Value<String>> TITLE = PropertyKey.of("title", String.class);
+    PropertyKey<Value<String>> TITLE_FILTERED = PropertyKey.of("filtered_title", String.class);
+    PropertyKey<Value<String>> AUTHOR = PropertyKey.of("author", String.class);
+    PropertyKey<ListValue<Component>> PAGES = PropertyKey.ofList("pages", Component.class);
+    PropertyKey<ListValue<Component>> PAGES_FILTERED = PropertyKey.ofList("filtered_pages", Component.class);
+    PropertyKey<Value<Integer>> GENERATION = PropertyKey.of("generation", Integer.class);
+    PropertyKey<Value<Boolean>> RESOLVED = PropertyKey.of("resolved", Boolean.class);
+
+    // UnsignedBookMeta
+    PropertyKey<ListValue<String>> PAGES_WRITTEN = PropertyKey.ofList("pages", String.class);
+
+    // BlockStateMeta
+    PropertyKey<StoredPropertyHolder> BLOCK_ENTITY_TAG = PropertyKey.ofPropertyHolder("BlockEntityTag");
+
+    // AxolotlBucket
+    PropertyKey<Value<Axolotl.Variant>> VARIANT = PropertyKey.of("Variant", Axolotl.Variant.class);
+
+}
diff --git a/src/main/java/io/papermc/paper/inventory/item/properties/PlayerHeadPartial.java b/src/main/java/io/papermc/paper/inventory/item/properties/PlayerHeadPartial.java
new file mode 100644
index 0000000000000000000000000000000000000000..d2477d57619b689602038ba208d20e5174865735
--- /dev/null
+++ b/src/main/java/io/papermc/paper/inventory/item/properties/PlayerHeadPartial.java
@@ -0,0 +1,8 @@
+package io.papermc.paper.inventory.item.properties;
+
+import com.destroystokyo.paper.profile.PlayerProfile;
+import org.bukkit.potion.PotionEffectType;
+import org.jetbrains.annotations.Nullable;
+
+public record PlayerHeadPartial(@Nullable String playerName, @Nullable PlayerProfile profile) {
+}
diff --git a/src/main/java/io/papermc/paper/inventory/item/properties/StewEffect.java b/src/main/java/io/papermc/paper/inventory/item/properties/StewEffect.java
new file mode 100644
index 0000000000000000000000000000000000000000..38721f6ea05d9014c1ebaeb35ec0ffbed7768234
--- /dev/null
+++ b/src/main/java/io/papermc/paper/inventory/item/properties/StewEffect.java
@@ -0,0 +1,6 @@
+package io.papermc.paper.inventory.item.properties;
+
+import org.bukkit.potion.PotionEffectType;
+
+public record StewEffect(PotionEffectType effect, int duration) {
+}
diff --git a/src/main/java/io/papermc/paper/inventory/item/properties/TropicalFishVariant.java b/src/main/java/io/papermc/paper/inventory/item/properties/TropicalFishVariant.java
new file mode 100644
index 0000000000000000000000000000000000000000..6198f1e633a28b3cc8b977216a98af607b2bedfc
--- /dev/null
+++ b/src/main/java/io/papermc/paper/inventory/item/properties/TropicalFishVariant.java
@@ -0,0 +1,7 @@
+package io.papermc.paper.inventory.item.properties;
+
+import org.bukkit.DyeColor;
+import org.bukkit.entity.TropicalFish;
+
+public record TropicalFishVariant(DyeColor patternColor, DyeColor bodyColor, TropicalFish.Pattern type) {
+}
diff --git a/src/main/java/io/papermc/paper/property/ImmutablePropertyBuilder.java b/src/main/java/io/papermc/paper/property/ImmutablePropertyBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..73dfdd74946b4b0eb3a6f5138e68ed56d8283e09
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/ImmutablePropertyBuilder.java
@@ -0,0 +1,64 @@
+package io.papermc.paper.property;
+
+import io.papermc.paper.property.value.Value;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class ImmutablePropertyBuilder {
+
+    private final Map<PropertyKey<? extends Value<?>>, Value<?>> map = new HashMap<>();
+
+    ImmutablePropertyBuilder() {
+    }
+
+    public <T extends Value<V>, V> ImmutablePropertyBuilder of(PropertyKey<T> key, Value<V> data) {
+        this.map.put(key, data);
+        return this;
+    }
+
+    @SuppressWarnings("unchecked")
+    public PropertyHolder.Immutable build() {
+        return new PropertyHolder.Immutable() {
+            @Override
+            public <T> @Nullable T get(PropertyKey<? extends Value<T>> property) {
+                return (T) ImmutablePropertyBuilder.this.map.get(property).getValue();
+            }
+
+            @Override
+            public <T> @Nullable T getOrDefault(PropertyKey<? extends Value<T>> property, T value) {
+               T val = this.get(property);
+               if (val == null) {
+                   return value;
+               }
+
+               return val;
+            }
+
+            @Override
+            public <E, V extends Value<E>> @Nullable V getValue(PropertyKey<V> property) {
+                return (V) ImmutablePropertyBuilder.this.map.get(property);
+            }
+
+            @Override
+            public <V, T extends Value<V>> @Nullable T getValueOrDefault(PropertyKey<T> key, T value) {
+                T val = this.getValue(key);
+                if (val == null) {
+                    return value;
+                }
+
+                return val;
+            }
+
+            @Override
+            public boolean hasProperty(PropertyKey<?> propertyKey) {
+                return ImmutablePropertyBuilder.this.map.containsKey(propertyKey);
+            }
+        };
+    }
+
+
+    private record Entry<T>(PropertyKey<? extends Value<T>> key, T value) {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/PropertyHolder.java b/src/main/java/io/papermc/paper/property/PropertyHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..3d281c081d3a997455d19e9dd5e86d1806c830b6
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/PropertyHolder.java
@@ -0,0 +1,33 @@
+package io.papermc.paper.property;
+
+import io.papermc.paper.property.value.MapValue;
+import io.papermc.paper.property.value.Value;
+import org.bukkit.enchantments.Enchantment;
+
+import java.util.Map;
+
+// Represents a property reader during runtime
+public interface PropertyHolder extends PropertyReader {
+
+    interface Mutable extends PropertyHolder, Cloneable {
+
+        void set(Value<?> value);
+
+        <T> void unset(PropertyKey<? extends Value<T>> key);
+
+        <T> void set(PropertyKey<? extends Value<T>> key, T value);
+
+        <V, T extends Value<V>> T create(PropertyKey<T> key);
+
+        <V, T extends Value<V>> T getOrCreate(PropertyKey<T> key);
+    }
+
+    interface Immutable extends PropertyHolder {
+
+        public static ImmutablePropertyBuilder builder() {
+            return new ImmutablePropertyBuilder();
+        }
+
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/property/PropertyKey.java b/src/main/java/io/papermc/paper/property/PropertyKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..d18841d965c239973068b33e5b187929df0648ee
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/PropertyKey.java
@@ -0,0 +1,72 @@
+package io.papermc.paper.property;
+
+import com.google.common.collect.Multimap;
+import io.leangen.geantyref.TypeFactory;
+import io.leangen.geantyref.TypeToken;
+import io.papermc.paper.property.value.ListValue;
+import io.papermc.paper.property.value.MapValue;
+import io.papermc.paper.property.value.MultiMapValue;
+import io.papermc.paper.property.value.SetValue;
+import io.papermc.paper.property.value.Value;
+import net.kyori.adventure.text.Component;
+import org.bukkit.attribute.Attributable;
+import org.bukkit.attribute.AttributeModifier;
+
+import java.lang.reflect.Type;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+public interface PropertyKey<T extends Value<?>> {
+
+    static <V> PropertyKey<SetValue<V>> ofSet(String key, TypeToken<V> valueToken) {
+        return new PropertyKeyImpl<>(key, TypeFactory.parameterizedClass(Set.class, valueToken.getType()), TypeFactory.parameterizedClass(SetValue.class, valueToken.getType()));
+    }
+
+    static <V> PropertyKey<SetValue<V>> ofSet(String key, Class<V> valueToken) {
+        return new PropertyKeyImpl<>(key, TypeFactory.parameterizedClass(Set.class, valueToken), TypeFactory.parameterizedClass(SetValue.class, valueToken));
+    }
+
+    static <K, V> PropertyKey<MapValue<K, V>> ofMap(String key, TypeToken<K> keyToken, TypeToken<V> valueToken) {
+        return new PropertyKeyImpl<>(key, TypeFactory.parameterizedClass(Map.class, keyToken.getType(), valueToken.getType()), TypeFactory.parameterizedClass(MapValue.class, keyToken.getType(), valueToken.getType()));
+    }
+
+    static <K, V> PropertyKey<MapValue<K, V>> ofMap(String key, Class<K> keyToken, Class<V> valueToken) {
+        return new PropertyKeyImpl<>(key, TypeFactory.parameterizedClass(Map.class, keyToken, valueToken), TypeFactory.parameterizedClass(MapValue.class, keyToken, valueToken));
+    }
+
+    static <T extends Value<V>, V> PropertyKey<T> of(String key, Class<V> token) {
+        return new PropertyKeyImpl<>(key, token, TypeFactory.parameterizedClass(Value.class, token.getClass()));
+    }
+
+    static <T extends Value<V>, V> PropertyKey<T> of(String key, TypeToken<V> token) {
+        return new PropertyKeyImpl<>(key, token.getType(), TypeFactory.parameterizedClass(Value.class, token.getType()));
+    }
+
+    static PropertyKey<StoredPropertyHolder> ofPropertyHolder(String display) {
+        return new PropertyKeyImpl<>(display, PropertyHolder.class, StoredPropertyHolder.class);
+    }
+
+    static <V> PropertyKey<ListValue<V>> ofList(String key, TypeToken<V> valueToken) {
+        return new PropertyKeyImpl<>(key, TypeFactory.parameterizedClass(List.class, valueToken.getType()), TypeFactory.parameterizedClass(ListValue.class, valueToken.getType()));
+    }
+
+    static <V> PropertyKey<ListValue<V>> ofList(String key, Class<V> valueToken) {
+        return new PropertyKeyImpl<>(key, TypeFactory.parameterizedClass(List.class, valueToken), TypeFactory.parameterizedClass(ListValue.class, valueToken));
+    }
+
+    static <K, V> PropertyKey<MultiMapValue<K, V>> ofMultiMap(String key, TypeToken<K> keyToken, TypeToken<V> valueToken) {
+        return new PropertyKeyImpl<>(key, TypeFactory.parameterizedClass(Multimap.class, keyToken.getType(), valueToken.getType()), TypeFactory.parameterizedClass(MultiMapValue.class, keyToken.getType(), valueToken.getType()));
+    }
+
+    static <K, V> PropertyKey<MultiMapValue<K, V>> ofMultiMap(String key, Class<K> keyToken, Class<V> valueToken) {
+        return new PropertyKeyImpl<>(key, TypeFactory.parameterizedClass(Multimap.class, keyToken, valueToken), TypeFactory.parameterizedClass(MultiMapValue.class, keyToken, valueToken));
+    }
+
+    String getKey();
+
+    Type getValueType();
+
+    Type getPropertyType();
+
+}
diff --git a/src/main/java/io/papermc/paper/property/PropertyKeyImpl.java b/src/main/java/io/papermc/paper/property/PropertyKeyImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..15f34c333778c024554f9beb284981c4bdad91cd
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/PropertyKeyImpl.java
@@ -0,0 +1,24 @@
+package io.papermc.paper.property;
+
+import io.leangen.geantyref.TypeToken;
+import io.papermc.paper.property.value.Value;
+
+import java.lang.reflect.Type;
+
+record PropertyKeyImpl<V, T extends Value<V>>(String key, Type value, Type propertyType) implements PropertyKey<T> {
+
+    @Override
+    public String getKey() {
+        return this.key;
+    }
+
+    @Override
+    public Type getValueType() {
+        return this.value;
+    }
+
+    @Override
+    public Type getPropertyType() {
+        return this.propertyType;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/PropertyReader.java b/src/main/java/io/papermc/paper/property/PropertyReader.java
new file mode 100644
index 0000000000000000000000000000000000000000..1ccbb407279dedba855c0c804689176a8fdeba83
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/PropertyReader.java
@@ -0,0 +1,25 @@
+package io.papermc.paper.property;
+
+import io.papermc.paper.property.value.Value;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.Nullable;
+
+public interface PropertyReader {
+
+    @Nullable
+    <T> T get(PropertyKey<? extends Value<T>> property);
+
+    @Contract("_,!null -> !null")
+    @Nullable
+    <T> T getOrDefault(PropertyKey<? extends Value<T>> property, T value);
+
+    @Nullable
+    <E, V extends Value<E>> V getValue(PropertyKey<V> property);
+
+    @Contract("_,!null -> !null")
+    @Nullable
+    <V, T extends Value<V>> T getValueOrDefault(PropertyKey<T> key, T value);
+
+    boolean hasProperty(PropertyKey<?> propertyKey);
+
+}
diff --git a/src/main/java/io/papermc/paper/property/StoredPropertyHolder.java b/src/main/java/io/papermc/paper/property/StoredPropertyHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..21a48a4b3fdc96664f08c1853159f24f44d79797
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/StoredPropertyHolder.java
@@ -0,0 +1,8 @@
+package io.papermc.paper.property;
+
+import io.papermc.paper.property.value.Value;
+
+// Represents a property reader during runtime
+public interface StoredPropertyHolder extends PropertyHolder.Mutable, Value<PropertyHolder> {
+
+}
diff --git a/src/main/java/io/papermc/paper/property/value/ListValue.java b/src/main/java/io/papermc/paper/property/value/ListValue.java
new file mode 100644
index 0000000000000000000000000000000000000000..376608c6bdffdc71535eb683c4882af072a6806d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/value/ListValue.java
@@ -0,0 +1,20 @@
+package io.papermc.paper.property.value;
+
+import java.util.List;
+
+public interface ListValue<V> extends Value<List<V>>, Iterable<V> {
+
+    V get(int index);
+
+    default boolean isEmpty() {
+        return this.size() == 0;
+    }
+
+    int size();
+
+    void add(V value);
+
+    void insert(V value, int index);
+
+    V remove(int index);
+}
diff --git a/src/main/java/io/papermc/paper/property/value/MapValue.java b/src/main/java/io/papermc/paper/property/value/MapValue.java
new file mode 100644
index 0000000000000000000000000000000000000000..b8d71c04868c127264f30c53ec74d2f2819f8079
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/value/MapValue.java
@@ -0,0 +1,21 @@
+package io.papermc.paper.property.value;
+
+import java.util.Map;
+
+public interface MapValue<K, V> extends Value<Map<K, V>>, Iterable<Map.Entry<K, V>> {
+
+    V getEntry(K key);
+
+    boolean has(K key);
+
+    V put(K key, V value);
+
+    boolean removeEntry(K key);
+
+    default boolean isEmpty() {
+        return this.size() == 0;
+    }
+
+    int size();
+
+}
diff --git a/src/main/java/io/papermc/paper/property/value/MultiMapValue.java b/src/main/java/io/papermc/paper/property/value/MultiMapValue.java
new file mode 100644
index 0000000000000000000000000000000000000000..b52867e8c79fe65662d4ebe82cd19f367c77b9fd
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/value/MultiMapValue.java
@@ -0,0 +1,8 @@
+package io.papermc.paper.property.value;
+
+import com.google.common.collect.Multimap;
+
+import java.util.Map;
+
+public interface MultiMapValue<K, V> extends Value<Multimap<K, V>> {
+}
diff --git a/src/main/java/io/papermc/paper/property/value/SetValue.java b/src/main/java/io/papermc/paper/property/value/SetValue.java
new file mode 100644
index 0000000000000000000000000000000000000000..c4ccabf3ad96ed6e83c0ed2096cdd62d8940e449
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/value/SetValue.java
@@ -0,0 +1,12 @@
+package io.papermc.paper.property.value;
+
+import java.util.Set;
+
+public interface SetValue<V> extends Value<Set<V>> {
+
+    boolean contains(V value);
+
+    void add(V value);
+
+    void remove(V value);
+}
diff --git a/src/main/java/io/papermc/paper/property/value/Value.java b/src/main/java/io/papermc/paper/property/value/Value.java
new file mode 100644
index 0000000000000000000000000000000000000000..fab6096d1e0edece524f62bcf09990c3ab897b2d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/value/Value.java
@@ -0,0 +1,12 @@
+package io.papermc.paper.property.value;
+
+import io.papermc.paper.property.PropertyKey;
+import org.jetbrains.annotations.Nullable;
+
+public interface Value<T> {
+
+    @Nullable
+    T getValue();
+
+    PropertyKey<? extends Value<T>> getKey();
+}
diff --git a/src/main/java/io/papermc/paper/property/value/handler/PropertyValueHandler.java b/src/main/java/io/papermc/paper/property/value/handler/PropertyValueHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..46fb5f54feeefc7cf954bec257bff0a682fae3ff
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/value/handler/PropertyValueHandler.java
@@ -0,0 +1,4 @@
+package io.papermc.paper.property.value.handler;
+
+public interface PropertyValueHandler {
+}
diff --git a/src/main/java/org/bukkit/UnsafeValues.java b/src/main/java/org/bukkit/UnsafeValues.java
index 854be548e5a645e7312e6e9390d5255f8b1d61e6..6c98a9c0f7dee0c737b66f7c4d6919ef6a6ac126 100644
--- a/src/main/java/org/bukkit/UnsafeValues.java
+++ b/src/main/java/org/bukkit/UnsafeValues.java
@@ -270,5 +270,9 @@ public interface UnsafeValues {
      * @throws IllegalStateException if no biome by the given key is registered.
      */
     void setBiomeKey(RegionAccessor accessor, int x, int y, int z, NamespacedKey biomeKey);
+
+    io.papermc.paper.property.PropertyHolder.Mutable getPropertyHolder(ItemStack itemStack);
+
+    ItemStack newItem(org.bukkit.Material material, int count);
     // Paper end
 }
diff --git a/src/main/java/org/bukkit/inventory/ItemStack.java b/src/main/java/org/bukkit/inventory/ItemStack.java
index 870c0ddd101094a3bce1ebf5ec4d42c51053db84..31dea7f23c635ddfd716903595189e30190d31f6 100644
--- a/src/main/java/org/bukkit/inventory/ItemStack.java
+++ b/src/main/java/org/bukkit/inventory/ItemStack.java
@@ -991,5 +991,10 @@ public class ItemStack implements Cloneable, ConfigurationSerializable, net.kyor
     public @NotNull ItemStack damage(int amount, @NotNull org.bukkit.entity.LivingEntity livingEntity) {
         return livingEntity.damageItemStack(this, amount);
     }
+
+
+    public io.papermc.paper.property.PropertyHolder.Mutable getPropertyHolder() {
+        return Bukkit.getUnsafe().getPropertyHolder(this);
+    }
     // Paper end
 }
diff --git a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
index cb3c25ef46b279ffdde87f47f729eb8aa7549c1c..5247daad3356d23c193f8fc93225c98ed6f201c4 100644
--- a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
@@ -2,6 +2,12 @@ package org.bukkit.plugin.java;
 
 import com.google.common.base.Preconditions;
 import com.google.common.io.ByteStreams;
+import org.bukkit.plugin.InvalidPluginException;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.SimplePluginManager;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
@@ -20,11 +26,6 @@ import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
 import java.util.logging.Level;
-import org.bukkit.plugin.InvalidPluginException;
-import org.bukkit.plugin.PluginDescriptionFile;
-import org.bukkit.plugin.SimplePluginManager;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
 
 /**
  * A ClassLoader for plugins, to allow shared classes across multiple plugins
@@ -66,6 +67,24 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
         this.logger = com.destroystokyo.paper.utils.PaperPluginLogger.getLogger(description); // Paper - Register logger early
 
         try {
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
             Class<?> jarClass;
             try {
                 jarClass = Class.forName(description.getMain(), true, this);
