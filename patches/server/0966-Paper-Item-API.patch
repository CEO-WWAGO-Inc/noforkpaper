From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Mon, 17 Oct 2022 18:00:34 -0400
Subject: [PATCH] Paper Item API

== AT ==
public net.minecraft.nbt.ListTag list

diff --git a/src/main/java/io/papermc/paper/inventory/item/PaperItemStack.java b/src/main/java/io/papermc/paper/inventory/item/PaperItemStack.java
new file mode 100644
index 0000000000000000000000000000000000000000..e15c4ae271e67e95fc8e6902e1ca80b17a139063
--- /dev/null
+++ b/src/main/java/io/papermc/paper/inventory/item/PaperItemStack.java
@@ -0,0 +1,43 @@
+package io.papermc.paper.inventory.item;
+
+import com.destroystokyo.paper.MaterialTags;
+import io.papermc.paper.item.meta.MetaAxolotlBucket;
+import io.papermc.paper.item.meta.MetaBanner;
+import io.papermc.paper.item.meta.MetaBlockState;
+import io.papermc.paper.item.meta.MetaBookSigned;
+import io.papermc.paper.item.meta.MetaBundle;
+import io.papermc.paper.item.meta.MetaCompass;
+import io.papermc.paper.item.meta.MetaEnchantmentStorage;
+import io.papermc.paper.item.meta.MetaFirework;
+import io.papermc.paper.item.meta.MetaFireworkEffect;
+import io.papermc.paper.item.meta.MetaKnowledgeBook;
+import io.papermc.paper.item.meta.MetaMap;
+import io.papermc.paper.item.meta.MetaMusicInstrument;
+import io.papermc.paper.item.meta.MetaPlayerHead;
+import io.papermc.paper.item.meta.MetaPotion;
+import io.papermc.paper.item.meta.MetaSpawnEgg;
+import io.papermc.paper.item.meta.MetaSuspiciousStew;
+import io.papermc.paper.item.meta.MetaTropicalFishBucket;
+import io.papermc.paper.item.meta.PaperMeta;
+import io.papermc.paper.property.MutablePropertyView;
+import net.minecraft.world.item.Items;
+import org.bukkit.Material;
+import org.bukkit.Tag;
+import org.bukkit.craftbukkit.block.CraftBlockStates;
+import org.bukkit.inventory.meta.ItemMeta;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+
+public class PaperItemStack {
+
+
+    public static net.minecraft.world.item.ItemStack asVanillaCopy(io.papermc.paper.inventory.item.ItemStack paperItemStack) {
+        return new net.minecraft.world.item.ItemStack(Items.STONE);
+    }
+
+
+}
diff --git a/src/main/java/io/papermc/paper/inventory/item/VanillaItemStack.java b/src/main/java/io/papermc/paper/inventory/item/VanillaItemStack.java
new file mode 100644
index 0000000000000000000000000000000000000000..7ce4f52240a560edb1198b26a966d31614b57d2e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/inventory/item/VanillaItemStack.java
@@ -0,0 +1,64 @@
+package io.papermc.paper.inventory.item;
+
+import io.papermc.paper.adventure.PaperAdventure;
+import net.kyori.adventure.key.Key;
+import net.kyori.adventure.text.event.HoverEvent;
+import net.minecraft.world.item.Item;
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.inventory.meta.ItemMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.function.UnaryOperator;
+
+public class VanillaItemStack implements ItemStack {
+
+    private final net.minecraft.world.item.ItemStack itemStack;
+
+    public VanillaItemStack(@NotNull net.minecraft.world.item.ItemStack vanilla) {
+        this.itemStack = vanilla;
+    }
+
+    @Override
+    public @NotNull Material getMaterial() {
+        return CraftMagicNumbers.getMaterial(this.itemStack.getItem());
+    }
+
+    @Override
+    public void setMaterial(@NotNull Material material) {
+        this.itemStack.setItem(CraftMagicNumbers.getItem(material));
+    }
+
+    @Override
+    public int getSize() {
+        return this.itemStack.getCount();
+    }
+
+    @Override
+    public void setSize(int size) {
+        this.itemStack.setCount(size);
+    }
+
+    @Override
+    public @Nullable ItemMeta getMeta() {
+        return null;
+    }
+
+    @Override
+    public void setMeta(@Nullable ItemMeta meta) {
+
+    }
+
+    @Override
+    public @NotNull HoverEvent<HoverEvent.ShowItem> asHoverEvent(@NotNull UnaryOperator<HoverEvent.ShowItem> op) {
+        Key key = CraftMagicNumbers.getMaterial(this.itemStack.getItem()).getKey();
+
+        return HoverEvent.showItem(op.apply(HoverEvent.ShowItem.of(key, this.itemStack.getCount(), PaperAdventure.asBinaryTagHolder(this.itemStack.getTag()))));
+    }
+
+    @Override
+    public @NotNull String translationKey() {
+        return null;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/PaperMetaRegistry.java b/src/main/java/io/papermc/paper/item/PaperMetaRegistry.java
new file mode 100644
index 0000000000000000000000000000000000000000..03034495818a32889a7266f2844e12cc1c7c5e83
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/PaperMetaRegistry.java
@@ -0,0 +1,325 @@
+package io.papermc.paper.item;
+
+import io.papermc.paper.item.meta.MetaAxolotlBucket;
+import io.papermc.paper.item.meta.MetaBanner;
+import io.papermc.paper.item.meta.MetaBlockState;
+import io.papermc.paper.item.meta.MetaBookSigned;
+import io.papermc.paper.item.meta.MetaBundle;
+import io.papermc.paper.item.meta.MetaCompass;
+import io.papermc.paper.item.meta.MetaEnchantmentStorage;
+import io.papermc.paper.item.meta.MetaFirework;
+import io.papermc.paper.item.meta.MetaFireworkEffect;
+import io.papermc.paper.item.meta.MetaKnowledgeBook;
+import io.papermc.paper.item.meta.MetaLeatherArmor;
+import io.papermc.paper.item.meta.MetaMap;
+import io.papermc.paper.item.meta.MetaMusicInstrument;
+import io.papermc.paper.item.meta.MetaPlayerHead;
+import io.papermc.paper.item.meta.MetaPotion;
+import io.papermc.paper.item.meta.MetaSpawnEgg;
+import io.papermc.paper.item.meta.MetaSuspiciousStew;
+import io.papermc.paper.item.meta.MetaTropicalFishBucket;
+import io.papermc.paper.item.meta.PaperMeta;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Material;
+import org.bukkit.inventory.meta.ItemMeta;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+
+public class PaperMetaRegistry {
+
+    public static ItemMeta getItemMeta(MutablePropertyView propertyHolder, Material material) {
+        MetaSupplier supplier = SUPPLIERS.get(material);
+        return Objects.requireNonNullElse(supplier, DEFAULT_META).create(propertyHolder, material);
+    }
+
+    // Registry
+    interface MetaSupplier {
+        ItemMeta create(MutablePropertyView view, Material material);
+    }
+
+    public static final MetaSupplier DEFAULT_META = PaperMeta::new;
+    public static final Map<Material, MetaSupplier> SUPPLIERS = new HashMap<>();
+
+    static {
+        register(Material.WRITTEN_BOOK, MetaBookSigned::new);
+        register(Material.WRITABLE_BOOK, MetaBookSigned::new);
+        //register(MaterialTags.SKULLS.getValues(), MetaPlayerHead::new);
+        register(List.of(Material.CREEPER_HEAD,
+            Material.CREEPER_WALL_HEAD,
+            Material.DRAGON_HEAD,
+            Material.DRAGON_WALL_HEAD,
+            Material.PIGLIN_HEAD,
+            Material.PIGLIN_WALL_HEAD,
+            Material.PLAYER_HEAD,
+            Material.PLAYER_WALL_HEAD,
+            Material.SKELETON_SKULL,
+            Material.SKELETON_WALL_SKULL,
+            Material.WITHER_SKELETON_SKULL,
+            Material.WITHER_SKELETON_WALL_SKULL,
+            Material.ZOMBIE_HEAD,
+            Material.ZOMBIE_WALL_HEAD), MetaPlayerHead::new);
+        register(List.of(Material.LEATHER_HELMET,
+            Material.LEATHER_HORSE_ARMOR,
+            Material.LEATHER_CHESTPLATE,
+            Material.LEATHER_LEGGINGS,
+            Material.LEATHER_BOOTS), MetaLeatherArmor::new);
+        register(List.of(Material.POTION,
+            Material.SPLASH_POTION,
+            Material.LINGERING_POTION,
+            Material.TIPPED_ARROW), MetaPotion::new);
+        register(Material.FILLED_MAP, MetaMap::new);
+        register(Material.FIREWORK_ROCKET, MetaFirework::new);
+        register(Material.FIREWORK_STAR, MetaFireworkEffect::new);
+        register(Material.ENCHANTED_BOOK, MetaEnchantmentStorage::new);
+        register(List.of(
+            Material.BLACK_BANNER,
+            Material.BLACK_WALL_BANNER,
+            Material.BLUE_BANNER,
+            Material.BLUE_WALL_BANNER,
+            Material.BROWN_BANNER,
+            Material.BROWN_WALL_BANNER,
+            Material.CYAN_BANNER,
+            Material.CYAN_WALL_BANNER,
+            Material.GRAY_BANNER,
+            Material.GRAY_WALL_BANNER,
+            Material.GREEN_BANNER,
+            Material.GREEN_WALL_BANNER,
+            Material.LIGHT_BLUE_BANNER,
+            Material.LIGHT_BLUE_WALL_BANNER,
+            Material.LIGHT_GRAY_BANNER,
+            Material.LIGHT_GRAY_WALL_BANNER,
+            Material.LIME_BANNER,
+            Material.LIME_WALL_BANNER,
+            Material.MAGENTA_BANNER,
+            Material.MAGENTA_WALL_BANNER,
+            Material.ORANGE_BANNER,
+            Material.ORANGE_WALL_BANNER,
+            Material.PINK_BANNER,
+            Material.PINK_WALL_BANNER,
+            Material.PURPLE_BANNER,
+            Material.PURPLE_WALL_BANNER,
+            Material.RED_BANNER,
+            Material.RED_WALL_BANNER,
+            Material.WHITE_BANNER,
+            Material.WHITE_WALL_BANNER,
+            Material.YELLOW_BANNER,
+            Material.YELLOW_WALL_BANNER
+        ), MetaBanner::new);
+//        register(MaterialTags.BANNERS.getValues(), MetaBanner::new);
+//        register(MaterialTags.SPAWN_EGGS.getValues(), MetaSpawnEgg::new);
+
+        register(List.of(Material.ALLAY_SPAWN_EGG,
+            Material.AXOLOTL_SPAWN_EGG,
+            Material.BAT_SPAWN_EGG,
+            Material.BEE_SPAWN_EGG,
+            Material.BLAZE_SPAWN_EGG,
+            Material.CAT_SPAWN_EGG,
+            Material.CAMEL_SPAWN_EGG,
+            Material.CAVE_SPIDER_SPAWN_EGG,
+            Material.CHICKEN_SPAWN_EGG,
+            Material.COD_SPAWN_EGG,
+            Material.COW_SPAWN_EGG,
+            Material.CREEPER_SPAWN_EGG,
+            Material.DOLPHIN_SPAWN_EGG,
+            Material.DONKEY_SPAWN_EGG,
+            Material.DROWNED_SPAWN_EGG,
+            Material.ELDER_GUARDIAN_SPAWN_EGG,
+            Material.ENDER_DRAGON_SPAWN_EGG,
+            Material.ENDERMAN_SPAWN_EGG,
+            Material.ENDERMITE_SPAWN_EGG,
+            Material.EVOKER_SPAWN_EGG,
+            Material.FOX_SPAWN_EGG,
+            Material.FROG_SPAWN_EGG,
+            Material.GHAST_SPAWN_EGG,
+            Material.GLOW_SQUID_SPAWN_EGG,
+            Material.GOAT_SPAWN_EGG,
+            Material.GUARDIAN_SPAWN_EGG,
+            Material.HOGLIN_SPAWN_EGG,
+            Material.HORSE_SPAWN_EGG,
+            Material.HUSK_SPAWN_EGG,
+            Material.IRON_GOLEM_SPAWN_EGG,
+            Material.LLAMA_SPAWN_EGG,
+            Material.MAGMA_CUBE_SPAWN_EGG,
+            Material.MOOSHROOM_SPAWN_EGG,
+            Material.MULE_SPAWN_EGG,
+            Material.OCELOT_SPAWN_EGG,
+            Material.PANDA_SPAWN_EGG,
+            Material.PARROT_SPAWN_EGG,
+            Material.PHANTOM_SPAWN_EGG,
+            Material.PIGLIN_BRUTE_SPAWN_EGG,
+            Material.PIGLIN_SPAWN_EGG,
+            Material.PIG_SPAWN_EGG,
+            Material.PILLAGER_SPAWN_EGG,
+            Material.POLAR_BEAR_SPAWN_EGG,
+            Material.PUFFERFISH_SPAWN_EGG,
+            Material.RABBIT_SPAWN_EGG,
+            Material.RAVAGER_SPAWN_EGG,
+            Material.SALMON_SPAWN_EGG,
+            Material.SHEEP_SPAWN_EGG,
+            Material.SHULKER_SPAWN_EGG,
+            Material.SILVERFISH_SPAWN_EGG,
+            Material.SKELETON_HORSE_SPAWN_EGG,
+            Material.SKELETON_SPAWN_EGG,
+            Material.SLIME_SPAWN_EGG,
+            Material.SNIFFER_SPAWN_EGG,
+            Material.SNOW_GOLEM_SPAWN_EGG,
+            Material.SPIDER_SPAWN_EGG,
+            Material.SQUID_SPAWN_EGG,
+            Material.STRAY_SPAWN_EGG,
+            Material.STRIDER_SPAWN_EGG,
+            Material.TADPOLE_SPAWN_EGG,
+            Material.TRADER_LLAMA_SPAWN_EGG,
+            Material.TROPICAL_FISH_SPAWN_EGG,
+            Material.TURTLE_SPAWN_EGG,
+            Material.VEX_SPAWN_EGG,
+            Material.VILLAGER_SPAWN_EGG,
+            Material.VINDICATOR_SPAWN_EGG,
+            Material.WARDEN_SPAWN_EGG,
+            Material.WANDERING_TRADER_SPAWN_EGG,
+            Material.WITCH_SPAWN_EGG,
+            Material.WITHER_SPAWN_EGG,
+            Material.WITHER_SKELETON_SPAWN_EGG,
+            Material.WOLF_SPAWN_EGG,
+            Material.ZOGLIN_SPAWN_EGG,
+            Material.ZOMBIE_HORSE_SPAWN_EGG,
+            Material.ZOMBIE_SPAWN_EGG,
+            Material.ZOMBIE_VILLAGER_SPAWN_EGG,
+            Material.ZOMBIFIED_PIGLIN_SPAWN_EGG), MetaSpawnEgg::new);
+        register(Material.ARMOR_STAND, DEFAULT_META); // Todo
+        register(Material.KNOWLEDGE_BOOK, MetaKnowledgeBook::new);
+
+        // Block entities
+        // TODO: Figure out how to dynamically add
+//        for (Material blockEntity : CraftBlockStates.FACTORIES.keySet()) {
+//            // Ignore skulls, banners, they have their own meta
+//            if (!MaterialTags.SKULLS.isTagged(blockEntity) && !MaterialTags.BANNERS.isTagged(blockEntity)) {
+//                register(blockEntity, MetaBlockState::new);
+//            }
+//        }
+        register(List.of(
+            Material.SHULKER_BOX,
+            Material.WHITE_SHULKER_BOX,
+            Material.ORANGE_SHULKER_BOX,
+            Material.MAGENTA_SHULKER_BOX,
+            Material.LIGHT_BLUE_SHULKER_BOX,
+            Material.YELLOW_SHULKER_BOX,
+            Material.LIME_SHULKER_BOX,
+            Material.PINK_SHULKER_BOX,
+            Material.GRAY_SHULKER_BOX,
+            Material.LIGHT_GRAY_SHULKER_BOX,
+            Material.CYAN_SHULKER_BOX,
+            Material.PURPLE_SHULKER_BOX,
+            Material.BLUE_SHULKER_BOX,
+            Material.BROWN_SHULKER_BOX,
+            Material.GREEN_SHULKER_BOX,
+            Material.RED_SHULKER_BOX,
+            Material.BLACK_SHULKER_BOX,
+            Material.FURNACE,
+            Material.CHEST,
+            Material.TRAPPED_CHEST,
+            Material.JUKEBOX,
+            Material.DISPENSER,
+            Material.DROPPER,
+            Material.ACACIA_HANGING_SIGN,
+            Material.ACACIA_SIGN,
+            Material.ACACIA_WALL_HANGING_SIGN,
+            Material.ACACIA_WALL_SIGN,
+            Material.BAMBOO_HANGING_SIGN,
+            Material.BAMBOO_SIGN,
+            Material.BAMBOO_WALL_HANGING_SIGN,
+            Material.BAMBOO_WALL_SIGN,
+            Material.BIRCH_HANGING_SIGN,
+            Material.BIRCH_SIGN,
+            Material.BIRCH_WALL_HANGING_SIGN,
+            Material.BIRCH_WALL_SIGN,
+            Material.CHERRY_HANGING_SIGN,
+            Material.CHERRY_SIGN,
+            Material.CHERRY_WALL_HANGING_SIGN,
+            Material.CHERRY_WALL_SIGN,
+            Material.CRIMSON_HANGING_SIGN,
+            Material.CRIMSON_SIGN,
+            Material.CRIMSON_WALL_HANGING_SIGN,
+            Material.CRIMSON_WALL_SIGN,
+            Material.DARK_OAK_HANGING_SIGN,
+            Material.DARK_OAK_SIGN,
+            Material.DARK_OAK_WALL_HANGING_SIGN,
+            Material.DARK_OAK_WALL_SIGN,
+            Material.JUNGLE_HANGING_SIGN,
+            Material.JUNGLE_SIGN,
+            Material.JUNGLE_WALL_HANGING_SIGN,
+            Material.JUNGLE_WALL_SIGN,
+            Material.MANGROVE_HANGING_SIGN,
+            Material.MANGROVE_SIGN,
+            Material.MANGROVE_WALL_HANGING_SIGN,
+            Material.MANGROVE_WALL_SIGN,
+            Material.OAK_HANGING_SIGN,
+            Material.OAK_SIGN,
+            Material.OAK_WALL_HANGING_SIGN,
+            Material.OAK_WALL_SIGN,
+            Material.SPRUCE_HANGING_SIGN,
+            Material.SPRUCE_SIGN,
+            Material.SPRUCE_WALL_HANGING_SIGN,
+            Material.SPRUCE_WALL_SIGN,
+            Material.WARPED_HANGING_SIGN,
+            Material.WARPED_SIGN,
+            Material.WARPED_WALL_HANGING_SIGN,
+            Material.WARPED_WALL_SIGN,
+            Material.SPAWNER,
+            Material.BREWING_STAND,
+            Material.ENCHANTING_TABLE,
+            Material.COMMAND_BLOCK,
+            Material.REPEATING_COMMAND_BLOCK,
+            Material.CHAIN_COMMAND_BLOCK,
+            Material.BEACON,
+            Material.DAYLIGHT_DETECTOR,
+            Material.HOPPER,
+            Material.COMPARATOR,
+            Material.SHIELD,
+            Material.STRUCTURE_BLOCK,
+            Material.ENDER_CHEST,
+            Material.BARREL,
+            Material.BELL,
+            Material.BLAST_FURNACE,
+            Material.CAMPFIRE,
+            Material.SOUL_CAMPFIRE,
+            Material.JIGSAW,
+            Material.LECTERN,
+            Material.SMOKER,
+            Material.BEEHIVE,
+            Material.BEE_NEST,
+            Material.SCULK_CATALYST,
+            Material.SCULK_SHRIEKER,
+            Material.SCULK_SENSOR,
+            Material.CHISELED_BOOKSHELF,
+            Material.DECORATED_POT,
+            Material.SUSPICIOUS_SAND
+        ), MetaBlockState::new);
+
+        register(Material.TROPICAL_FISH_BUCKET, MetaTropicalFishBucket::new);
+        register(Material.AXOLOTL_BUCKET, MetaAxolotlBucket::new);
+        register(Material.SUSPICIOUS_STEW, MetaSuspiciousStew::new);
+        register(Material.COMPASS, MetaCompass::new);
+        register(Material.BUNDLE, MetaBundle::new);
+        register(Material.GOAT_HORN, MetaMusicInstrument::new);
+    }
+
+
+    static void register(Collection<Material> materials, MetaSupplier supplier) {
+        for (Material material : materials) {
+            register(material, supplier);
+        }
+    }
+
+    static void register(Material material, MetaSupplier supplier) {
+        if (SUPPLIERS.containsKey(material)) {
+            throw new IllegalArgumentException("Provided duplicate material " + material);
+        }
+
+        SUPPLIERS.put(material, supplier);
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/item/PaperMetaSerialization.java b/src/main/java/io/papermc/paper/item/PaperMetaSerialization.java
new file mode 100644
index 0000000000000000000000000000000000000000..3b842ca96040e9d2b6754e740d8696b58f0f9ce7
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/PaperMetaSerialization.java
@@ -0,0 +1,81 @@
+package io.papermc.paper.item;
+
+import io.papermc.paper.item.meta.PaperMeta;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.world.item.Items;
+import org.bukkit.Bukkit;
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.ItemMeta;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.util.Base64;
+import java.util.HashMap;
+import java.util.Map;
+
+/*
+This is meant to convert the legacy manually upkept bukkit crud into a minecraft backed format.
+
+This will delegate the legacy serialization logic onto the old meta classes, and then will
+convert them to the paper meta class.
+
+When serializing, we will serialize with type "PAPER_META" and simply write a dummy item into the storage.
+This allows us to store in the NBT default format, and have auto version updating.... preventing us from upkeeping our own format.
+ */
+public class PaperMetaSerialization {
+
+    // Convert the craft meta into a paper meta
+    public static ItemMeta deserialize(String type, Constructor<? extends CraftMetaItem> constructor, Map<String, Object> map) throws Throwable {
+        if (type.equals("PAPER_META")) {
+            // Represents our custom paper meta type
+            String blob = (String) map.get("blob");
+            // Decode the meta
+            return Bukkit.getUnsafe().deserializeItem(Base64.getDecoder().decode(blob)).getItemMeta();
+        }
+
+        if (constructor == null) {
+            throw new IllegalArgumentException(type + " is not a valid meta type");
+        }
+
+        try {
+            // CONVERT LEGACY META ITEM
+            constructor.setAccessible(true);
+            return convertBukkitToPaper(constructor.newInstance(map));
+        } catch (final InstantiationException | IllegalAccessException e) {
+            throw new AssertionError(e);
+        } catch (final InvocationTargetException e) {
+            throw e.getCause();
+        }
+    }
+
+    // We need to serialize metadata under our own "custom" metadata.
+    public static Map<String, Object> serialize(PaperMeta paperMeta) {
+        Map<String, Object> meta = new HashMap<>();
+        meta.put("meta-type", "PAPER_META");
+
+        CraftItemStack itemStack = CraftItemStack.asCraftCopy(new ItemStack(paperMeta.getMaterial()));
+        // Manually set the tag, bypassing any sort of checks
+        itemStack.handle.setTag(paperMeta.getPropertyHolder().getCompoundTag());
+        // Serialze the itemstack.
+        // We really don't care about the type/count, we just want to be able to serialize the main data in order to use the
+        // datafixer system
+        meta.put("blob", Base64.getEncoder().encodeToString(Bukkit.getUnsafe().serializeItem(itemStack)));
+
+        return meta;
+    }
+
+    public static Map<String, Object> serialize(CraftMetaItem paperMeta) {
+        return serialize(convertBukkitToPaper(paperMeta));
+    }
+
+    public static PaperMeta convertBukkitToPaper(CraftMetaItem meta) {
+        CompoundTag compoundTag = new CompoundTag();
+        meta.apply(compoundTag);
+
+        return new PaperMeta(io.papermc.paper.property.nbt.NbtPropertyHolder.itemHolder(compoundTag), Material.STONE);
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaAxolotlBucket.java b/src/main/java/io/papermc/paper/item/meta/MetaAxolotlBucket.java
new file mode 100644
index 0000000000000000000000000000000000000000..396d651a9c45042c58bf64586e67f8cd8069c239
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaAxolotlBucket.java
@@ -0,0 +1,70 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.entity.Axolotl;
+import org.bukkit.inventory.meta.AxolotlBucketMeta;
+import org.jetbrains.annotations.NotNull;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaAxolotlBucket extends PaperMeta implements AxolotlBucketMeta {
+
+    public MetaAxolotlBucket(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public @NotNull Axolotl.Variant getVariant() {
+        return this.propertyHolder.get(ItemProperties.VARIANT);
+    }
+
+    @Override
+    public void setVariant(Axolotl.@NotNull Variant variant) {
+        this.propertyHolder.set(ItemProperties.VARIANT, variant);
+    }
+
+    @Override
+    public boolean hasVariant() {
+        return this.propertyHolder.hasProperty(ItemProperties.VARIANT);
+    }
+
+    @Override
+    public @NotNull MetaAxolotlBucket clone() {
+        return new MetaAxolotlBucket(this.propertyHolder.clone(), material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.propertyHolder.unset(ItemProperties.VARIANT);
+        this.propertyHolder.unset(ItemProperties.ENTITY_TAG);
+    }
+
+    // Equality logic
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isBucketEmpty();
+    }
+
+    boolean isBucketEmpty() {
+        return !(this.hasVariant() || this.propertyHolder.get(ItemProperties.ENTITY_TAG) != null);
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaAxolotlBucket that) {
+            return (this.hasVariant() ? that.hasVariant() && this.getVariant().equals(that.getVariant()) : !that.hasVariant()) && (this.propertyHolder.get(ItemProperties.ENTITY_TAG) != null ? that.propertyHolder.get(ItemProperties.ENTITY_TAG) != null && this.propertyHolder.get(ItemProperties.ENTITY_TAG).equals(that.propertyHolder.get(ItemProperties.ENTITY_TAG)) : that.propertyHolder.get(ItemProperties.ENTITY_TAG) == null);
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaAxolotlBucket || this.isBucketEmpty());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaBanner.java b/src/main/java/io/papermc/paper/item/meta/MetaBanner.java
new file mode 100644
index 0000000000000000000000000000000000000000..c7cf2b32e5dae65e05516dd9629bff3fea1cc63f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaBanner.java
@@ -0,0 +1,113 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.DyeColor;
+import org.bukkit.Material;
+import org.bukkit.block.banner.Pattern;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.BannerMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.List;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaBanner extends PaperMeta implements BannerMeta {
+
+    public MetaBanner(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public @NotNull MetaBanner clone() {
+        return new MetaBanner(this.propertyHolder.clone(), material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.propertyHolder.unset(ItemProperties.BLOCK_ENTITY_TAG);
+    }
+
+    @Override
+    public @Nullable DyeColor getBaseColor() {
+        return this.getFromPropertyPath(ItemProperties.BLOCK_ENTITY_TAG, PaperMetaProperties.BASE);
+    }
+
+    @Override
+    public void setBaseColor(@Nullable DyeColor color) {
+        this.setFromPropertyPath(ItemProperties.BLOCK_ENTITY_TAG, PaperMetaProperties.BASE, color);
+    }
+
+    @Override
+    public @NotNull List<Pattern> getPatterns() {
+        return this.getFromPropertyPathOrElse(ItemProperties.BLOCK_ENTITY_TAG, PaperMetaProperties.PATTERNS, List.of());
+    }
+
+    @Override
+    public void setPatterns(@NotNull List<Pattern> patterns) {
+        this.setFromPropertyPath(ItemProperties.BLOCK_ENTITY_TAG, PaperMetaProperties.PATTERNS, patterns);
+    }
+
+    @Override
+    public void addPattern(@NotNull Pattern pattern) {
+        MutablePropertyView holder = this.propertyHolder.getOrCreate(ItemProperties.BLOCK_ENTITY_TAG);
+        List<Pattern> patterns = holder.getOrCreate(PaperMetaProperties.PATTERNS);
+        patterns.add(pattern);
+    }
+
+    @Override
+    public @NotNull Pattern getPattern(int i) {
+        MutablePropertyView holder = this.propertyHolder.getOrCreate(ItemProperties.BLOCK_ENTITY_TAG);
+        List<Pattern> patterns = holder.getOrCreate(PaperMetaProperties.PATTERNS);
+        return patterns.get(i);
+    }
+
+    @Override
+    public @NotNull Pattern removePattern(int i) {
+        MutablePropertyView holder = this.propertyHolder.getOrCreate(ItemProperties.BLOCK_ENTITY_TAG);
+        List<Pattern> patterns = holder.getOrCreate(PaperMetaProperties.PATTERNS);
+
+        return patterns.remove(i);
+    }
+
+    @Override
+    public void setPattern(int i, @NotNull Pattern pattern) {
+        MutablePropertyView holder = this.propertyHolder.getOrCreate(ItemProperties.BLOCK_ENTITY_TAG);
+        List<Pattern> patterns = holder.getOrCreate(PaperMetaProperties.PATTERNS);
+
+        patterns.set(i, pattern);
+    }
+
+    @Override
+    public int numberOfPatterns() {
+        MutablePropertyView holder = this.propertyHolder.getOrCreate(ItemProperties.BLOCK_ENTITY_TAG);
+        List<Pattern> patterns = holder.getOrCreate(PaperMetaProperties.PATTERNS);
+
+        return patterns.size();
+    }
+
+    // Equality logic
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaBanner that) {
+            return this.getBaseColor() == that.getBaseColor() && this.getPatterns().equals(that.getPatterns());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaBanner || (this.getPatterns().isEmpty() && this.getBaseColor() == null));
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.getPatterns().isEmpty() && this.getBaseColor() == null;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaBlockState.java b/src/main/java/io/papermc/paper/item/meta/MetaBlockState.java
new file mode 100644
index 0000000000000000000000000000000000000000..72386ae8e0f85a3abc05709fbeabf2c55aa2fb0b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaBlockState.java
@@ -0,0 +1,129 @@
+package io.papermc.paper.item.meta;
+
+import com.destroystokyo.paper.MaterialSetTag;
+import com.google.common.base.Objects;
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import io.papermc.paper.property.nbt.AdapterContext;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import org.apache.commons.lang.Validate;
+import org.bukkit.DyeColor;
+import org.bukkit.Material;
+import org.bukkit.block.BlockState;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.block.CraftBanner;
+import org.bukkit.craftbukkit.block.CraftBlockEntityState;
+import org.bukkit.craftbukkit.block.CraftBlockStates;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.BlockStateMeta;
+import org.jetbrains.annotations.NotNull;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaBlockState extends PaperMeta implements BlockStateMeta {
+
+    public MetaBlockState(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public boolean hasBlockState() {
+        return this.propertyHolder.hasProperty(ItemProperties.BLOCK_ENTITY_TAG);
+    }
+
+    @Override
+    public BlockState getBlockState() {
+        MutablePropertyView holder = this.propertyHolder.get(ItemProperties.BLOCK_ENTITY_TAG);
+
+        Material stateMaterial = (this.material != Material.SHIELD) ? this.material : shieldToBannerHack(holder); // Only actually used for jigsaws
+        if (holder != null) {
+            if (this.material == Material.SHIELD) {
+                holder.set(PaperMetaProperties.IDENTIFIER, "minecraft:banner");
+            } else if (this.material == Material.BEE_NEST || this.material == Material.BEEHIVE) {
+                holder.set(PaperMetaProperties.IDENTIFIER, "minecraft:beehive");
+            } else if (MaterialSetTag.SHULKER_BOXES.isTagged(this.material)) {
+                holder.set(PaperMetaProperties.IDENTIFIER, "minecraft:shulker_box");
+            }
+        }
+
+        // This is expected to always return a CraftBlockEntityState for the passed material:
+        return CraftBlockStates.getBlockState(stateMaterial, null); // TODO
+    }
+
+    @Override
+    public void setBlockState(BlockState blockState) {
+        Validate.notNull(blockState, "blockState must not be null");
+
+        Material stateMaterial = (this.material != Material.SHIELD) ? this.material : shieldToBannerHack(this.propertyHolder.get(ItemProperties.BLOCK_ENTITY_TAG));
+        Class<?> blockStateType = CraftBlockStates.getBlockStateType(stateMaterial);
+        Validate.isTrue(blockStateType == blockState.getClass() && blockState instanceof CraftBlockEntityState, "Invalid blockState for " + this.material);
+
+        MutablePropertyView mutable = NbtPropertyHolder.simpleBlob(((CraftBlockEntityState) blockState).getSnapshotNBT(), AdapterContext.empty());
+        this.propertyHolder.set(ItemProperties.BLOCK_ENTITY_TAG, mutable);
+        // Set shield base
+        if (this.material == Material.SHIELD) {
+            mutable.set(PaperMetaProperties.BASE, ((CraftBanner) blockState).getBaseColor());
+        }
+    }
+
+    private static Material shieldToBannerHack(MutablePropertyView tag) {
+        if (tag == null) {
+            return Material.WHITE_BANNER;
+        }
+
+        DyeColor colorValue = tag.get(PaperMetaProperties.BASE);
+        if (colorValue == null) {
+            return Material.WHITE_BANNER;
+        }
+
+        return switch (colorValue) {
+            case WHITE -> Material.WHITE_BANNER;
+            case ORANGE -> Material.ORANGE_BANNER;
+            case MAGENTA -> Material.MAGENTA_BANNER;
+            case LIGHT_BLUE -> Material.LIGHT_BLUE_BANNER;
+            case YELLOW -> Material.YELLOW_BANNER;
+            case LIME -> Material.LIME_BANNER;
+            case PINK -> Material.PINK_BANNER;
+            case GRAY -> Material.GRAY_BANNER;
+            case LIGHT_GRAY -> Material.LIGHT_GRAY_BANNER;
+            case CYAN -> Material.CYAN_BANNER;
+            case PURPLE -> Material.PURPLE_BANNER;
+            case BLUE -> Material.BLUE_BANNER;
+            case BROWN -> Material.BROWN_BANNER;
+            case GREEN -> Material.GREEN_BANNER;
+            case RED -> Material.RED_BANNER;
+            case BLACK -> Material.BLACK_BANNER;
+        };
+    }
+
+    @Override
+    public @NotNull MetaBlockState clone() {
+        return new MetaBlockState(this.propertyHolder.clone(), material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.propertyHolder.unset(ItemProperties.BLOCK_ENTITY_TAG);
+    }
+
+    // Equality
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaBlockState that) {
+            return Objects.equal(this.propertyHolder.get(ItemProperties.BLOCK_ENTITY_TAG), that.propertyHolder.get(ItemProperties.BLOCK_ENTITY_TAG));
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaBlockState || this.propertyHolder.get(ItemProperties.BLOCK_ENTITY_TAG) == null);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.propertyHolder.get(ItemProperties.BLOCK_ENTITY_TAG) == null;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaBook.java b/src/main/java/io/papermc/paper/item/meta/MetaBook.java
new file mode 100644
index 0000000000000000000000000000000000000000..afdebf0d96e8f3f2b83da2707dce71fab5e9f674
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaBook.java
@@ -0,0 +1,507 @@
+package io.papermc.paper.item.meta;
+
+import com.google.common.collect.ImmutableList;
+import io.leangen.geantyref.TypeFactory;
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.item.property.ItemPropertyRegistration;
+import io.papermc.paper.property.MutablePropertyView;
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.md_5.bungee.chat.ComponentSerializer;
+import net.minecraft.nbt.CompoundTag;
+import org.apache.commons.lang.Validate;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
+import org.bukkit.inventory.meta.BookMeta;
+import org.jetbrains.annotations.NotNull;
+import org.spigotmc.ValidateUtils;
+
+import java.util.AbstractList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+
+// TODO: Cleanup, I hate all of this
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaBook extends PaperMeta implements BookMeta {
+
+
+    static final int MAX_PAGES = 100;
+    static final int MAX_PAGE_LENGTH = 320; // 256 limit + 64 characters to allow for psuedo colour codes
+    static final int MAX_TITLE_LENGTH = 32;
+
+
+    public MetaBook(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public boolean hasAuthor() {
+        return MetaBook.this.propertyHolder.hasProperty(ItemProperties.AUTHOR);
+    }
+
+    @Override
+    public boolean hasTitle() {
+        return MetaBook.this.propertyHolder.hasProperty(ItemProperties.TITLE);
+    }
+
+    @Override
+    public boolean hasPages() {
+        List<Component> pages = this.propertyHolder.get(ItemProperties.PAGES);
+        return pages != null && !pages.isEmpty();
+    }
+
+    @Override
+    public boolean hasGeneration() {
+        return this.propertyHolder.hasProperty(ItemProperties.GENERATION);
+    }
+
+    @Override
+    public String getTitle() {
+        String author = MetaBook.this.propertyHolder.get(ItemProperties.AUTHOR);
+        if (author != null) {
+            author = ValidateUtils.limit(author, io.papermc.paper.configuration.GlobalConfiguration.get().itemValidation.book.author);
+        }
+
+        return author;
+    }
+
+    @Override
+    public boolean setTitle(final String title) {
+        if (title == null) {
+            MetaBook.this.propertyHolder.unset(ItemProperties.AUTHOR);
+            return true;
+        } else if (title.length() > MAX_TITLE_LENGTH) {
+            return false;
+        }
+
+        MetaBook.this.propertyHolder.set(ItemProperties.AUTHOR, title);
+        return true;
+    }
+
+    @Override
+    public String getAuthor() {
+        String author = MetaBook.this.propertyHolder.get(ItemProperties.AUTHOR);
+        if (author != null) {
+            author = ValidateUtils.limit(author, io.papermc.paper.configuration.GlobalConfiguration.get().itemValidation.book.author);
+        }
+
+        return author;
+    }
+
+    @Override
+    public void setAuthor(String author) {
+        if (author != null) {
+            author = ValidateUtils.limit(author, io.papermc.paper.configuration.GlobalConfiguration.get().itemValidation.book.author);
+        }
+
+        MetaBook.this.propertyHolder.set(ItemProperties.AUTHOR, author);
+    }
+
+    @Override
+    public Generation getGeneration() {
+        if (!MetaBook.this.propertyHolder.hasProperty(ItemProperties.GENERATION)) {
+            return null;
+        }
+
+        int generation = MetaBook.this.propertyHolder.get(ItemProperties.GENERATION);
+        return Generation.values()[generation];
+    }
+
+    @Override
+    public void setGeneration(Generation generation) {
+        if (generation == null) {
+            MetaBook.this.propertyHolder.unset(ItemProperties.GENERATION);
+        } else {
+            MetaBook.this.propertyHolder.set(ItemProperties.GENERATION, generation.ordinal());
+        }
+    }
+
+    @Override
+    public net.kyori.adventure.text.Component title() {
+        String title = MetaBook.this.propertyHolder.get(ItemProperties.TITLE);
+        return title == null ? null : net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(title);
+    }
+
+    @Override
+    public org.bukkit.inventory.meta.BookMeta title(net.kyori.adventure.text.Component title) {
+        this.setTitle(title == null ? null : net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().serialize(title));
+        return this;
+    }
+
+    @Override
+    public net.kyori.adventure.text.Component author() {
+        String author = MetaBook.this.propertyHolder.get(ItemProperties.AUTHOR);
+        return author == null ? null : net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(author);
+    }
+
+    @Override
+    public org.bukkit.inventory.meta.BookMeta author(net.kyori.adventure.text.Component author) {
+        this.setAuthor(author == null ? null : net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().serialize(author));
+        return this;
+    }
+
+    @Override
+    public net.kyori.adventure.text.Component page(final int page) {
+        Validate.isTrue(isValidPage(page), "Invalid page number");
+        return MetaBook.this.propertyHolder.get(this.getPageProperty()).get(page);
+    }
+
+    @Override
+    public void page(final int page, net.kyori.adventure.text.Component data) {
+        if (!isValidPage(page)) {
+            throw new IllegalArgumentException("Invalid page number " + page + "/" + this.getPageCount());
+        }
+        List<Component> pages = MetaBook.this.propertyHolder.get(this.getPageProperty());
+
+        if (data == null) {
+            data = net.kyori.adventure.text.Component.empty();
+        }
+        pages.set(page - 1, data);
+    }
+
+    @Override
+    public List<net.kyori.adventure.text.Component> pages() {
+        List<Component> pages = MetaBook.this.propertyHolder.get(this.getPageProperty());
+        if (pages == null) {
+            return List.of();
+        }
+
+        return pages;
+    }
+
+    @Override
+    public BookMeta pages(List<net.kyori.adventure.text.Component> pages) {
+        MetaBook.this.propertyHolder.unset(this.getPageProperty());
+        for (net.kyori.adventure.text.Component page : pages) {
+            addPages(page);
+        }
+        return this;
+    }
+
+    @Override
+    public BookMeta pages(net.kyori.adventure.text.Component... pages) {
+        MetaBook.this.propertyHolder.unset(this.getPageProperty());
+        addPages(pages);
+        return this;
+    }
+
+    @Override
+    public void addPages(net.kyori.adventure.text.Component... pages) {
+        List<Component> pageList = MetaBook.this.propertyHolder.get(this.getPageProperty());
+        for (net.kyori.adventure.text.Component page : pages) {
+            if (pageList.size() >= MAX_PAGES) {
+                return;
+            }
+
+            if (page == null) {
+                page = net.kyori.adventure.text.Component.empty();
+            }
+
+            pageList.add(page);
+        }
+    }
+
+    public PropertyKey<List<Component>> getPageProperty() {
+        return ItemProperties.PAGES;
+    }
+
+    class CraftMetaBookBuilder implements BookMetaBuilder {
+        private net.kyori.adventure.text.Component title = null;
+        private net.kyori.adventure.text.Component author = null;
+        private final List<net.kyori.adventure.text.Component> pages = new java.util.ArrayList<>();
+
+        @Override
+        public BookMetaBuilder title(net.kyori.adventure.text.Component title) {
+            this.title = title;
+            return this;
+        }
+
+        @Override
+        public BookMetaBuilder author(net.kyori.adventure.text.Component author) {
+            this.author = author;
+            return this;
+        }
+
+        @Override
+        public BookMetaBuilder addPage(net.kyori.adventure.text.Component page) {
+            this.pages.add(page);
+            return this;
+        }
+
+        @Override
+        public BookMetaBuilder pages(net.kyori.adventure.text.Component... pages) {
+            java.util.Collections.addAll(this.pages, pages);
+            return this;
+        }
+
+        @Override
+        public BookMetaBuilder pages(java.util.Collection<net.kyori.adventure.text.Component> pages) {
+            this.pages.addAll(pages);
+            return this;
+        }
+
+        @Override
+        public BookMeta build() {
+            return this.build(title, author, pages);
+        }
+
+        protected BookMeta build(net.kyori.adventure.text.Component title, net.kyori.adventure.text.Component author, java.util.List<net.kyori.adventure.text.Component> pages) {
+            MetaBook metaBook = new MetaBook(NbtPropertyHolder.simpleBlob(new CompoundTag(), ItemPropertyRegistration.ITEM_CONTEXT), Material.WRITTEN_BOOK);
+            metaBook.propertyHolder.set(ItemProperties.TITLE, LegacyComponentSerializer.legacySection().serialize(title));
+            metaBook.propertyHolder.set(ItemProperties.AUTHOR, LegacyComponentSerializer.legacySection().serialize(author));
+            metaBook.propertyHolder.set(ItemProperties.PAGES, pages);
+
+            return metaBook;
+        }
+    }
+
+    @Override
+    public BookMetaBuilder toBuilder() {
+        return new MetaBook.CraftMetaBookBuilder();
+    }
+
+    @Override
+    public String getPage(final int page) {
+        Validate.isTrue(this.isValidPage(page), "Invalid page number");
+        // assert: pages != null
+        return this.convertDataToPlainPage(MetaBook.this.propertyHolder.get(PAGES_LEGACY).get(page - 1));
+    }
+
+    @Override
+    public void setPage(final int page, final String text) {
+        if (!this.isValidPage(page)) {
+            throw new IllegalArgumentException("Invalid page number " + page + "/" + this.getPageCount());
+        }
+        // assert: pages != null
+
+        String newText = this.validatePage(text);
+        MetaBook.this.propertyHolder.get(PAGES_LEGACY).set(page - 1, this.convertPlainPageToData(newText));
+    }
+
+    @Override
+    public void setPages(final String... pages) {
+        this.setPages(Arrays.asList(pages));
+    }
+
+    @Override
+    public void addPage(final String... pages) {
+        for (String page : pages) {
+            page = this.validatePage(page);
+            this.internalAddPage(this.convertPlainPageToData(page));
+        }
+    }
+
+    String validatePage(String page) {
+        if (page == null) {
+            page = "";
+        } else if (page.length() > MAX_PAGE_LENGTH) {
+            page = page.substring(0, MAX_PAGE_LENGTH);
+        }
+        return page;
+    }
+
+    @Override
+    public int getPageCount() {
+        List<String> pages = MetaBook.this.propertyHolder.get(PAGES_LEGACY);
+        return (pages == null) ? 0 : pages.size();
+    }
+
+    @Override
+    public List<String> getPages() {
+        List<String> pages = MetaBook.this.propertyHolder.getOrDefault(PAGES_LEGACY, List.of());
+
+        return pages.stream().map(this::convertDataToPlainPage).collect(ImmutableList.toImmutableList());
+    }
+
+    @Override
+    public void setPages(List<String> pages) {
+        MetaBook.this.propertyHolder.unset(PAGES_LEGACY);
+        if (pages.isEmpty()) {
+            return;
+        }
+
+        for (String page : pages) {
+            this.addPage(page);
+        }
+    }
+
+    protected String convertPlainPageToData(String page) {
+        // Writable books store their data as plain Strings, so we don't need to convert anything.
+        return page;
+    }
+
+    protected String convertDataToPlainPage(String pageData) {
+        // pageData is expected to already be a plain String.
+        return pageData;
+    }
+
+
+    // Legacy Spigot IMPL
+    private static final PropertyKey<List<String>> PAGES_LEGACY = PropertyKey.of("pages", TypeFactory.parameterizedClass(List.class, String.class));
+
+    private final BookMeta.Spigot spigot = new SpigotMeta();
+
+    private class SpigotMeta extends BookMeta.Spigot {
+
+        private String pageToJSON(String page) {
+            if (MetaBook.this instanceof MetaBookSigned) {
+                // Page data is already in JSON format:
+                return page;
+            } else {
+                // Convert from plain String to JSON (similar to conversion between writable books and written books):
+                net.minecraft.network.chat.Component component = CraftChatMessage.fromString(page, true, true)[0];
+                return CraftChatMessage.toJSON(component);
+            }
+        }
+
+        private String componentsToPage(BaseComponent[] components) {
+            // asserted: components != null
+            if (MetaBook.this instanceof MetaBookSigned) {
+                // Pages are in JSON format:
+                return ComponentSerializer.toString(components);
+            } else {
+                // Convert component to plain String:
+                return CraftChatMessage.fromJSONComponent(ComponentSerializer.toString(components));
+            }
+        }
+
+        @Override
+        public BaseComponent[] getPage(final int page) {
+            Validate.isTrue(MetaBook.this.isValidPage(page), "Invalid page number");
+            return ComponentSerializer.parse(this.pageToJSON(MetaBook.this.propertyHolder.get(PAGES_LEGACY).get(page - 1)));
+        }
+
+        @Override
+        public void setPage(final int page, final BaseComponent... text) {
+            if (!MetaBook.this.isValidPage(page)) {
+                throw new IllegalArgumentException("Invalid page number " + page + "/" + MetaBook.this.getPageCount());
+            }
+
+            BaseComponent[] newText = text == null ? new BaseComponent[0] : text;
+            MetaBook.this.propertyHolder.get(PAGES_LEGACY).set(page - 1, this.componentsToPage(newText));
+        }
+
+        @Override
+        public void setPages(final BaseComponent[]... pages) {
+            this.setPages(Arrays.asList(pages));
+        }
+
+        @Override
+        public void addPage(final BaseComponent[]... pages) {
+            for (BaseComponent[] page : pages) {
+                if (page == null) {
+                    page = new BaseComponent[0];
+                }
+
+                MetaBook.this.internalAddPage(this.componentsToPage(page));
+            }
+        }
+
+        @Override
+        public List<BaseComponent[]> getPages() {
+            List<String> pages = MetaBook.this.propertyHolder.get(PAGES_LEGACY);
+            if (pages == null || pages.isEmpty()) {
+                return List.of();
+            }
+
+            return new AbstractList<BaseComponent[]>() {
+
+                @Override
+                public BaseComponent[] get(int index) {
+                    return ComponentSerializer.parse(MetaBook.SpigotMeta.this.pageToJSON(pages.get(index)));
+                }
+
+                @Override
+                public int size() {
+                    return pages.size();
+                }
+            };
+        }
+
+        @Override
+        public void setPages(List<BaseComponent[]> pages) {
+            MetaBook.this.propertyHolder.unset(PAGES_LEGACY);
+            if (pages.isEmpty()) {
+                return;
+            }
+
+            for (BaseComponent[] page : pages) {
+                this.addPage(page);
+            }
+        }
+    }
+
+    // Utilities
+    private boolean isValidPage(int page) {
+        return page > 0 && page <= this.getPageCount();
+    }
+
+    private void internalAddPage(String page) {
+        // asserted: page != null
+        List<String> pages = MetaBook.this.propertyHolder.get(PAGES_LEGACY);
+        if (pages != null && pages.size() >= MAX_PAGES) {
+            return;
+        } else if (pages == null) {
+            pages = MetaBook.this.propertyHolder.create(PAGES_LEGACY);
+        }
+
+        pages.add(page);
+    }
+
+    @Override
+    public BookMeta.Spigot spigot() {
+        return this.spigot;
+    }
+
+    @Override
+    public @NotNull MetaBook clone() {
+        return new MetaBook(this.propertyHolder.clone(), material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.propertyHolder.unset(ItemProperties.TITLE);
+        this.propertyHolder.unset(ItemProperties.TITLE_FILTERED);
+        this.propertyHolder.unset(ItemProperties.AUTHOR);
+        this.propertyHolder.unset(ItemProperties.PAGES);
+        this.propertyHolder.unset(ItemProperties.PAGES_FILTERED);
+        this.propertyHolder.unset(ItemProperties.GENERATION);
+        this.propertyHolder.unset(ItemProperties.RESOLVED);
+    }
+
+    // Equality
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaBook that) {
+            return (this.hasTitle() ? that.hasTitle() && this.getTitle().equals(that.getTitle()) : !that.hasTitle())
+                && (this.hasAuthor() ? that.hasAuthor() && this.getAuthor().equals(that.getAuthor()) : !that.hasAuthor())
+                && (Objects.equals(this.getPages(), that.getPages()))
+                && (Objects.equals(this.propertyHolder.get(ItemProperties.RESOLVED), that.propertyHolder.get(ItemProperties.RESOLVED)))
+                && (this.hasGeneration() ? that.hasGeneration() && this.getGeneration().equals(that.getGeneration()) : !that.hasGeneration());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaBook || this.isBookEmpty());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isBookEmpty();
+    }
+
+    boolean isBookEmpty() {
+        return !((!this.getPages().isEmpty()) || this.hasAuthor() || this.hasTitle() || this.hasGeneration() || (this.propertyHolder.get(ItemProperties.RESOLVED) != null));
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaBookSigned.java b/src/main/java/io/papermc/paper/item/meta/MetaBookSigned.java
new file mode 100644
index 0000000000000000000000000000000000000000..2b4f7c053e4cb3a52b96596a734c676d87323c2f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaBookSigned.java
@@ -0,0 +1,59 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import io.papermc.paper.property.PropertyKey;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
+import org.bukkit.inventory.meta.BookMeta;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaBookSigned extends MetaBook implements BookMeta {
+
+    public MetaBookSigned(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    protected String convertPlainPageToData(String page) {
+        return CraftChatMessage.fromStringToJSON(page, true);
+    }
+
+    @Override
+    protected String convertDataToPlainPage(String pageData) {
+        return CraftChatMessage.fromJSONComponent(pageData);
+    }
+
+    @Override
+    public PropertyKey<List<Component>> getPageProperty() {
+        return ItemProperties.PAGES;
+    }
+
+    @Override
+    public @NotNull MetaBookSigned clone() {
+        return new MetaBookSigned(this.propertyHolder.clone(), material);
+    }
+
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        return super.equalsCommon(meta);
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaBookSigned || isBookEmpty());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty();
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaBundle.java b/src/main/java/io/papermc/paper/item/meta/MetaBundle.java
new file mode 100644
index 0000000000000000000000000000000000000000..64a4a5d7a5f51abf1fae984a870a2409d9e87e10
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaBundle.java
@@ -0,0 +1,87 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.BundleMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collections;
+import java.util.List;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaBundle extends PaperMeta implements BundleMeta {
+
+    public MetaBundle(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public boolean hasItems() {
+        List<ItemStack> items = this.propertyHolder.get(ItemProperties.ITEMS);
+        return items != null && !items.isEmpty();
+    }
+
+    @Override
+    public @NotNull List<ItemStack> getItems() {
+        List<ItemStack> items = this.propertyHolder.get(ItemProperties.ITEMS);
+        if (items == null) {
+            return List.of();
+        }
+
+
+        return Collections.unmodifiableList(items);
+    }
+
+    @Override
+    public void setItems(@Nullable List<ItemStack> items) {
+        this.propertyHolder.set(ItemProperties.ITEMS, items);
+    }
+
+    @Override
+    public void addItem(@NotNull ItemStack item) {
+        List<ItemStack> items = this.propertyHolder.getOrCreate(ItemProperties.ITEMS);
+        items.add(item);
+    }
+
+    @Override
+    public @NotNull MetaBundle clone() {
+        return new MetaBundle(this.propertyHolder.clone(), this.material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.propertyHolder.unset(ItemProperties.ITEMS);
+    }
+
+    // Equality
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isBundleEmpty();
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaBundle that) {
+
+            return (this.hasItems() ? that.hasItems() && this.getItems().equals(that.getItems()) : !that.hasItems());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaBundle || this.isBundleEmpty());
+    }
+
+    boolean isBundleEmpty() {
+        return !(this.hasItems());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaCompass.java b/src/main/java/io/papermc/paper/item/meta/MetaCompass.java
new file mode 100644
index 0000000000000000000000000000000000000000..b4933e3e9b79d2f4a6f361293f73da733b67d839
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaCompass.java
@@ -0,0 +1,109 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.math.Position;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.Material;
+import org.bukkit.NamespacedKey;
+import org.bukkit.World;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.CompassMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Objects;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaCompass extends PaperMeta implements CompassMeta {
+
+    public MetaCompass(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public boolean hasLodestone() {
+        return this.propertyHolder.hasProperty(ItemProperties.LODESTONE_DIMENSION);
+    }
+
+    @Override
+    public @Nullable Location getLodestone() {
+        NamespacedKey dimension = this.propertyHolder.get(ItemProperties.LODESTONE_DIMENSION);
+        if (dimension == null) {
+            return null;
+        }
+
+        World world = Bukkit.getWorld(dimension);
+
+        Position position = this.propertyHolder.get(ItemProperties.LODESTONE_POS);
+        if (position == null) {
+            return null;
+        }
+
+        return position.toLocation(world);
+    }
+
+    @Override
+    public void setLodestone(@Nullable Location lodestone) {
+        this.propertyHolder.set(ItemProperties.LODESTONE_POS, lodestone);
+        this.propertyHolder.set(ItemProperties.LODESTONE_DIMENSION, lodestone.getWorld().getKey());
+    }
+
+    @Override
+    public boolean isLodestoneTracked() {
+        return this.propertyHolder.getOrDefault(ItemProperties.LODESTONE_TRACKED, false);
+    }
+
+    @Override
+    public void setLodestoneTracked(boolean tracked) {
+        this.propertyHolder.set(ItemProperties.LODESTONE_TRACKED, tracked);
+    }
+
+    @Override
+    public @NotNull MetaCompass clone() {
+        return new MetaCompass(this.propertyHolder.clone(), this.material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.propertyHolder.unset(ItemProperties.LODESTONE_DIMENSION);
+        this.propertyHolder.unset(ItemProperties.LODESTONE_POS);
+        this.propertyHolder.unset(ItemProperties.LODESTONE_TRACKED);
+    }
+
+    // Equality
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaCompass that) {
+
+            return (this.hasLodestone() ? that.hasLodestone() && Objects.equals( this.propertyHolder.get(ItemProperties.LODESTONE_DIMENSION), that.propertyHolder.get(ItemProperties.LODESTONE_DIMENSION))
+                && this.getLodestone().equals(that.getLodestone()) : !that.hasLodestone())
+                && this.isLodestoneTracked() == that.isLodestoneTracked();
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaCompass || this.isCompassEmpty());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isCompassEmpty();
+    }
+
+    boolean isCompassEmpty() {
+        return !(this.hasLodestone() || this.hasLodestoneTracked());
+    }
+
+    boolean hasLodestoneTracked() {
+        return this.propertyHolder.hasProperty(ItemProperties.LODESTONE_TRACKED);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaCrossbow.java b/src/main/java/io/papermc/paper/item/meta/MetaCrossbow.java
new file mode 100644
index 0000000000000000000000000000000000000000..20c28152a56ac682b32d273c6b676dbafd9b9b8e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaCrossbow.java
@@ -0,0 +1,102 @@
+package io.papermc.paper.item.meta;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import net.minecraft.world.item.ArrowItem;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.CrossbowMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaCrossbow extends PaperMeta implements CrossbowMeta {
+
+    public MetaCrossbow(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public boolean hasChargedProjectiles() {
+        List<ItemStack> effects = this.propertyHolder.get(ItemProperties.CHARGED_PROJECTILES);
+        return effects != null && !effects.isEmpty();
+    }
+
+    @Override
+    public @NotNull List<ItemStack> getChargedProjectiles() {
+        return this.propertyHolder.getOrDefault(ItemProperties.CHARGED_PROJECTILES, List.of());
+    }
+
+    @Override
+    public void setChargedProjectiles(@Nullable List<ItemStack> projectiles) {
+        this.propertyHolder.unset(ItemProperties.CHARGED_PROJECTILES);
+        this.propertyHolder.set(ItemProperties.CHARGED, false);
+
+        if (projectiles == null) {
+            return;
+        }
+
+        for (ItemStack i : projectiles) {
+            this.addChargedProjectile(i);
+        }
+    }
+
+    @Override
+    public void addChargedProjectile(@NotNull ItemStack item) {
+        Preconditions.checkArgument(item != null, "item");
+        Preconditions.checkArgument(item.getType() == Material.FIREWORK_ROCKET || CraftMagicNumbers.getItem(item.getType()) instanceof ArrowItem, "Item %s is not an arrow or firework rocket", item);
+
+        this.propertyHolder.set(ItemProperties.CHARGED, true);
+        this.propertyHolder.getOrCreate(ItemProperties.CHARGED_PROJECTILES).add(item);
+    }
+
+    @Override
+    public @NotNull MetaCrossbow clone() {
+        return new MetaCrossbow(this.propertyHolder.clone(), this.material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.propertyHolder.unset(ItemProperties.CHARGED);
+        this.propertyHolder.unset(ItemProperties.CHARGED_PROJECTILES);
+    }
+
+    // Equality
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isCrossbowEmpty();
+    }
+
+    boolean isCrossbowEmpty() {
+        return !(this.hasChargedProjectiles());
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaCrossbow that) {
+
+            return this.hasChargedProjectiles() == that.hasChargedProjectiles()
+                && (this.charged() ? that.charged() && this.getChargedProjectiles().equals(that.getChargedProjectiles()) : !that.hasChargedProjectiles());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaCrossbow || this.isCrossbowEmpty());
+    }
+
+    public boolean charged() {
+        return this.propertyHolder.getOrDefault(ItemProperties.CHARGED, false);
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaEnchantmentStorage.java b/src/main/java/io/papermc/paper/item/meta/MetaEnchantmentStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..665bb85331faeb8a9612fc0c13b5fc1232432208
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaEnchantmentStorage.java
@@ -0,0 +1,170 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.EnchantmentPair;
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import io.papermc.paper.property.types.EnchantmentPairImpl;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.enchantments.Enchantment;
+import org.bukkit.inventory.meta.EnchantmentStorageMeta;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaEnchantmentStorage extends PaperMeta implements EnchantmentStorageMeta {
+
+    public MetaEnchantmentStorage(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public boolean hasStoredEnchant(Enchantment ench) {
+        List<EnchantmentPair> enchantments = this.propertyHolder.get(ItemProperties.STORED_ENCHANTMENTS);
+        if (enchantments == null) {
+            return false;
+        }
+
+        for (EnchantmentPair next : enchantments) {
+            if (next.enchantment() == ench) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public int getStoredEnchantLevel(Enchantment ench) {
+        List<EnchantmentPair> enchantmentPairs = this.propertyHolder.get(ItemProperties.STORED_ENCHANTMENTS);
+        if (enchantmentPairs == null) {
+            return 0;
+        }
+        for (EnchantmentPair pair : enchantmentPairs) {
+            if (pair.enchantment() == ench) {
+                return pair.level();
+            }
+        }
+
+        return 0;
+    }
+
+    @Override
+    public Map<Enchantment, Integer> getStoredEnchants() {
+        List<EnchantmentPair> pairs = this.propertyHolder.getOrCreate(ItemProperties.STORED_ENCHANTMENTS);
+        Map<Enchantment, Integer> map = new HashMap<>();
+        for (EnchantmentPair enchantmentPair : pairs) {
+            map.put(enchantmentPair.enchantment(), enchantmentPair.level());
+        }
+
+        return map;
+    }
+
+    @Override
+    public boolean addStoredEnchant(Enchantment ench, int level, boolean ignoreRestrictions) {
+        if (ignoreRestrictions || level >= ench.getStartLevel() && level <= ench.getMaxLevel()) {
+            List<EnchantmentPair> enchantments = this.propertyHolder.getOrCreate(ItemProperties.STORED_ENCHANTMENTS);
+
+            EnchantmentPair oldValue = null;
+            int oldIndex = 0;
+            for (int i = 0; i < enchantments.size(); i++) {
+                EnchantmentPair value = enchantments.get(i);
+                if (value.enchantment() == ench) {
+                    oldValue = value;
+                    oldIndex = i;
+                    break;
+                }
+            }
+
+            if (oldValue == null) {
+                enchantments.add(new EnchantmentPairImpl(ench, level));
+                return true;
+            } else {
+                enchantments.set(oldIndex, new EnchantmentPairImpl(ench, level));
+                return oldValue.level() != level;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean removeStoredEnchant(Enchantment ench) {
+        List<EnchantmentPair> enchantmentMap = this.propertyHolder.get(ItemProperties.STORED_ENCHANTMENTS);
+        if (enchantmentMap == null) {
+            return false;
+        }
+
+        Iterator<EnchantmentPair> iterator = enchantmentMap.listIterator();
+        while (iterator.hasNext()) {
+            EnchantmentPair next = iterator.next();
+            if (next.enchantment() == ench) {
+                iterator.remove();
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean hasStoredEnchants() {
+        return this.propertyHolder.hasProperty(ItemProperties.STORED_ENCHANTMENTS) && !this.propertyHolder.get(ItemProperties.STORED_ENCHANTMENTS).isEmpty();
+    }
+
+    @Override
+    public boolean hasConflictingStoredEnchant(Enchantment ench) {
+        if (!hasStoredEnchants()) {
+            return false;
+        }
+
+        for (EnchantmentPair enchant : this.propertyHolder.getOrDefault(ItemProperties.STORED_ENCHANTMENTS, List.of())) {
+            if (enchant.enchantment().conflictsWith(ench)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public @NotNull MetaEnchantmentStorage clone() {
+        return new MetaEnchantmentStorage(this.propertyHolder.clone(), this.material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.propertyHolder.unset(ItemProperties.STORED_ENCHANTMENTS);
+    }
+
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isEnchantedEmpty();
+    }
+
+    boolean isEnchantedEmpty() {
+        return !this.hasStoredEnchants();
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaEnchantmentStorage that) {
+            return (this.hasStoredEnchants() ? that.hasStoredEnchants() && this.getStoredEnchants().equals(that.getStoredEnchants()) : !that.hasStoredEnchants());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaEnchantmentStorage || this.isEnchantedEmpty());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaFirework.java b/src/main/java/io/papermc/paper/item/meta/MetaFirework.java
new file mode 100644
index 0000000000000000000000000000000000000000..e97ff75858de7192f4a2b06c85a4f188d2a97fe4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaFirework.java
@@ -0,0 +1,133 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.apache.commons.lang.Validate;
+import org.bukkit.FireworkEffect;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.FireworkMeta;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaFirework extends PaperMeta implements FireworkMeta {
+
+    public MetaFirework(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public boolean hasEffects() {
+        List<FireworkEffect> effects = this.propertyHolder.get(ItemProperties.EXPLOSIONS);
+        return effects != null && !effects.isEmpty();
+    }
+
+    @Override
+    public void addEffect(FireworkEffect effect) {
+        this.addEffects(List.of(effect));
+    }
+
+    @Override
+    public void addEffects(FireworkEffect... effects) {
+        if (effects.length == 0) {
+            return;
+        }
+
+        this.addEffects(List.of(effects));
+    }
+
+    @Override
+    public void addEffects(Iterable<FireworkEffect> effects) {
+        List<FireworkEffect> explosions = this.propertyHolder.getOrCreate(ItemProperties.EXPLOSIONS);
+        for (FireworkEffect fireworkEffect : effects) {
+            explosions.add(fireworkEffect);
+        }
+    }
+
+    @Override
+    public List<FireworkEffect> getEffects() {
+        return this.propertyHolder.get(ItemProperties.EXPLOSIONS);
+    }
+
+    @Override
+    public int getEffectsSize() {
+        List<FireworkEffect> effects = this.propertyHolder.get(ItemProperties.EXPLOSIONS);
+        return effects == null ? 0 : effects.size();
+    }
+
+    @Override
+    public void removeEffect(int index) {
+        List<FireworkEffect> effects = this.propertyHolder.get(ItemProperties.EXPLOSIONS);
+        if (effects == null) {
+            throw new IndexOutOfBoundsException("Index: " + index + ", Size: 0");
+        } else {
+            effects.remove(index);
+        }
+    }
+
+    @Override
+    public void clearEffects() {
+        this.propertyHolder.unset(ItemProperties.EXPLOSIONS);
+    }
+
+    @Override
+    public int getPower() {
+        return this.propertyHolder.getOrDefault(ItemProperties.FLIGHT, (byte) 0);
+    }
+
+    @Override
+    public void setPower(int power) {
+        Validate.isTrue(power >= 0, "Power cannot be less than zero: ", power);
+        Validate.isTrue(power < 0x80, "Power cannot be more than 127: ", power);
+        this.propertyHolder.set(ItemProperties.FLIGHT, (byte) power);
+    }
+
+
+    @Override
+    public @NotNull MetaFirework clone() {
+        return new MetaFirework(this.propertyHolder.clone(), this.material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.propertyHolder.unset(ItemProperties.FLIGHT);
+        this.propertyHolder.unset(ItemProperties.EXPLOSIONS);
+    }
+
+    // Equality
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isFireworkEmpty();
+    }
+
+    boolean isFireworkEmpty() {
+        return !(this.hasEffects() || this.hasPower());
+    }
+
+    boolean hasPower() {
+        return this.getPower() != 0;
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+
+        if (meta instanceof MetaFirework that) {
+
+            return (this.hasPower() ? that.hasPower() && this.getPower() == that.getPower() : !that.hasPower())
+                && (this.hasEffects() ? that.hasEffects() && this.getEffects().equals(that.getEffects()) : !that.hasEffects());
+        }
+
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaFirework || this.isFireworkEmpty());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaFireworkEffect.java b/src/main/java/io/papermc/paper/item/meta/MetaFireworkEffect.java
new file mode 100644
index 0000000000000000000000000000000000000000..354ffdddecb50a1acf26d281154cfeea4cd29788
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaFireworkEffect.java
@@ -0,0 +1,71 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.FireworkEffect;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.FireworkEffectMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaFireworkEffect extends PaperMeta implements FireworkEffectMeta {
+
+    public MetaFireworkEffect(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public void setEffect(@Nullable FireworkEffect effect) {
+        this.propertyHolder.set(ItemProperties.EXPLOSION, effect);
+    }
+
+    @Override
+    public boolean hasEffect() {
+        return this.propertyHolder.hasProperty(ItemProperties.EXPLOSION);
+    }
+
+    @Override
+    public @Nullable FireworkEffect getEffect() {
+        return this.propertyHolder.get(ItemProperties.EXPLOSION);
+    }
+
+    @Override
+    public @NotNull MetaFireworkEffect clone() {
+        return new MetaFireworkEffect(this.propertyHolder.clone(), this.material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.propertyHolder.unset(ItemProperties.EXPLOSION);
+    }
+
+    // Equality
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && !this.hasChargeMeta();
+    }
+
+    boolean hasChargeMeta() {
+        return this.hasEffect();
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaFireworkEffect that) {
+            return (this.hasEffect() ? that.hasEffect() && this.getEffect().equals(that.getEffect()) : !that.hasEffect());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaFireworkEffect || !this.hasChargeMeta());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaKnowledgeBook.java b/src/main/java/io/papermc/paper/item/meta/MetaKnowledgeBook.java
new file mode 100644
index 0000000000000000000000000000000000000000..6a4f1b788fb02f6d5255bc48d6c8e9fc61d7503b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaKnowledgeBook.java
@@ -0,0 +1,86 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Material;
+import org.bukkit.NamespacedKey;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.KnowledgeBookMeta;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaKnowledgeBook extends PaperMeta implements KnowledgeBookMeta {
+
+    static final int MAX_RECIPES = Short.MAX_VALUE;
+
+    public MetaKnowledgeBook(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public boolean hasRecipes() {
+        List<NamespacedKey> effects = this.propertyHolder.get(ItemProperties.RECIPES);
+        return effects != null && !effects.isEmpty();
+    }
+
+    @Override
+    public @NotNull List<NamespacedKey> getRecipes() {
+        return this.propertyHolder.getOrDefault(ItemProperties.RECIPES, List.of());
+    }
+
+    @Override
+    public void setRecipes(@NotNull List<NamespacedKey> recipes) {
+        this.propertyHolder.set(ItemProperties.RECIPES, recipes);
+    }
+
+    @Override
+    public void addRecipe(@NotNull NamespacedKey... recipes) {
+        List<NamespacedKey> keys = this.propertyHolder.getOrCreate(ItemProperties.RECIPES);
+        for (NamespacedKey key : recipes) {
+            if (keys.size() > MAX_RECIPES) {
+                break;
+            }
+
+            keys.add(key);
+        }
+    }
+
+    @Override
+    public @NotNull MetaKnowledgeBook clone() {
+        return new MetaKnowledgeBook(this.propertyHolder.clone(), this.material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.propertyHolder.unset(ItemProperties.RECIPES);
+    }
+
+    // Equality
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isBookEmpty();
+    }
+
+    boolean isBookEmpty() {
+        return !(this.hasRecipes());
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaKnowledgeBook that) {
+            return (this.hasRecipes() ? that.hasRecipes() && this.getRecipes().equals(that.getRecipes()) : !that.hasRecipes());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaKnowledgeBook || this.isBookEmpty());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaLeatherArmor.java b/src/main/java/io/papermc/paper/item/meta/MetaLeatherArmor.java
new file mode 100644
index 0000000000000000000000000000000000000000..601de48cb795475282783c8d7e5edf7a7bc4b529
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaLeatherArmor.java
@@ -0,0 +1,76 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Color;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.LeatherArmorMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaLeatherArmor extends PaperMeta implements LeatherArmorMeta {
+
+    private static final Color DEFAULT_LEATHER_COLOR = Color.fromRGB(0xA06540);
+
+    public MetaLeatherArmor(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public @NotNull Color getColor() {
+        return this.getFromPropertyPathOrElse(ItemProperties.DISPLAY, ItemProperties.COLOR, DEFAULT_LEATHER_COLOR);
+    }
+
+    @Override
+    public void setColor(@Nullable Color color) {
+        this.setFromPropertyPath(ItemProperties.DISPLAY, ItemProperties.COLOR, color);
+    }
+
+    @Override
+    public @NotNull MetaLeatherArmor clone() {
+        return new MetaLeatherArmor(this.propertyHolder.clone(), this.material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.unsetInPropertyPath(ItemProperties.DISPLAY, ItemProperties.COLOR);
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isLeatherArmorEmpty();
+    }
+
+    boolean isLeatherArmorEmpty() {
+        return !(this.hasColor());
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaLeatherArmor that) {
+            return this.getColor().equals(that.getColor());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaLeatherArmor || this.isLeatherArmorEmpty());
+    }
+
+    boolean hasColor() {
+        Color color = this.getColor();
+        if (color == null) {
+            return false;
+        }
+
+        // LEGACY
+        return !DEFAULT_LEATHER_COLOR.equals(color);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaMap.java b/src/main/java/io/papermc/paper/item/meta/MetaMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..93f4753097e4bc48063cffce7d1a9a3c89389d77
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaMap.java
@@ -0,0 +1,143 @@
+package io.papermc.paper.item.meta;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Bukkit;
+import org.bukkit.Color;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.MapMeta;
+import org.bukkit.map.MapView;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaMap extends PaperMeta implements MapMeta {
+
+    public MetaMap(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public boolean hasMapId() {
+        return this.propertyHolder.hasProperty(ItemProperties.MAP_ID);
+    }
+
+    @Override
+    public int getMapId() {
+        Integer mapId = this.propertyHolder.get(ItemProperties.MAP_ID);
+        Preconditions.checkState(mapId != null, "Item does not have map associated - check hasMapView() first!");
+
+        return mapId.intValue();
+    }
+
+    @Override
+    public void setMapId(int id) {
+        this.propertyHolder.set(ItemProperties.MAP_ID, id);
+    }
+
+    @Override
+    public boolean hasMapView() {
+        return this.hasMapId();
+    }
+
+    @Override
+    public MapView getMapView() {
+        return Bukkit.getMap(this.getMapId());
+    }
+
+    @Override
+    public void setMapView(MapView map) {
+        this.propertyHolder.set(ItemProperties.MAP_ID, (map != null) ? map.getId() : null);
+    }
+
+    @Override
+    public boolean isScaling() {
+        return this.propertyHolder.getOrDefault(ItemProperties.MAP_SCALE_DIRECTION, (byte) 0) > 0;
+    }
+
+    @Override
+    public void setScaling(boolean value) {
+        this.propertyHolder.set(ItemProperties.MAP_SCALE_DIRECTION, (byte) (value ? 1 : 0));
+    }
+
+    boolean hasScaling() {
+        return this.isScaling();
+    }
+
+    // isn't wrapped in a display tag....
+    // Stupid legacy!
+    @Override
+    public boolean hasLocationName() {
+        return this.propertyHolder.hasProperty(ItemProperties.LOC_NAME);
+    }
+
+    @Override
+    public @Nullable String getLocationName() {
+        return this.propertyHolder.get(ItemProperties.LOC_NAME);
+    }
+
+    @Override
+    public void setLocationName(@Nullable String name) {
+        this.propertyHolder.set(ItemProperties.LOC_NAME, name);
+    }
+
+    @Override
+    public boolean hasColor() {
+        return this.hasInPropertyPath(ItemProperties.DISPLAY, ItemProperties.MAP_COLOR);
+    }
+
+    @Override
+    public @Nullable Color getColor() {
+        return this.getFromPropertyPath(ItemProperties.DISPLAY, ItemProperties.MAP_COLOR);
+    }
+
+    @Override
+    public void setColor(@Nullable Color color) {
+        this.setFromPropertyPath(ItemProperties.DISPLAY, ItemProperties.MAP_COLOR, color);
+    }
+
+    @Override
+    public @NotNull MetaMap clone() {
+        return new MetaMap(this.propertyHolder.clone(), this.material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.propertyHolder.unset(ItemProperties.MAP_ID);
+        this.unsetInPropertyPath(ItemProperties.DISPLAY, ItemProperties.MAP_COLOR);
+        this.propertyHolder.unset(ItemProperties.MAP_SCALE_DIRECTION);
+    }
+
+    // equality
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isMapEmpty();
+    }
+
+    boolean isMapEmpty() {
+        return !(this.hasMapId() || this.hasScaling() | this.hasLocationName() || this.hasColor());
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaMap that) {
+
+            return (this.isScaling() == that.isScaling())
+                && (this.hasMapId() ? that.hasMapId() && this.getMapId() == that.getMapId() : !that.hasMapId())
+                && (this.hasLocationName() ? that.hasLocationName() && this.getLocationName().equals(that.getLocationName()) : !that.hasLocationName())
+                && (this.hasColor() ? that.hasColor() && this.getColor().equals(that.getColor()) : !that.hasColor());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaMap || this.isMapEmpty());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaMusicInstrument.java b/src/main/java/io/papermc/paper/item/meta/MetaMusicInstrument.java
new file mode 100644
index 0000000000000000000000000000000000000000..5184543b7f42d35241af0e10063da279f9ae3069
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaMusicInstrument.java
@@ -0,0 +1,65 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Material;
+import org.bukkit.MusicInstrument;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.MusicInstrumentMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaMusicInstrument extends PaperMeta implements MusicInstrumentMeta {
+
+    public MetaMusicInstrument(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public void setInstrument(@Nullable MusicInstrument instrument) {
+        this.propertyHolder.set(ItemProperties.INSTRUMENT, instrument);
+    }
+
+    @Override
+    public @Nullable MusicInstrument getInstrument() {
+        return this.propertyHolder.get(ItemProperties.INSTRUMENT);
+    }
+
+    @Override
+    public @NotNull MetaMusicInstrument clone() {
+        return new MetaMusicInstrument(this.propertyHolder.clone(), this.material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.propertyHolder.unset(ItemProperties.INSTRUMENT);
+    }
+
+    // Equality
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaMusicInstrument that) {
+            return this.getInstrument() == that.getInstrument();
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaMusicInstrument || this.isInstrumentEmpty());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isInstrumentEmpty();
+    }
+
+    boolean isInstrumentEmpty() {
+        return this.getInstrument() == null;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaPlayerHead.java b/src/main/java/io/papermc/paper/item/meta/MetaPlayerHead.java
new file mode 100644
index 0000000000000000000000000000000000000000..2053e7a7945c1551a13658bdb43b8444ad5075a9
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaPlayerHead.java
@@ -0,0 +1,193 @@
+package io.papermc.paper.item.meta;
+
+import com.destroystokyo.paper.profile.PlayerProfile;
+import com.mojang.authlib.GameProfile;
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Bukkit;
+import org.bukkit.Material;
+import org.bukkit.NamespacedKey;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.craftbukkit.profile.CraftPlayerProfile;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.meta.SkullMeta;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Objects;
+
+// Ignores the STRING "SkullOwner" property, as that is temporary
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaPlayerHead extends PaperMeta implements SkullMeta {
+
+    static final int MAX_OWNER_LENGTH = 16;
+
+    public MetaPlayerHead(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public boolean hasOwner() {
+        PlayerProfile profile = this.propertyHolder.get(ItemProperties.SKULL_OWNER);
+        String name = this.propertyHolder.get(ItemProperties.SKULL_OWNER_NAME);
+
+        return profile != null || name != null;
+    }
+
+    @Override
+    public String getOwner() {
+        PlayerProfile profile = this.propertyHolder.get(ItemProperties.SKULL_OWNER);
+        String name = this.propertyHolder.get(ItemProperties.SKULL_OWNER_NAME);
+        if (profile != null && profile.getName() != null) {
+            return profile.getName();
+        }
+
+        return name;
+    }
+
+    // Paper start
+    @Override
+    public void setPlayerProfile(@org.jetbrains.annotations.Nullable com.destroystokyo.paper.profile.PlayerProfile profile) {
+        this.propertyHolder.set(ItemProperties.SKULL_OWNER, profile);
+    }
+
+    @org.jetbrains.annotations.Nullable
+    @Override
+    public com.destroystokyo.paper.profile.PlayerProfile getPlayerProfile() {
+        return this.propertyHolder.get(ItemProperties.SKULL_OWNER);
+    }
+    // Paper end
+
+    @Override
+    public OfflinePlayer getOwningPlayer() {
+        if (this.hasOwner()) {
+            PlayerProfile profile = this.propertyHolder.get(ItemProperties.SKULL_OWNER);
+            String name = this.propertyHolder.get(ItemProperties.SKULL_OWNER_NAME);
+            if (name != null) {
+                return Bukkit.getOfflinePlayer(name);
+            }
+
+            if (profile.getId() != null) {
+                return Bukkit.getOfflinePlayer(profile.getId());
+            }
+
+            if (profile.getName() != null) {
+                return Bukkit.getOfflinePlayer(profile.getName());
+            }
+        }
+
+        return null;
+    }
+
+    @Override
+    public boolean setOwner(String name) {
+        if (name != null && name.length() > MAX_OWNER_LENGTH) {
+            return false;
+        }
+
+        if (name == null) {
+            this.setProfile(null);
+        } else {
+            this.setProfile(Bukkit.createProfile(name));
+        }
+
+        return true;
+    }
+
+    @Override
+    public boolean setOwningPlayer(OfflinePlayer owner) {
+        if (owner == null) {
+            this.setProfile(null);
+        } else if (owner instanceof Player player) {
+            this.setProfile(player.getPlayerProfile());
+        } else {
+            this.setProfile(Bukkit.createProfile(owner.getUniqueId(), owner.getName()));
+        }
+
+        return true;
+    }
+
+    @Override
+    @Deprecated // Paper
+    public org.bukkit.profile.PlayerProfile getOwnerProfile() {
+        if (!this.hasOwner()) {
+            return null;
+        }
+
+        return this.propertyHolder.get(ItemProperties.SKULL_OWNER);
+    }
+
+    @Override
+    @Deprecated // Paper
+    public void setOwnerProfile(org.bukkit.profile.PlayerProfile profile) {
+        if (profile == null) {
+            this.setProfile(null);
+        } else {
+            GameProfile gameProfile = (((com.destroystokyo.paper.profile.SharedPlayerProfile) profile).buildGameProfile());
+            CraftPlayerProfile.validateSkullProfile(gameProfile);
+
+            this.setProfile(profile); // Paper
+        }
+    }
+
+    @Override
+    public void setNoteBlockSound(@Nullable NamespacedKey noteBlockSound) {
+        this.setFromPropertyPath(ItemProperties.BLOCK_ENTITY_TAG, ItemProperties.NOTE_BLOCK_SOUND, noteBlockSound);
+    }
+
+    @Override
+    public @Nullable NamespacedKey getNoteBlockSound() {
+        return this.getFromPropertyPath(ItemProperties.BLOCK_ENTITY_TAG, ItemProperties.NOTE_BLOCK_SOUND);
+    }
+
+    @Override
+    public @NotNull MetaPlayerHead clone() {
+        return new MetaPlayerHead(this.propertyHolder.clone(), this.material);
+    }
+
+    private void setProfile(org.bukkit.profile.PlayerProfile gameProfile) {
+        if (gameProfile == null) {
+            this.propertyHolder.set(ItemProperties.SKULL_OWNER, null);
+            return;
+        }
+
+        // Convert bukkit -> paper
+        this.propertyHolder.set(ItemProperties.SKULL_OWNER, new com.destroystokyo.paper.profile.CraftPlayerProfile(((CraftPlayerProfile) gameProfile).buildGameProfile()));
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.propertyHolder.unset(ItemProperties.SKULL_OWNER);
+        this.propertyHolder.unset(ItemProperties.SKULL_OWNER_NAME);
+        this.propertyHolder.unset(ItemProperties.BLOCK_ENTITY_TAG);
+    }
+
+    // Equality
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaPlayerHead that) {
+            // SPIGOT-5403: equals does not check properties
+            return (this.getPlayerProfile() != null ? that.getPlayerProfile() != null && this.getPlayerProfile().equals(that.getPlayerProfile()) : that.getPlayerProfile() == null) && Objects.equals(this.getNoteBlockSound(), that.getNoteBlockSound());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaPlayerHead || this.isSkullEmpty());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isSkullEmpty();
+    }
+
+    boolean isSkullEmpty() {
+        return this.getPlayerProfile() == null && this.getNoteBlockSound() == null;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaPotion.java b/src/main/java/io/papermc/paper/item/meta/MetaPotion.java
new file mode 100644
index 0000000000000000000000000000000000000000..dde57608537f2f89496aab53c35c4819b9328fca
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaPotion.java
@@ -0,0 +1,188 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Color;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.PotionMeta;
+import org.bukkit.potion.PotionData;
+import org.bukkit.potion.PotionEffect;
+import org.bukkit.potion.PotionEffectType;
+import org.bukkit.potion.PotionType;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Iterator;
+import java.util.List;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaPotion extends PaperMeta implements PotionMeta {
+
+    private static final PotionData DEFAULT_TYPE = new PotionData(PotionType.UNCRAFTABLE, false, false);
+
+    public MetaPotion(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public void setBasePotionData(@NotNull PotionData data) {
+        this.propertyHolder.set(ItemProperties.DEFAULT_POTION_TYPE, data);
+    }
+
+    @Override
+    public @NotNull PotionData getBasePotionData() {
+        return this.propertyHolder.getOrDefault(ItemProperties.DEFAULT_POTION_TYPE, DEFAULT_TYPE);
+    }
+
+    @Override
+    public boolean hasCustomEffects() {
+        List<PotionEffect> effects = this.propertyHolder.get(ItemProperties.CUSTOM_POTION_EFFECTS);
+        return effects != null && !effects.isEmpty();
+    }
+
+    @Override
+    public @NotNull List<PotionEffect> getCustomEffects() {
+        return this.propertyHolder.getOrDefault(ItemProperties.CUSTOM_POTION_EFFECTS, List.of());
+    }
+
+    @Override
+    public boolean addCustomEffect(@NotNull PotionEffect effect, boolean overwrite) {
+        List<PotionEffect> effects = this.propertyHolder.getOrCreate(ItemProperties.CUSTOM_POTION_EFFECTS);
+        int i = 0;
+        for (PotionEffect old : effects) {
+            if (old.getType() == effect.getType()) {
+                if (!overwrite) {
+                    return false;
+                } else if (old.getAmplifier() == effect.getAmplifier() && old.getDuration() == effect.getDuration() && old.isAmbient() == effect.isAmbient()) {
+                    return false;
+                }
+
+                break;
+            }
+            i++;
+        }
+
+        effects.add(i, effect);
+        return true;
+    }
+
+    @Override
+    public boolean removeCustomEffect(@NotNull PotionEffectType type) {
+        List<PotionEffect> effects = this.propertyHolder.getOrCreate(ItemProperties.CUSTOM_POTION_EFFECTS);
+        if (effects == null) {
+            return false;
+        }
+
+        boolean changed = false;
+        Iterator<PotionEffect> iterator = effects.iterator();
+        while (iterator.hasNext()) {
+            PotionEffect next = iterator.next();
+            if (next.getType() == type) {
+                iterator.remove();
+                changed = true;
+            }
+        }
+
+        return changed;
+    }
+
+    @Override
+    public boolean hasCustomEffect(@NotNull PotionEffectType type) {
+        List<PotionEffect> effects = this.propertyHolder.getOrCreate(ItemProperties.CUSTOM_POTION_EFFECTS);
+        for (PotionEffect old : effects) {
+            if (old.getType() == type) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean clearCustomEffects() {
+        boolean changed = this.hasCustomEffects();
+        this.propertyHolder.unset(ItemProperties.CUSTOM_POTION_EFFECTS);
+        return changed;
+    }
+
+    @Override
+    public boolean setMainEffect(@NotNull PotionEffectType type) {
+        List<PotionEffect> effects = this.propertyHolder.getOrCreate(ItemProperties.CUSTOM_POTION_EFFECTS);
+        PotionEffect found = null;
+        int i = 0;
+        for (PotionEffect old : effects) {
+            if (old.getType() == type) {
+                found = old;
+                break;
+            }
+            i++;
+        }
+
+        if (i == 0 || found == null) {
+            return false;
+        }
+
+        PotionEffect old = effects.get(0);
+        effects.set(0, found);
+        effects.set(i, old);
+
+        return true;
+    }
+
+    @Override
+    public boolean hasColor() {
+        return this.hasInPropertyPath(ItemProperties.DISPLAY, ItemProperties.COLOR);
+    }
+
+    @Override
+    public @Nullable Color getColor() {
+        return this.getFromPropertyPath(ItemProperties.DISPLAY, ItemProperties.COLOR);
+    }
+
+    @Override
+    public void setColor(@Nullable Color color) {
+        this.setFromPropertyPath(ItemProperties.DISPLAY, ItemProperties.COLOR, color);
+    }
+
+    @Override
+    public @NotNull MetaPotion clone() {
+        return new MetaPotion(this.propertyHolder.clone(), this.material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.propertyHolder.unset(ItemProperties.DEFAULT_POTION_TYPE);
+        this.propertyHolder.unset(ItemProperties.CUSTOM_POTION_EFFECTS);
+    }
+
+    // Equality
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaPotion that) {
+
+            return this.getBasePotionData().equals(that.getBasePotionData())
+                && (this.hasCustomEffects() ? that.hasCustomEffects() && this.getCustomEffects().equals(that.getCustomEffects()) : !that.hasCustomEffects())
+                && (this.hasColor() ? that.hasColor() && this.getColor().equals(that.getColor()) : !that.hasColor());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaPotion || this.isPotionEmpty());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isPotionEmpty();
+    }
+
+    boolean isPotionEmpty() {
+        return (this.getBasePotionData().getType() == PotionType.UNCRAFTABLE) && !(this.hasCustomEffects() || this.hasColor());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaSpawnEgg.java b/src/main/java/io/papermc/paper/item/meta/MetaSpawnEgg.java
new file mode 100644
index 0000000000000000000000000000000000000000..a981e1a1aed8afcde3e74c0d264aa7910ca95829
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaSpawnEgg.java
@@ -0,0 +1,70 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.MutablePropertyView;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.entity.EntityType;
+import org.bukkit.inventory.meta.SpawnEggMeta;
+import org.jetbrains.annotations.NotNull;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaSpawnEgg extends PaperMeta implements SpawnEggMeta {
+
+    public MetaSpawnEgg(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public EntityType getSpawnedType() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setSpawnedType(EntityType type) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public @NotNull MetaSpawnEgg clone() {
+        return new MetaSpawnEgg(this.propertyHolder.clone(), this.material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.propertyHolder.unset(ItemProperties.ENTITY_TAG);
+    }
+
+    // Equality
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isSpawnEggEmpty();
+    }
+
+    boolean isSpawnEggEmpty() {
+        return !(this.hasSpawnedType() || this.propertyHolder.get(ItemProperties.ENTITY_TAG) != null);
+    }
+
+    boolean hasSpawnedType() {
+        return false;
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaSpawnEgg that) {
+
+            return this.hasSpawnedType() ? that.hasSpawnedType() : !that.hasSpawnedType()
+                && this.propertyHolder.get(ItemProperties.ENTITY_TAG) != null ? that.propertyHolder.get(ItemProperties.ENTITY_TAG) != null && this.propertyHolder.get(ItemProperties.ENTITY_TAG).equals(that.propertyHolder.get(ItemProperties.ENTITY_TAG)) : this.propertyHolder.get(ItemProperties.ENTITY_TAG) == null;
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaSpawnEgg || this.isSpawnEggEmpty());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaSuspiciousStew.java b/src/main/java/io/papermc/paper/item/meta/MetaSuspiciousStew.java
new file mode 100644
index 0000000000000000000000000000000000000000..cba72e053c77ee1c37333f21efa555261ecd5ec1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaSuspiciousStew.java
@@ -0,0 +1,139 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.inventory.item.properties.StewEffect;
+import io.papermc.paper.property.MutablePropertyView;
+import io.papermc.paper.property.nbt.types.StewEffectsListNbt;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.inventory.meta.SuspiciousStewMeta;
+import org.bukkit.potion.PotionEffect;
+import org.bukkit.potion.PotionEffectType;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaSuspiciousStew extends PaperMeta implements SuspiciousStewMeta {
+
+    public MetaSuspiciousStew(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public boolean hasCustomEffects() {
+        List<StewEffect> effects = this.propertyHolder.get(ItemProperties.STEW_EFFECTS);
+        return effects != null && !effects.isEmpty();
+    }
+
+    @Override
+    public @NotNull List<PotionEffect> getCustomEffects() {
+        List<PotionEffect> effects = new ArrayList<>();
+        for (StewEffect effect : this.propertyHolder.getOrDefault(ItemProperties.STEW_EFFECTS, List.of())) {
+            effects.add(new PotionEffect(effect.effect(), effect.duration(), 0));
+        }
+
+        return effects;
+    }
+
+    @Override
+    public boolean addCustomEffect(@NotNull PotionEffect effect, boolean overwrite) {
+        List<StewEffect> effects = this.propertyHolder.getOrCreate(ItemProperties.STEW_EFFECTS);
+        int i = 0;
+        for (StewEffect old : effects) {
+            if (old.effect() == effect.getType()) {
+                if (!overwrite) {
+                    return false;
+                }
+                if (old.duration() == effect.getDuration()) {
+                    return false;
+                }
+
+                break;
+            }
+            i++;
+        }
+
+        effects.set(i, new StewEffectsListNbt.StewEffectImpl(effect.getType(), effect.getDuration()));
+
+        return true;
+    }
+
+    @Override
+    public boolean removeCustomEffect(@NotNull PotionEffectType type) {
+        List<StewEffect> effects = this.propertyHolder.get(ItemProperties.STEW_EFFECTS);
+        if (effects == null) {
+            return false;
+        }
+
+        boolean changed = false;
+        Iterator<StewEffect> iterator = effects.iterator();
+        while (iterator.hasNext()) {
+            StewEffect next = iterator.next();
+            if (next.effect() == type) {
+                iterator.remove();
+                changed = true;
+            }
+        }
+
+        return changed;
+    }
+
+    @Override
+    public boolean hasCustomEffect(@NotNull PotionEffectType type) {
+        List<StewEffect> effects = this.propertyHolder.getOrCreate(ItemProperties.STEW_EFFECTS);
+        for (StewEffect old : effects) {
+            if (old.effect() == type) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean clearCustomEffects() {
+        boolean changed = this.hasCustomEffects();
+        this.propertyHolder.unset(ItemProperties.STEW_EFFECTS);
+        return changed;
+    }
+
+    @Override
+    public @NotNull MetaSuspiciousStew clone() {
+        return new MetaSuspiciousStew(this.propertyHolder.clone(), this.material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.propertyHolder.unset(ItemProperties.STEW_EFFECTS);
+    }
+
+    // Equality
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isStewEmpty();
+    }
+
+    boolean isStewEmpty() {
+        return !this.hasCustomEffects();
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaSuspiciousStew that) {
+            return (this.hasCustomEffects() ? that.hasCustomEffects() && this.getCustomEffects().equals(that.getCustomEffects()) : !that.hasCustomEffects());
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaSuspiciousStew || this.isStewEmpty());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/MetaTropicalFishBucket.java b/src/main/java/io/papermc/paper/item/meta/MetaTropicalFishBucket.java
new file mode 100644
index 0000000000000000000000000000000000000000..e2f5ebff3b41eb93d1757d299ccdd8db31c110c7
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/MetaTropicalFishBucket.java
@@ -0,0 +1,106 @@
+package io.papermc.paper.item.meta;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.inventory.item.properties.TropicalFishVariant;
+import io.papermc.paper.property.MutablePropertyView;
+import io.papermc.paper.property.nbt.types.TropicalFishVariantNbt;
+import org.bukkit.DyeColor;
+import org.bukkit.Material;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.entity.TropicalFish;
+import org.bukkit.inventory.meta.TropicalFishBucketMeta;
+import org.jetbrains.annotations.NotNull;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class MetaTropicalFishBucket extends PaperMeta implements TropicalFishBucketMeta {
+
+    private static final TropicalFishVariant DEFAULT = new TropicalFishVariantNbt.TropicalFishVariantImpl(DyeColor.WHITE, DyeColor.WHITE, TropicalFish.Pattern.KOB);
+
+    public MetaTropicalFishBucket(MutablePropertyView mutable, Material material) {
+        super(mutable, material);
+    }
+
+    @Override
+    public @NotNull DyeColor getPatternColor() {
+        TropicalFishVariant variant = this.propertyHolder.getOrDefault(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, DEFAULT);
+        return variant.patternColor();
+    }
+
+    @Override
+    public void setPatternColor(@NotNull DyeColor color) {
+        TropicalFishVariant variant = this.propertyHolder.getOrDefault(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, DEFAULT);
+        this.set(new TropicalFishVariantNbt.TropicalFishVariantImpl(color, variant.bodyColor(), variant.type()));
+    }
+
+    @Override
+    public @NotNull DyeColor getBodyColor() {
+        TropicalFishVariant variant = this.propertyHolder.getOrDefault(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, DEFAULT);
+        return variant.bodyColor();
+    }
+
+    @Override
+    public void setBodyColor(@NotNull DyeColor color) {
+        TropicalFishVariant variant = this.propertyHolder.getOrDefault(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, DEFAULT);
+        this.set(new TropicalFishVariantNbt.TropicalFishVariantImpl(variant.patternColor(), color, variant.type()));
+    }
+
+    @Override
+    public @NotNull TropicalFish.Pattern getPattern() {
+        TropicalFishVariant variant = this.propertyHolder.getOrDefault(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, DEFAULT);
+        return variant.type();
+    }
+
+    @Override
+    public void setPattern(TropicalFish.@NotNull Pattern pattern) {
+        TropicalFishVariant variant = this.propertyHolder.getOrDefault(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, DEFAULT);
+        this.set(new TropicalFishVariantNbt.TropicalFishVariantImpl(variant.patternColor(), variant.bodyColor(), pattern));
+    }
+
+    @Override
+    public boolean hasVariant() {
+        return this.propertyHolder.hasProperty(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT);
+    }
+
+    private void set(TropicalFishVariantNbt.TropicalFishVariantImpl variant) {
+        this.propertyHolder.set(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, variant);
+    }
+
+    @Override
+    public @NotNull MetaTropicalFishBucket clone() {
+        return new MetaTropicalFishBucket(this.propertyHolder.clone(), this.material);
+    }
+
+    @Override
+    public void migrateFrom(MutablePropertyView mutable) {
+        this.propertyHolder.unset(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT);
+        this.propertyHolder.unset(ItemProperties.ENTITY_TAG);
+    }
+
+    @Override
+    public boolean equalsCommon(PaperMeta meta) {
+        if (!super.equalsCommon(meta)) {
+            return false;
+        }
+        if (meta instanceof MetaTropicalFishBucket that) {
+
+            return (this.hasVariant() ? that.hasVariant() && this.propertyHolder.get(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT).equals(that.propertyHolder.get(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT)) : !that.hasVariant())
+                && (this.propertyHolder.get(ItemProperties.ENTITY_TAG) != null ? that.propertyHolder.get(ItemProperties.ENTITY_TAG) != null && this.propertyHolder.get(ItemProperties.ENTITY_TAG).equals(that.propertyHolder.get(ItemProperties.ENTITY_TAG)) : that.propertyHolder.get(ItemProperties.ENTITY_TAG) == null);
+        }
+        return true;
+    }
+
+    @Override
+    public boolean notUncommon(PaperMeta meta) {
+        return super.notUncommon(meta) && (meta instanceof MetaTropicalFishBucket || this.isBucketEmpty());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return super.isEmpty() && this.isBucketEmpty();
+    }
+
+    boolean isBucketEmpty() {
+        return !(this.hasVariant() || this.propertyHolder.get(ItemProperties.ENTITY_TAG) != null);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/PaperMeta.java b/src/main/java/io/papermc/paper/item/meta/PaperMeta.java
new file mode 100644
index 0000000000000000000000000000000000000000..9ec0d6aa18c5a7ec45b29bc491902105655360ea
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/PaperMeta.java
@@ -0,0 +1,741 @@
+package io.papermc.paper.item.meta;
+
+import com.destroystokyo.paper.Namespaced;
+import com.google.common.collect.LinkedHashMultimap;
+import com.google.common.collect.Multimap;
+import com.google.common.collect.SetMultimap;
+import com.google.common.collect.Sets;
+import io.papermc.paper.inventory.item.properties.AttributePair;
+import io.papermc.paper.inventory.item.properties.EnchantmentPair;
+import io.papermc.paper.item.PaperMetaSerialization;
+import io.papermc.paper.property.MutablePropertyView;
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.nbt.AdapterContext;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.nbt.pdc.LivePersistentDataContainer;
+import io.papermc.paper.property.types.EnchantmentPairImpl;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.minecraft.world.item.BlockItem;
+import org.bukkit.Material;
+import org.bukkit.NamespacedKey;
+import org.bukkit.attribute.Attribute;
+import org.bukkit.attribute.AttributeModifier;
+import org.bukkit.block.data.BlockData;
+import org.bukkit.configuration.serialization.ConfigurationSerializable;
+import org.bukkit.configuration.serialization.DelegateDeserialization;
+import org.bukkit.craftbukkit.Overridden;
+import org.bukkit.craftbukkit.block.data.CraftBlockData;
+import org.bukkit.craftbukkit.inventory.CraftItemFactory;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.bukkit.craftbukkit.inventory.tags.DeprecatedCustomTagContainer;
+import org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.enchantments.Enchantment;
+import org.bukkit.inventory.EquipmentSlot;
+import org.bukkit.inventory.ItemFlag;
+import org.bukkit.inventory.meta.BlockDataMeta;
+import org.bukkit.inventory.meta.Damageable;
+import org.bukkit.inventory.meta.ItemMeta;
+import org.bukkit.inventory.meta.Repairable;
+import org.bukkit.inventory.meta.tags.CustomItemTagContainer;
+import org.bukkit.persistence.PersistentDataContainer;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
+import static io.papermc.paper.inventory.item.properties.ItemProperties.*;
+
+@DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
+public class PaperMeta implements ItemMeta, Damageable, Repairable, BlockDataMeta, ConfigurationSerializable {
+
+    private static final CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new CraftPersistentDataTypeRegistry();
+
+    protected final NbtPropertyHolder propertyHolder;
+    protected final Material material;
+
+    public PaperMeta(MutablePropertyView propertyHolder, Material material) {
+        this.propertyHolder = (NbtPropertyHolder) propertyHolder;
+        this.material = material;
+    }
+
+    protected boolean hasInPropertyPath(PropertyKey<MutablePropertyView> outer, PropertyKey<?> inner) {
+        MutablePropertyView holder = this.propertyHolder.get(outer);
+        if (holder != null) {
+            return holder.hasProperty(inner);
+        }
+
+        return false;
+    }
+
+    protected <T> T getFromPropertyPath(PropertyKey<MutablePropertyView> outer, PropertyKey<T> inner) {
+        MutablePropertyView holder = this.propertyHolder.get(outer);
+        if (holder != null) {
+            return holder.get(inner);
+        }
+
+        return null;
+    }
+
+    @Contract("_,_m,,!null -> !null")
+    protected <T> T getFromPropertyPathOrElse(PropertyKey<MutablePropertyView> outer, PropertyKey<T> inner, T defaultValue) {
+        MutablePropertyView holder = this.propertyHolder.get(outer);
+        if (holder != null) {
+            return holder.getOrDefault(inner, defaultValue);
+        }
+
+        return defaultValue;
+    }
+
+    protected <T> void unsetInPropertyPath(PropertyKey<MutablePropertyView> outer, PropertyKey<T> inner) {
+        MutablePropertyView holder = this.propertyHolder.get(outer);
+        if (holder != null) {
+            holder.unset(inner);
+        }
+    }
+
+    protected <T> void setFromPropertyPath(PropertyKey<MutablePropertyView> outer, PropertyKey<T> inner, T value) {
+        MutablePropertyView holder = this.propertyHolder.getOrCreate(outer);
+        holder.set(inner, value);
+    }
+
+    @Override
+    public boolean hasDisplayName() {
+        return this.hasInPropertyPath(DISPLAY, DISPLAY_NAME);
+    }
+
+    @Nullable
+    @Override
+    public Component displayName() {
+        return this.getFromPropertyPath(DISPLAY, DISPLAY_NAME);
+    }
+
+    @Override
+    public void displayName(@Nullable Component displayName) {
+        this.setFromPropertyPath(DISPLAY, DISPLAY_NAME, displayName);
+    }
+
+    @Override
+    public @NotNull String getDisplayName() {
+        Component displayName = this.displayName();
+        if (displayName == null) {
+            return "";
+        }
+        String gson = GsonComponentSerializer.gson().serialize(displayName);
+        return CraftChatMessage.fromJSONComponent(gson);
+    }
+
+    @Override
+    public void setDisplayName(@Nullable String name) {
+        // TODO: test null strings
+        this.displayName(GsonComponentSerializer.gson().deserialize(CraftChatMessage.fromStringOrNullToJSON(name)));
+    }
+
+    @NotNull
+    @Override
+    public BaseComponent[] getDisplayNameComponent() {
+        Component displayName = this.displayName();
+        if (displayName == null) {
+            return new BaseComponent[0];
+        }
+
+        return net.md_5.bungee.chat.ComponentSerializer.parse(GsonComponentSerializer.gson().serialize(displayName));
+    }
+
+    @Override
+    public void setDisplayNameComponent(@Nullable BaseComponent[] component) {
+        String gson = net.md_5.bungee.chat.ComponentSerializer.toString(component);
+        this.displayName(GsonComponentSerializer.gson().deserialize(gson));
+    }
+
+    @Override
+    public boolean hasLocalizedName() {
+        return this.hasInPropertyPath(DISPLAY, LOC_NAME);
+    }
+
+    @Override
+    public @NotNull String getLocalizedName() {
+        return this.getFromPropertyPath(DISPLAY, LOC_NAME);
+    }
+
+    @Override
+    public void setLocalizedName(@Nullable String name) {
+        this.setFromPropertyPath(DISPLAY, LOC_NAME, name);
+    }
+
+    @Override
+    public boolean hasLore() {
+        return this.hasInPropertyPath(DISPLAY, LORE);
+    }
+
+    @Override
+    public @Nullable List<Component> lore() {
+        return this.getFromPropertyPath(DISPLAY, LORE);
+    }
+
+    @Override
+    public void lore(@Nullable List<Component> lore) {
+        this.setFromPropertyPath(DISPLAY, LORE, lore);
+    }
+
+    @Override
+    public @Nullable List<String> getLore() {
+        return null;
+    }
+
+    @Override
+    public void setLore(@Nullable List<String> lore) {
+
+    }
+
+    @Override
+    public @Nullable List<BaseComponent[]> getLoreComponents() {
+        return null;
+    }
+
+    @Override
+    public void setLoreComponents(@Nullable List<BaseComponent[]> lore) {
+
+    }
+
+    @Override
+    public boolean hasCustomModelData() {
+        return this.propertyHolder.hasProperty(CUSTOM_MODEL_DATA);
+    }
+
+    @Override
+    public int getCustomModelData() {
+        return this.propertyHolder.getOrDefault(CUSTOM_MODEL_DATA, 0);
+    }
+
+    @Override
+    public void setCustomModelData(@Nullable Integer data) {
+        this.propertyHolder.set(CUSTOM_MODEL_DATA, data);
+    }
+
+    @Override
+    public boolean hasEnchants() {
+        // Legacy reasons?
+        // TODO: check
+        return this.propertyHolder.hasProperty(ENCHANTMENTS) && !this.propertyHolder.get(ENCHANTMENTS).isEmpty();
+    }
+
+    @Override
+    public boolean hasEnchant(@NotNull Enchantment ench) {
+        List<EnchantmentPair> pairs = this.propertyHolder.get(ENCHANTMENTS);
+        if (pairs == null) {
+            return false;
+        }
+
+        for (EnchantmentPair next : pairs) {
+            if (next.enchantment() == ench) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public int getEnchantLevel(@NotNull Enchantment ench) {
+        List<EnchantmentPair> pairs = this.propertyHolder.get(ENCHANTMENTS);
+        if (pairs == null) {
+            return 0;
+        }
+
+        for (EnchantmentPair next : pairs) {
+            if (next.enchantment() == ench) {
+                return next.level();
+            }
+        }
+
+        return 0;
+    }
+
+    @Override
+    public @NotNull Map<Enchantment, Integer> getEnchants() {
+        List<EnchantmentPair> pairs = this.propertyHolder.get(ENCHANTMENTS);
+        if (pairs == null) {
+            return Map.of();
+        }
+
+        Map<Enchantment, Integer> enchants = new HashMap<>();
+        for (EnchantmentPair next : pairs) {
+            enchants.put(next.enchantment(), next.level());
+        }
+
+        return enchants;
+    }
+
+    @Override
+    public boolean addEnchant(@NotNull Enchantment ench, int level, boolean ignoreLevelRestriction) {
+        if (ignoreLevelRestriction || level >= ench.getStartLevel() && level <= ench.getMaxLevel()) {
+            List<EnchantmentPair> enchantments = this.propertyHolder.getOrCreate(ENCHANTMENTS);
+
+            EnchantmentPair oldValue = null;
+            int oldIndex = 0;
+            for (int i = 0; i < enchantments.size(); i++) {
+                EnchantmentPair value = enchantments.get(i);
+                if (value.enchantment() == ench) {
+                    oldValue = value;
+                    oldIndex = i;
+                    break;
+                }
+            }
+
+            if (oldValue == null) {
+                enchantments.add(new EnchantmentPairImpl(ench, level));
+                return true;
+            } else {
+                enchantments.set(oldIndex, new EnchantmentPairImpl(ench, level));
+                return oldValue.level() != level;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean removeEnchant(@NotNull Enchantment ench) {
+        List<EnchantmentPair> enchantmentMap = this.propertyHolder.get(ENCHANTMENTS);
+        if (enchantmentMap == null) {
+            return false;
+        }
+
+        Iterator<EnchantmentPair> iterator = enchantmentMap.listIterator();
+        while (iterator.hasNext()) {
+            EnchantmentPair next = iterator.next();
+            if (next.enchantment() == ench) {
+                iterator.remove();
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public boolean hasConflictingEnchant(@NotNull Enchantment ench) {
+        if (!hasEnchants()) {
+            return false;
+        }
+
+        for (EnchantmentPair enchant : this.propertyHolder.getOrDefault(ENCHANTMENTS, List.of())) {
+            if (enchant.enchantment().conflictsWith(ench)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    @Override
+    public void addItemFlags(@NotNull ItemFlag... itemFlags) {
+        Set<ItemFlag> flagSetValue = this.propertyHolder.getOrCreate(HIDE_FLAGS);
+        flagSetValue.addAll(Arrays.asList(itemFlags));
+    }
+
+    @Override
+    public void removeItemFlags(@NotNull ItemFlag... itemFlags) {
+        Set<ItemFlag> flagSetValue = this.propertyHolder.get(HIDE_FLAGS);
+        if (flagSetValue == null) {
+            return;
+        }
+
+        for (ItemFlag flag : itemFlags) {
+            flagSetValue.remove(flag);
+        }
+    }
+
+    @Override
+    public @NotNull Set<ItemFlag> getItemFlags() {
+        return this.propertyHolder.getOrDefault(HIDE_FLAGS, Set.of());
+    }
+
+    @Override
+    public boolean hasItemFlag(@NotNull ItemFlag flag) {
+        return this.propertyHolder.hasProperty(HIDE_FLAGS);
+    }
+
+    @Override
+    public boolean isUnbreakable() {
+        return this.propertyHolder.hasProperty(UNBREAKABLE) && this.propertyHolder.get(UNBREAKABLE);
+    }
+
+    @Override
+    public void setUnbreakable(boolean unbreakable) {
+        this.propertyHolder.set(UNBREAKABLE, unbreakable);
+    }
+
+    @Override
+    public boolean hasAttributeModifiers() {
+        return this.propertyHolder.hasProperty(ATTRIBUTES);
+    }
+
+    @Override
+    public @Nullable Multimap<Attribute, AttributeModifier> getAttributeModifiers() {
+        return null;
+        // return this.propertyHolder.getOrDefault(ATTRIBUTES, LinkedHashMultimap.create());
+    }
+
+    @Override
+    public void setAttributeModifiers(@Nullable Multimap<Attribute, AttributeModifier> attributeModifiers) {
+        //this.propertyHolder.set(ATTRIBUTES, attributeModifiers);
+    }
+
+    @Override
+    public @NotNull Multimap<Attribute, AttributeModifier> getAttributeModifiers(@NotNull EquipmentSlot slot) {
+        SetMultimap<Attribute, AttributeModifier> result = LinkedHashMultimap.create();
+        for (AttributePair entry : this.propertyHolder.getOrCreate(ATTRIBUTES)) {
+            if (entry.modifier().getSlot() == null || entry.modifier().getSlot() == slot) {
+                result.put(entry.attribute(), entry.modifier());
+            }
+        }
+
+        return result;
+    }
+
+    @Override
+    public @Nullable Collection<AttributeModifier> getAttributeModifiers(@NotNull Attribute attribute) {
+        return this.propertyHolder.get(ATTRIBUTES).stream().filter((pair) -> pair.attribute() == attribute).map(AttributePair::modifier).toList();
+    }
+
+    @Override
+    public boolean addAttributeModifier(@NotNull Attribute attribute, @NotNull AttributeModifier modifier) {
+        return false; // TODO
+//        MultiMapValue<Attribute, AttributeModifier> attributes = this.propertyHolder.getOrCreate(ATTRIBUTES);
+//        for (Map.Entry<Attribute, AttributeModifier> entry : attributes.entries()) {
+//            Preconditions.checkArgument(!entry.getValue().getUniqueId().equals(modifier.getUniqueId()), "Cannot register AttributeModifier. Modifier is already applied! %s", modifier);
+//        }
+//
+//        return attributes.put(attribute, modifier);
+    }
+
+    @Override
+    public boolean removeAttributeModifier(@NotNull Attribute attribute) {
+        return false; // TODO
+//        this.propertyHolder.getOrCreate(ATTRIBUTES).
+//        return !this.attributeModifiers.removeAll(attribute).isEmpty();
+    }
+
+    @Override
+    public boolean removeAttributeModifier(@NotNull EquipmentSlot slot) {
+        return false; // TODO
+//        int removed = 0;
+//        Iterator<Map.Entry<Attribute, AttributeModifier>> iter = this.attributeModifiers.entries().iterator();
+//
+//        while (iter.hasNext()) {
+//            Map.Entry<Attribute, AttributeModifier> entry = iter.next();
+//            // Explicitly match against null because (as of MC 1.13) AttributeModifiers without a -
+//            // set slot are active in any slot.
+//            if (entry.getValue().getSlot() == null || entry.getValue().getSlot() == slot) {
+//                iter.remove();
+//                ++removed;
+//            }
+//        }
+//        return removed > 0;
+    }
+
+    @Override
+    public boolean removeAttributeModifier(@NotNull Attribute attribute, @NotNull AttributeModifier modifier) {
+        return false; // TODO
+//        int removed = 0;
+//        Iterator<Map.Entry<Attribute, AttributeModifier>> iter = this.attributeModifiers.entries().iterator();
+//
+//        while (iter.hasNext()) {
+//            Map.Entry<Attribute, AttributeModifier> entry = iter.next();
+//            if (entry.getKey() == null || entry.getValue() == null) {
+//                iter.remove();
+//                ++removed;
+//                continue; // remove all null values while we are here
+//            }
+//
+//            if (entry.getKey() == attribute && entry.getValue().getUniqueId().equals(modifier.getUniqueId())) {
+//                iter.remove();
+//                ++removed;
+//            }
+//        }
+//        return removed > 0;
+    }
+
+    @Override
+    public @NotNull CustomItemTagContainer getCustomTagContainer() {
+        return new DeprecatedCustomTagContainer(this.getPersistentDataContainer());
+    }
+
+    @Override
+    public void setVersion(int version) {
+        // TODO
+    }
+
+    @Override
+    public @NotNull PaperMeta clone() {
+        return new PaperMeta(propertyHolder, this.material);
+    }
+
+    @Override
+    public Set<Material> getCanDestroy() {
+        return !hasDestroyableKeys() ? Collections.emptySet() : legacyGetMatsFromKeys(this.getDestroyableKeys());
+    }
+
+    @Override
+    public void setCanDestroy(Set<Material> canDestroy) {
+        List<Namespaced> namespaced = new ArrayList<>();
+        legacyClearAndReplaceKeys(namespaced, canDestroy);
+        this.propertyHolder.set(CAN_DESTROY_BLOCK_LIST, namespaced);
+    }
+
+    @Override
+    public Set<Material> getCanPlaceOn() {
+        return !hasPlaceableKeys() ? Collections.emptySet() : legacyGetMatsFromKeys(this.getPlaceableKeys());
+    }
+
+    @Override
+    public void setCanPlaceOn(Set<Material> canPlaceOn) {
+        List<Namespaced> namespaced = new ArrayList<>();
+        legacyClearAndReplaceKeys(namespaced, canPlaceOn);
+        this.propertyHolder.set(CAN_PLACE_ON_BLOCK_LIST, namespaced);
+    }
+
+    @Deprecated
+    private void legacyClearAndReplaceKeys(Collection<Namespaced> toUpdate, Collection<Material> beingSet) {
+        if (beingSet.stream().anyMatch(Material::isLegacy)) {
+            throw new IllegalArgumentException("Set must not contain any legacy materials!");
+        }
+
+        toUpdate.clear();
+        toUpdate.addAll(beingSet.stream().map(Material::getKey).collect(java.util.stream.Collectors.toSet()));
+    }
+
+    @Deprecated
+    private Set<Material> legacyGetMatsFromKeys(Collection<Namespaced> names) {
+        Set<Material> mats = Sets.newHashSet();
+        for (Namespaced key : names) {
+            if (!(key instanceof org.bukkit.NamespacedKey)) {
+                continue;
+            }
+
+            Material material = Material.matchMaterial(key.toString(), false);
+            if (material != null) {
+                mats.add(material);
+            }
+        }
+
+        return mats;
+    }
+
+    @Override
+    public @NotNull Set<Namespaced> getDestroyableKeys() {
+        Set<Namespaced> namespaced = new HashSet<>();
+        for (Namespaced legacy : this.propertyHolder.getOrDefault(CAN_DESTROY_BLOCK_LIST, List.of())) {
+            namespaced.add(new NamespacedKey(legacy.getNamespace(), legacy.getKey()));
+        }
+        return namespaced;
+    }
+
+    @Override
+    public void setDestroyableKeys(@NotNull Collection<Namespaced> canDestroy) {
+        List<Namespaced> namespaced = new ArrayList<>();
+        for (Namespaced legacy : canDestroy) {
+            namespaced.add(legacy);
+        }
+        this.propertyHolder.set(CAN_DESTROY_BLOCK_LIST, namespaced);
+    }
+
+    @Override
+    public @NotNull Set<Namespaced> getPlaceableKeys() {
+        Set<Namespaced> namespaced = new HashSet<>();
+        for (Namespaced legacy : this.propertyHolder.getOrDefault(CAN_PLACE_ON_BLOCK_LIST, List.of())) {
+            namespaced.add(new NamespacedKey(legacy.getNamespace(), legacy.getKey()));
+        }
+        return namespaced;
+    }
+
+    @Override
+    public @NotNull void setPlaceableKeys(@NotNull Collection<Namespaced> canPlaceOn) {
+        List<Namespaced> namespaced = new ArrayList<>();
+        for (Namespaced legacy : canPlaceOn) {
+            namespaced.add(legacy);
+        }
+        this.propertyHolder.set(CAN_PLACE_ON_BLOCK_LIST, namespaced);
+    }
+
+    @Override
+    public boolean hasPlaceableKeys() {
+        return !this.propertyHolder.getOrDefault(CAN_PLACE_ON_BLOCK_LIST, List.of()).isEmpty();
+    }
+
+    @Override
+    public boolean hasDestroyableKeys() {
+        return !this.propertyHolder.getOrDefault(CAN_DESTROY_BLOCK_LIST, List.of()).isEmpty();
+    }
+
+    @Override
+    public @NotNull PersistentDataContainer getPersistentDataContainer() {
+        return new LivePersistentDataContainer(((NbtPropertyHolder) this.propertyHolder.getOrCreate(PUBLIC_BUKKIT_VALUES)).getCompoundTag(), DATA_TYPE_REGISTRY);
+    }
+
+    @Override
+    public @NotNull String getAsString() {
+        return this.toString();
+    }
+
+    public void migrateFrom(MutablePropertyView mutable) {
+    }
+
+    @NotNull
+    public NbtPropertyHolder getPropertyHolder() {
+        return propertyHolder;
+    }
+
+    // TODO
+
+    @Override
+    public String toString() {
+        return this.getClass().getName() + "{" +
+            "propertyHolder=" + propertyHolder +
+            '}';
+    }
+
+    // Block data meta
+    @Override
+    public boolean hasBlockData() {
+        return this.propertyHolder.hasProperty(BLOCK_STATE);
+    }
+
+    @Override
+    public BlockData getBlockData(Material material) {
+        // Paper start - fix NPE if this.blockData is null
+        final net.minecraft.world.level.block.state.BlockState defaultBlockState = CraftMagicNumbers.getBlock(material).defaultBlockState();
+        MutablePropertyView holder = this.propertyHolder.get(BLOCK_STATE);
+
+        return CraftBlockData.fromData(holder == null ? defaultBlockState : BlockItem.getBlockState(defaultBlockState, ((NbtPropertyHolder) holder).getCompoundTag()));
+        // Paper end
+    }
+
+    @Override
+    public void setBlockData(BlockData blockData) {
+        this.propertyHolder.set(BLOCK_STATE, NbtPropertyHolder.simpleBlob(((CraftBlockData) blockData).toStates(), AdapterContext.empty()));
+    }
+
+    // Damage meta
+
+    @Override
+    public boolean hasDamage() {
+        return this.propertyHolder.hasProperty(DAMAGE);
+    }
+
+    @Override
+    public int getDamage() {
+        return this.propertyHolder.getOrDefault(DAMAGE, 0);
+    }
+
+    @Override
+    public void setDamage(int damage) {
+        this.propertyHolder.set(DAMAGE, damage);
+    }
+
+    // REpair meta
+    @Override
+    public boolean hasRepairCost() {
+        return this.propertyHolder.hasProperty(REPAIR_COST);
+    }
+
+    @Override
+    public int getRepairCost() {
+        return this.propertyHolder.getOrDefault(REPAIR_COST, 0);
+    }
+
+    @Override
+    public void setRepairCost(int cost) {
+        this.propertyHolder.set(REPAIR_COST, cost);
+    }
+
+    @Override
+    public final boolean equals(Object object) {
+        if (object == null) {
+            return false;
+        }
+        if (object == this) {
+            return true;
+        }
+        if (!(object instanceof PaperMeta)) {
+            return false;
+        }
+        return CraftItemFactory.instance().equals(this, (ItemMeta) object);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(propertyHolder);
+    }
+
+    // Legacy crud
+    /*
+    Serialization strategy:
+    Load meta into legacy meta object, serialize into a "paper" format which uses byte serialization.
+     */
+    @Override
+    public @NotNull Map<String, Object> serialize() {
+        return PaperMetaSerialization.serialize(this);
+    }
+
+    // Equality checks
+    /**
+     * This method is almost as weird as notUncommon.
+     * Only return false if your common internals are unequal.
+     * Checking your own internals is redundant if you are not common, as notUncommon is meant for checking those 'not common' variables.
+     */
+    @Overridden
+    public boolean equalsCommon(PaperMeta that) {
+        return ((this.hasDisplayName() ? that.hasDisplayName() && this.getDisplayName().equals(that.getDisplayName()) : !that.hasDisplayName()))
+            && (this.hasLocalizedName() ? that.hasLocalizedName() && this.getLocalizedName().equals(that.getLocalizedName()) : !that.hasLocalizedName())
+            && (this.hasEnchants() ? that.hasEnchants() && this.getEnchants().equals(that.getEnchants()) : !that.hasEnchants())
+            && (Objects.equals(this.getLore(), that.getLore()))
+            && (this.hasCustomModelData() ? that.hasCustomModelData() && this.getCustomModelData() == that.getCustomModelData() : !that.hasCustomModelData())
+            && (this.hasBlockData() ? that.hasBlockData() && this.propertyHolder.get(BLOCK_STATE).equals(that.propertyHolder.get(BLOCK_STATE)) : !that.hasBlockData())
+            && (this.hasRepairCost() ? that.hasRepairCost() && this.getRepairCost() == that.getRepairCost() : !that.hasRepairCost())
+            && (this.hasAttributeModifiers() ? that.hasAttributeModifiers() && this.getAttributeModifiers().equals(that.getAttributeModifiers()) : !that.hasAttributeModifiers())
+            && (this.getPersistentDataContainer().equals(that.getPersistentDataContainer()))
+            && (this.getItemFlags().equals(that.getItemFlags())
+            && (this.isUnbreakable() == that.isUnbreakable())
+            && (this.hasDamage() ? that.hasDamage() && this.getDamage() == that.getDamage() : !that.hasDamage())
+            // Paper start - Implement an API for CanPlaceOn and CanDestroy NBT values
+            && (this.hasPlaceableKeys() ? that.hasPlaceableKeys() && this.getPlaceableKeys().equals(that.getPlaceableKeys()) : !that.hasPlaceableKeys())
+            && (this.hasDestroyableKeys() ? that.hasDestroyableKeys() && this.getDestroyableKeys().equals(that.getDestroyableKeys()) : !that.hasDestroyableKeys()));
+        // Paper end
+    }
+
+    /**
+     * This method is a bit weird...
+     * Return true if you are a common class OR your uncommon parts are empty.
+     * Empty uncommon parts implies the NBT data would be equivalent if both were applied to an item
+     */
+    @Overridden
+    public boolean notUncommon(PaperMeta meta) {
+        return true;
+    }
+
+    @Overridden
+    public boolean isEmpty() {
+        return !(this.hasDisplayName() || this.hasLocalizedName() || this.hasEnchants() || (this.getLore() != null) || this.hasCustomModelData() || this.hasBlockData() || this.hasRepairCost() || !this.getPersistentDataContainer().isEmpty() || !this.getItemFlags().isEmpty() || this.isUnbreakable() || this.hasDamage() || this.hasAttributeModifiers() || this.hasPlaceableKeys() || this.hasDestroyableKeys()); // Paper - Implement an API for CanPlaceOn and CanDestroy NBT values
+    }
+
+    public Material getMaterial() {
+        return material;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/item/meta/PaperMetaProperties.java b/src/main/java/io/papermc/paper/item/meta/PaperMetaProperties.java
new file mode 100644
index 0000000000000000000000000000000000000000..6526eb8766d186c9617c59cc95693e984d1808b3
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/meta/PaperMetaProperties.java
@@ -0,0 +1,31 @@
+package io.papermc.paper.item.meta;
+
+import io.leangen.geantyref.TypeFactory;
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.nbt.AdapterContext;
+import io.papermc.paper.property.nbt.primitives.StringPrimitive;
+import io.papermc.paper.property.nbt.types.AxolotlVariantNbt;
+import io.papermc.paper.property.nbt.types.DyeColorNbt;
+import org.bukkit.DyeColor;
+import org.bukkit.NamespacedKey;
+import org.bukkit.block.banner.Pattern;
+
+import java.util.List;
+
+class PaperMetaProperties {
+
+    // Banner Block Entity
+    static final PropertyKey<DyeColor> BASE = PropertyKey.of("Base", DyeColor.class);
+    static final PropertyKey<List<Pattern>> PATTERNS = PropertyKey.of("Patterns", TypeFactory.parameterizedClass(List.class, Pattern.class));
+
+    // Block Entity
+    static final PropertyKey<String> IDENTIFIER = PropertyKey.of("id", String.class);
+
+    // Register
+    public static void register(AdapterContext context) {
+        context.register(BASE, new DyeColorNbt());
+        // TODO: Patterns
+        context.register(IDENTIFIER, new StringPrimitive());
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/item/property/ItemPropertyRegistration.java b/src/main/java/io/papermc/paper/item/property/ItemPropertyRegistration.java
new file mode 100644
index 0000000000000000000000000000000000000000..9e09f71b67e3ced942f03f1b5d21127d5984cc20
--- /dev/null
+++ b/src/main/java/io/papermc/paper/item/property/ItemPropertyRegistration.java
@@ -0,0 +1,105 @@
+package io.papermc.paper.item.property;
+
+import io.papermc.paper.inventory.item.properties.ItemProperties;
+import io.papermc.paper.property.nbt.AdapterContext;
+import io.papermc.paper.property.nbt.primitives.BlockPositionNbtPrimitive;
+import io.papermc.paper.property.nbt.primitives.BooleanPrimitive;
+import io.papermc.paper.property.nbt.primitives.BytePrimitive;
+import io.papermc.paper.property.nbt.primitives.ColorNbtPrimitive;
+import io.papermc.paper.property.nbt.primitives.ComponentNbtPrimitive;
+import io.papermc.paper.property.nbt.primitives.IntegerPrimitive;
+import io.papermc.paper.property.nbt.primitives.ItemStackNbtPrimitive;
+import io.papermc.paper.property.nbt.primitives.KeyedRegistryPrimitive;
+import io.papermc.paper.property.nbt.primitives.NamespaceKeyNbtPrimitive;
+import io.papermc.paper.property.nbt.primitives.StringPrimitive;
+import io.papermc.paper.property.nbt.types.AttributeMap;
+import io.papermc.paper.property.nbt.types.AxolotlVariantNbt;
+import io.papermc.paper.property.nbt.types.BlockStateConditionNamespaceHackNbt;
+import io.papermc.paper.property.nbt.types.CompoundTagNbt;
+import io.papermc.paper.property.nbt.types.CustomEffectNbt;
+import io.papermc.paper.property.nbt.types.EnchantmentList;
+import io.papermc.paper.property.nbt.types.FireworkEffectNbt;
+import io.papermc.paper.property.nbt.types.GameProfileNbt;
+import io.papermc.paper.property.nbt.types.ItemFlagBitset;
+import io.papermc.paper.property.nbt.types.PotionDataNbt;
+import io.papermc.paper.property.nbt.types.StewEffectsListNbt;
+import io.papermc.paper.property.nbt.types.TropicalFishVariantNbt;
+import io.papermc.paper.property.nbt.types.WrappedListNbt;
+import org.bukkit.MusicInstrument;
+
+public class ItemPropertyRegistration {
+
+    public static final AdapterContext ITEM_CONTEXT = new AdapterContext();
+    static  {
+        ITEM_CONTEXT.register(ItemProperties.ENCHANTMENTS, new EnchantmentList());
+        ITEM_CONTEXT.register(ItemProperties.UNBREAKABLE, new BooleanPrimitive());
+        ITEM_CONTEXT.register(ItemProperties.CAN_PLACE_ON_BLOCK_LIST, new WrappedListNbt(new BlockStateConditionNamespaceHackNbt()));
+        ITEM_CONTEXT.register(ItemProperties.CAN_DESTROY_BLOCK_LIST, new WrappedListNbt(new BlockStateConditionNamespaceHackNbt()));
+        ITEM_CONTEXT.register(ItemProperties.HIDE_FLAGS, new ItemFlagBitset());
+        ITEM_CONTEXT.register(ItemProperties.REPAIR_COST, new IntegerPrimitive());
+        ITEM_CONTEXT.register(ItemProperties.CUSTOM_MODEL_DATA, new IntegerPrimitive());
+        ITEM_CONTEXT.register(ItemProperties.DAMAGE, new IntegerPrimitive());
+        ITEM_CONTEXT.register(ItemProperties.ATTRIBUTES, new AttributeMap());
+        ITEM_CONTEXT.register(ItemProperties.BLOCK_STATE, new CompoundTagNbt(ITEM_CONTEXT));
+        ITEM_CONTEXT.register(ItemProperties.ENTITY_TAG, new CompoundTagNbt(ITEM_CONTEXT));
+
+        ITEM_CONTEXT.register(ItemProperties.DISPLAY, new CompoundTagNbt(ITEM_CONTEXT));
+        ITEM_CONTEXT.register(ItemProperties.DISPLAY_NAME, new ComponentNbtPrimitive());
+        ITEM_CONTEXT.register(ItemProperties.COLOR, new ColorNbtPrimitive());
+        ITEM_CONTEXT.register(ItemProperties.MAP_COLOR, new ColorNbtPrimitive());
+
+        ITEM_CONTEXT.register(ItemProperties.PUBLIC_BUKKIT_VALUES, new CompoundTagNbt(ITEM_CONTEXT));
+        ITEM_CONTEXT.register(ItemProperties.LOC_NAME, new StringPrimitive());
+
+        ITEM_CONTEXT.register(ItemProperties.TROPICAL_FISH_BUCKET_VARIANT, new TropicalFishVariantNbt());
+
+        ITEM_CONTEXT.register(ItemProperties.STEW_EFFECTS, new StewEffectsListNbt());
+
+        ITEM_CONTEXT.register(ItemProperties.SKULL_OWNER, new GameProfileNbt());
+        ITEM_CONTEXT.register(ItemProperties.SKULL_OWNER_NAME, new StringPrimitive());
+
+        // TODO: Potion
+        ITEM_CONTEXT.register(ItemProperties.CUSTOM_POTION_EFFECTS, new WrappedListNbt<>(new CustomEffectNbt()));
+        ITEM_CONTEXT.register(ItemProperties.DEFAULT_POTION_TYPE, new PotionDataNbt());
+
+        ITEM_CONTEXT.register(ItemProperties.MAP_ID, new IntegerPrimitive());
+        ITEM_CONTEXT.register(ItemProperties.MAP_SCALE_DIRECTION, new BytePrimitive());
+        ITEM_CONTEXT.register(ItemProperties.MAP_TO_LOCK, new BooleanPrimitive());
+
+        ITEM_CONTEXT.register(ItemProperties.RECIPES, new WrappedListNbt<>(new NamespaceKeyNbtPrimitive()));
+
+        ITEM_CONTEXT.register(ItemProperties.FIREWORKS, new CompoundTagNbt(ITEM_CONTEXT));
+        ITEM_CONTEXT.register(ItemProperties.FLIGHT, new BytePrimitive());
+        ITEM_CONTEXT.register(ItemProperties.EXPLOSIONS, new WrappedListNbt<>(new FireworkEffectNbt()));
+
+        ITEM_CONTEXT.register(ItemProperties.STORED_ENCHANTMENTS, new EnchantmentList());
+
+        ITEM_CONTEXT.register(ItemProperties.CHARGED, new BooleanPrimitive());
+        ITEM_CONTEXT.register(ItemProperties.CHARGED_PROJECTILES, new WrappedListNbt<>(new ItemStackNbtPrimitive()));
+
+        ITEM_CONTEXT.register(ItemProperties.LODESTONE_POS, new BlockPositionNbtPrimitive());
+        ITEM_CONTEXT.register(ItemProperties.LODESTONE_DIMENSION, new NamespaceKeyNbtPrimitive());
+        ITEM_CONTEXT.register(ItemProperties.LODESTONE_TRACKED, new BooleanPrimitive());
+
+        ITEM_CONTEXT.register(ItemProperties.ITEMS, new WrappedListNbt<>(new ItemStackNbtPrimitive()));
+
+        ITEM_CONTEXT.register(ItemProperties.TITLE, new StringPrimitive());
+        ITEM_CONTEXT.register(ItemProperties.TITLE_FILTERED, new StringPrimitive());
+        ITEM_CONTEXT.register(ItemProperties.AUTHOR, new StringPrimitive());
+        ITEM_CONTEXT.register(ItemProperties.PAGES, new WrappedListNbt<>(new ComponentNbtPrimitive()));
+        ITEM_CONTEXT.register(ItemProperties.PAGES_FILTERED, new WrappedListNbt<>(new ComponentNbtPrimitive()));
+        ITEM_CONTEXT.register(ItemProperties.GENERATION, new IntegerPrimitive());
+        ITEM_CONTEXT.register(ItemProperties.RESOLVED, new BooleanPrimitive());
+
+        ITEM_CONTEXT.register(ItemProperties.PAGES_WRITTEN, new WrappedListNbt<>(new StringPrimitive()));
+        ITEM_CONTEXT.register(ItemProperties.BLOCK_ENTITY_TAG, new CompoundTagNbt(ITEM_CONTEXT));
+        ITEM_CONTEXT.register(ItemProperties.NOTE_BLOCK_SOUND, new NamespaceKeyNbtPrimitive());
+        ITEM_CONTEXT.register(ItemProperties.VARIANT, new AxolotlVariantNbt());
+
+        ITEM_CONTEXT.register(ItemProperties.INSTRUMENT, new KeyedRegistryPrimitive<>(MusicInstrument::getByKey, MusicInstrument::getKey));
+
+        ITEM_CONTEXT.lockRegistration();
+    }
+
+
+}
diff --git a/src/main/java/io/papermc/paper/property/adapter/TypeAdapter.java b/src/main/java/io/papermc/paper/property/adapter/TypeAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..6f19ef7ac64677b08769c35cd805acb5edff69a7
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/adapter/TypeAdapter.java
@@ -0,0 +1,10 @@
+package io.papermc.paper.property.adapter;
+
+public interface TypeAdapter<PLATFORM_TYPE, RUNTIME_TYPE> {
+
+    PLATFORM_TYPE toPlatform(RUNTIME_TYPE runtimeType);
+
+    RUNTIME_TYPE toRuntime(PLATFORM_TYPE platformType);
+
+
+}
diff --git a/src/main/java/io/papermc/paper/property/adapter/ValueTypeAdapter.java b/src/main/java/io/papermc/paper/property/adapter/ValueTypeAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..16aea9c70aa79fe0120f23354e6a94974c62aeef
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/adapter/ValueTypeAdapter.java
@@ -0,0 +1,13 @@
+package io.papermc.paper.property.adapter;
+
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.PropertyView;
+
+public interface ValueTypeAdapter<RUNTIME_TYPE, HOLDER extends PropertyView> {
+
+    RUNTIME_TYPE getValue(HOLDER holder, PropertyKey<RUNTIME_TYPE> propertyKey);
+
+    void writeDirect(HOLDER holder, PropertyKey<?> propertyKey, RUNTIME_TYPE direct);
+
+    RUNTIME_TYPE getNewValue(HOLDER holder, PropertyKey<RUNTIME_TYPE> propertyKey);
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/AdapterContext.java b/src/main/java/io/papermc/paper/property/nbt/AdapterContext.java
new file mode 100644
index 0000000000000000000000000000000000000000..b8f9b584ca86b1348d0980a2ded20a555d36bc5f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/AdapterContext.java
@@ -0,0 +1,45 @@
+package io.papermc.paper.property.nbt;
+
+import io.papermc.paper.property.PropertyKey;
+import org.bukkit.util.Consumer;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class AdapterContext {
+
+    private final Map<PropertyKey<?>, NbtPlatformAdapter<?>> adapters = new HashMap<>();
+    private boolean locked = false;
+
+    public static AdapterContext empty() {
+        return new AdapterContext();
+    }
+
+    public <T> void register(PropertyKey<T> key, NbtPlatformAdapter<T> adapter) {
+        if (locked) {
+            throw new IllegalStateException("Cannot dynamically register property types");
+        }
+
+        this.adapters.put(key, adapter);
+    }
+
+    public void lockRegistration() {
+        this.locked = true;
+    }
+
+    public static AdapterContext of(Consumer<AdapterContext> consumer) {
+        AdapterContext context = new AdapterContext();
+        consumer.accept(context);
+        context.lockRegistration();
+        return context;
+    }
+
+
+    public NbtPlatformAdapter getAdapter(PropertyKey key) {
+        NbtPlatformAdapter adapter = this.adapters.get(key);
+        if (adapter == null) {
+            throw new UnsupportedOperationException("Unimplemented adapter for NBT tag: " + key);
+        }
+        return adapter;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/NbtPlatformAdapter.java b/src/main/java/io/papermc/paper/property/nbt/NbtPlatformAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..661bda75180e9a56ac21ad9b31a7eacae1fd50cf
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/NbtPlatformAdapter.java
@@ -0,0 +1,12 @@
+package io.papermc.paper.property.nbt;
+
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.adapter.ValueTypeAdapter;
+
+public interface NbtPlatformAdapter<TYPE> extends ValueTypeAdapter<TYPE, NbtPropertyHolder> {
+    int getTagType();
+
+    default void removeDirect(NbtPropertyHolder nbtPropertyHolder, PropertyKey<TYPE> propertyKey) {
+        nbtPropertyHolder.getCompoundTag().remove(propertyKey.getKey());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/NbtPropertyHolder.java b/src/main/java/io/papermc/paper/property/nbt/NbtPropertyHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..15ebf2de47c4d5d7b831047258eec630d9517c87
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/NbtPropertyHolder.java
@@ -0,0 +1,152 @@
+package io.papermc.paper.property.nbt;
+
+import io.papermc.paper.item.property.ItemPropertyRegistration;
+import io.papermc.paper.property.MutablePropertyView;
+import io.papermc.paper.property.PropertyKey;
+import net.minecraft.nbt.CompoundTag;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Objects;
+import java.util.Set;
+
+@SuppressWarnings("unchecked")
+public class NbtPropertyHolder implements MutablePropertyView {
+
+    private final AdapterContext adapterContext;
+    private final CompoundTag compoundTag;
+
+    // TODO cleanup.
+    // Properly pass a context object in places
+    public static NbtPropertyHolder simpleBlob(CompoundTag compoundTag, AdapterContext context) {
+        return new NbtPropertyHolder(context, compoundTag);
+    }
+
+    NbtPropertyHolder(AdapterContext adapterContext, CompoundTag compoundTag) {
+        if (compoundTag == null) {
+            throw new IllegalArgumentException("Cannot have null compound tag.");
+        }
+
+        this.adapterContext = adapterContext;
+        this.compoundTag = compoundTag;
+    }
+
+    public static MutablePropertyView itemHolder(CompoundTag compoundTag) {
+        return io.papermc.paper.property.nbt.NbtPropertyHolder.simpleBlob(compoundTag, ItemPropertyRegistration.ITEM_CONTEXT);
+    }
+
+    public static MutablePropertyView empty() {
+        return new NbtPropertyHolder(AdapterContext.empty(), new CompoundTag());
+    }
+
+    @Override
+    public void unset(PropertyKey<?> key) {
+        this.compoundTag.remove(key.getKey());
+    }
+
+    @Override
+    public <T> void set(@NotNull PropertyKey<T> key, T value) {
+        NbtPlatformAdapter adapter = this.getAdapter(key);
+        if (value != null) {
+            adapter.writeDirect(this, key, value);
+        } else {
+            adapter.removeDirect(this, key);
+        }
+    }
+
+    @Override
+    public <T> @NotNull T create(@NotNull PropertyKey<T> key) {
+        NbtPlatformAdapter adapter = this.getAdapter(key);
+        return (T) adapter.getNewValue(this, key);
+    }
+
+    @Override
+    public <T> T getOrCreate(@NotNull PropertyKey<T> key) {
+        NbtPlatformAdapter adapter = this.getAdapter(key);
+
+        if (!this.compoundTag.contains(key.getKey(), adapter.getTagType())) {
+            return (T) adapter.getNewValue(this, key);
+        }
+
+        return (T) adapter.getValue(this, key);
+    }
+
+    @Override
+    public MutablePropertyView clone() {
+        CompoundTag cloned = this.compoundTag.copy();
+        return new NbtPropertyHolder(this.adapterContext, cloned);
+    }
+
+    @Override
+    public void clear() {
+        this.compoundTag.tags.clear();
+    }
+
+    @Override
+    public <T> @Nullable T get(PropertyKey<T> key) {
+        NbtPlatformAdapter adapter = this.getAdapter(key);
+        if (adapter == null) {
+            throw new UnsupportedOperationException("No adapter for: " + key);
+        }
+
+        return (T) adapter.getValue(this, key);
+    }
+
+    @Override
+    public <T> @Nullable T getOrDefault(@NotNull PropertyKey<T> key, T defaultValue) {
+        T returnedValue = this.get(key);
+        if (returnedValue == null) {
+            return defaultValue;
+        }
+
+        return returnedValue;
+    }
+
+    @Override
+    public boolean hasProperty(@NotNull PropertyKey<?> propertyKey) {
+        return this.compoundTag.contains(propertyKey.getKey());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return this.compoundTag.isEmpty();
+    }
+
+    public @NotNull Set<String> keySet() {
+        return this.compoundTag.getAllKeys();
+    }
+
+
+    public CompoundTag getCompoundTag() {
+        return compoundTag;
+    }
+
+    public NbtPlatformAdapter getAdapter(PropertyKey key) {
+        return this.adapterContext.getAdapter(key);
+    }
+
+    public AdapterContext getContext() {
+        return this.adapterContext;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        NbtPropertyHolder holder = (NbtPropertyHolder) o;
+        return Objects.equals(compoundTag, holder.compoundTag);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(compoundTag);
+    }
+
+    @Override
+    public String toString() {
+        return "NbtPropertyHolder{" +
+            "adapterContext=" + adapterContext +
+            ", compoundTag=" + compoundTag +
+            '}';
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/pdc/LivePersistentDataContainer.java b/src/main/java/io/papermc/paper/property/nbt/pdc/LivePersistentDataContainer.java
new file mode 100644
index 0000000000000000000000000000000000000000..cb596c72d3e141077597b5f35b26a7d33106fe3b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/pdc/LivePersistentDataContainer.java
@@ -0,0 +1,170 @@
+package io.papermc.paper.property.nbt.pdc;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.Tag;
+import org.apache.commons.lang.Validate;
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.persistence.CraftPersistentDataAdapterContext;
+import org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry;
+import org.bukkit.persistence.PersistentDataAdapterContext;
+import org.bukkit.persistence.PersistentDataContainer;
+import org.bukkit.persistence.PersistentDataType;
+
+import java.util.HashSet;
+import java.util.Objects;
+import java.util.Set;
+
+public class LivePersistentDataContainer implements PersistentDataContainer {
+
+    private final CompoundTag compoundTag;
+    private final CraftPersistentDataTypeRegistry registry;
+    private final CraftPersistentDataAdapterContext adapterContext;
+
+    public LivePersistentDataContainer(CompoundTag compoundTag, CraftPersistentDataTypeRegistry registry) {
+        this.compoundTag = compoundTag;
+        this.registry = registry;
+        this.adapterContext = new CraftPersistentDataAdapterContext(this.registry);
+    }
+
+
+    @Override
+    public <T, Z> void set(NamespacedKey key, PersistentDataType<T, Z> type, Z value) {
+        Validate.notNull(key, "The provided key for the custom value was null");
+        Validate.notNull(type, "The provided type for the custom value was null");
+        Validate.notNull(value, "The provided value for the custom value was null");
+
+        this.compoundTag.put(key.toString(), this.registry.wrap(type.getPrimitiveType(), type.toPrimitive(value, adapterContext)));
+    }
+
+    @Override
+    public <T, Z> boolean has(NamespacedKey key, PersistentDataType<T, Z> type) {
+        Validate.notNull(key, "The provided key for the custom value was null");
+        Validate.notNull(type, "The provided type for the custom value was null");
+
+        Tag value = this.compoundTag.get(key.toString());
+        if (value == null) {
+            return false;
+        }
+
+        return this.registry.isInstanceOf(type.getPrimitiveType(), value);
+    }
+
+    @Override
+    public <T, Z> Z get(NamespacedKey key, PersistentDataType<T, Z> type) {
+        Validate.notNull(key, "The provided key for the custom value was null");
+        Validate.notNull(type, "The provided type for the custom value was null");
+
+        Tag value = this.compoundTag.get(key.toString());
+        if (value == null) {
+            return null;
+        }
+
+        return type.fromPrimitive(this.registry.extract(type.getPrimitiveType(), value), adapterContext);
+    }
+
+    @Override
+    public <T, Z> Z getOrDefault(NamespacedKey key, PersistentDataType<T, Z> type, Z defaultValue) {
+        Z z = this.get(key, type);
+        return z != null ? z : defaultValue;
+    }
+
+    @Override
+    public Set<NamespacedKey> getKeys() {
+        Set<NamespacedKey> keys = new HashSet<>();
+
+        this.compoundTag.getAllKeys().forEach(key -> {
+            String[] keyData = key.split(":", 2);
+            if (keyData.length == 2) {
+                keys.add(new NamespacedKey(keyData[0], keyData[1]));
+            }
+        });
+
+        return keys;
+    }
+
+    @Override
+    public void remove(NamespacedKey key) {
+        Validate.notNull(key, "The provided key for the custom value was null");
+
+        this.compoundTag.remove(key.toString());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return this.compoundTag.isEmpty();
+    }
+
+    @Override
+    public PersistentDataAdapterContext getAdapterContext() {
+        return this.adapterContext;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        LivePersistentDataContainer that = (LivePersistentDataContainer) o;
+        return Objects.equals(compoundTag, that.compoundTag);
+    }
+
+    public CompoundTag toTagCompound() {
+        return compoundTag;
+    }
+
+    public void put(String key, Tag base) {
+        this.compoundTag.put(key, base);
+    }
+
+    public void putAll(CompoundTag compound) {
+        for (String key : compound.getAllKeys()) {
+            this.compoundTag.put(key, compound.get(key));
+        }
+    }
+
+
+    public CraftPersistentDataTypeRegistry getDataTagTypeRegistry() {
+        return this.registry;
+    }
+
+    @Override
+    public int hashCode() {
+        int hashCode = 3;
+        hashCode += this.compoundTag.hashCode(); // We will simply add the maps hashcode
+        return hashCode;
+    }
+
+
+    // Paper start
+    public void clear() {
+        this.compoundTag.tags.clear();
+    }
+
+    @Override
+    public boolean has(NamespacedKey key) {
+        Validate.notNull(key, "The provided key for the custom value was null");
+
+        return this.compoundTag.contains(key.toString());
+    }
+
+    @Override
+    public byte[] serializeToBytes() throws java.io.IOException {
+        net.minecraft.nbt.CompoundTag root = this.toTagCompound();
+        java.io.ByteArrayOutputStream byteArrayOutput = new java.io.ByteArrayOutputStream();
+        try (java.io.DataOutputStream dataOutput = new java.io.DataOutputStream(byteArrayOutput)) {
+            net.minecraft.nbt.NbtIo.write(root, dataOutput);
+            return byteArrayOutput.toByteArray();
+        }
+    }
+
+    @Override
+    public void readFromBytes(byte[] bytes, boolean clear) throws java.io.IOException {
+        if (clear) {
+            this.clear();
+        }
+        try (java.io.DataInputStream dataInput = new java.io.DataInputStream(new java.io.ByteArrayInputStream(bytes))) {
+            net.minecraft.nbt.CompoundTag compound = net.minecraft.nbt.NbtIo.read(dataInput);
+            this.putAll(compound);
+        }
+    }
+    // Paper end
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/AbstractListNbtPlatformAdapter.java b/src/main/java/io/papermc/paper/property/nbt/primitives/AbstractListNbtPlatformAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..440e2b3019363aaa6079932a3e12717311c21515
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/AbstractListNbtPlatformAdapter.java
@@ -0,0 +1,47 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.util.TransformingRandomAccessList;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.Tag;
+
+import java.util.List;
+
+public abstract class AbstractListNbtPlatformAdapter<T> extends NbtPrimitiveWrapper<List<T>, ListTag> {
+
+    public AbstractListNbtPlatformAdapter() {
+        super(new ListTagPrimitive());
+    }
+
+    @Override
+    public List<T> fromPrimitive(ListTag primitive) {
+        return new TransformingRandomAccessList<>(primitive.list, this::deserialize, this::serialize);
+    }
+
+    @Override
+    public ListTag toPrimitive(List<T> type) {
+        ListTag listTag = new ListTag();
+        for (T object : type) {
+            listTag.add(serialize(object));
+        }
+
+        return listTag;
+    }
+
+    public abstract T deserialize(Tag tag);
+
+    public abstract Tag serialize(T value);
+
+    @Override
+    public List<T> getNewValue(NbtPropertyHolder holder, PropertyKey<List<T>> propertyKey) {
+        holder.getCompoundTag().put(propertyKey.getKey(), new ListTag());
+        return this.getValue(holder, propertyKey);
+    }
+
+    @Override
+    public int getTagType() {
+        return Tag.TAG_LIST;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/BlockPositionNbtPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/BlockPositionNbtPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..7eed7ce505090bb1f455976aec256c0f051612f4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/BlockPositionNbtPrimitive.java
@@ -0,0 +1,26 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import io.papermc.paper.math.Position;
+import net.minecraft.core.BlockPos;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtUtils;
+import net.minecraft.nbt.Tag;
+
+public class BlockPositionNbtPrimitive extends SinglePrimitiveNbtPlatformAdapter<Position> {
+
+    @Override
+    public int getTagType() {
+        return Tag.TAG_COMPOUND;
+    }
+
+    @Override
+    public Position getType(Tag tag) {
+        BlockPos pos = NbtUtils.readBlockPos((CompoundTag) tag);
+        return Position.block(pos.getX(), pos.getY(), pos.getZ());
+    }
+
+    @Override
+    public Tag write(Position type) {
+        return NbtUtils.writeBlockPos(new BlockPos(type.blockZ(), type.blockY(), type.blockZ()));
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/BooleanPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/BooleanPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..1b192a7cb4196ad94c8ebbe4590280c103b8de84
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/BooleanPrimitive.java
@@ -0,0 +1,24 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import net.minecraft.nbt.ByteTag;
+import net.minecraft.nbt.IntTag;
+import net.minecraft.nbt.Tag;
+
+public class BooleanPrimitive extends SinglePrimitiveNbtPlatformAdapter<Boolean> {
+
+    @Override
+    public int getTagType() {
+        return IntTag.TAG_BYTE;
+    }
+
+    @Override
+    public Boolean getType(Tag tag) {
+        return ((ByteTag) tag).getAsByte() != 0;
+    }
+
+    @Override
+    public Tag write(Boolean type) {
+        return ByteTag.valueOf(type);
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/BytePrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/BytePrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..70d6603f2d28d93e4b7ae87079199e3160c1d849
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/BytePrimitive.java
@@ -0,0 +1,24 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import net.minecraft.nbt.ByteTag;
+import net.minecraft.nbt.IntTag;
+import net.minecraft.nbt.Tag;
+
+public class BytePrimitive extends SinglePrimitiveNbtPlatformAdapter<Byte> {
+
+    @Override
+    public int getTagType() {
+        return IntTag.TAG_BYTE;
+    }
+
+    @Override
+    public Byte getType(Tag tag) {
+        return ((ByteTag) tag).getAsByte();
+    }
+
+    @Override
+    public Tag write(Byte type) {
+        return ByteTag.valueOf(type);
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/ColorNbtPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/ColorNbtPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..65a9fb79a91ade533128d36ef8ac88bbbba27415
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/ColorNbtPrimitive.java
@@ -0,0 +1,20 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import org.bukkit.Color;
+
+public class ColorNbtPrimitive extends NbtPrimitiveWrapper<Color, Integer> {
+
+    public ColorNbtPrimitive() {
+        super(new IntegerPrimitive());
+    }
+
+    @Override
+    public Color fromPrimitive(Integer primitive) {
+        return Color.fromRGB(primitive);
+    }
+
+    @Override
+    public Integer toPrimitive(Color type) {
+        return type.asRGB();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/ComponentNbtPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/ComponentNbtPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..fd501ae1b53eacfd1a83d5c8268709333f247b47
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/ComponentNbtPrimitive.java
@@ -0,0 +1,21 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
+
+public class ComponentNbtPrimitive extends NbtPrimitiveWrapper<Component, String> {
+
+    public ComponentNbtPrimitive() {
+        super(new StringPrimitive());
+    }
+
+    @Override
+    public Component fromPrimitive(String primitive) {
+        return GsonComponentSerializer.gson().deserialize(primitive);
+    }
+
+    @Override
+    public String toPrimitive(Component type) {
+        return GsonComponentSerializer.gson().serialize(type);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/CompoundTagPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/CompoundTagPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..309327df89e33f021762affb2484fffbf953fac0
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/CompoundTagPrimitive.java
@@ -0,0 +1,23 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.IntTag;
+import net.minecraft.nbt.Tag;
+
+public class CompoundTagPrimitive extends SinglePrimitiveNbtPlatformAdapter<CompoundTag> {
+
+    @Override
+    public int getTagType() {
+        return IntTag.TAG_COMPOUND;
+    }
+
+    @Override
+    public CompoundTag getType(Tag tag) {
+        return (CompoundTag) tag;
+    }
+
+    @Override
+    public Tag write(CompoundTag type) {
+        return type;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/IntArrayPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/IntArrayPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..a66284228f7d15af7b95fe84577c4a9d120b2eb8
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/IntArrayPrimitive.java
@@ -0,0 +1,24 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import net.minecraft.nbt.IntArrayTag;
+import net.minecraft.nbt.IntTag;
+import net.minecraft.nbt.Tag;
+
+public class IntArrayPrimitive extends SinglePrimitiveNbtPlatformAdapter<int[]> {
+
+    @Override
+    public int getTagType() {
+        return IntTag.TAG_INT_ARRAY;
+    }
+
+    @Override
+    public int[] getType(Tag tag) {
+        return ((IntArrayTag) tag).getAsIntArray();
+    }
+
+    @Override
+    public Tag write(int[] type) {
+        return new IntArrayTag(type);
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/IntegerPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/IntegerPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..ca3d8e62c6cf7d16fa6af95a2e37a04550e2f0f2
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/IntegerPrimitive.java
@@ -0,0 +1,23 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import net.minecraft.nbt.IntTag;
+import net.minecraft.nbt.Tag;
+
+public class IntegerPrimitive extends SinglePrimitiveNbtPlatformAdapter<Integer> {
+
+    @Override
+    public int getTagType() {
+        return IntTag.TAG_INT;
+    }
+
+    @Override
+    public Integer getType(Tag tag) {
+        return ((IntTag) tag).getAsInt();
+    }
+
+    @Override
+    public Tag write(Integer type) {
+        return IntTag.valueOf(type);
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/ItemStackNbtPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/ItemStackNbtPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..a2f422db63ca15889d66c70072dd7da87a4a2f83
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/ItemStackNbtPrimitive.java
@@ -0,0 +1,24 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.Tag;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.inventory.ItemStack;
+
+public class ItemStackNbtPrimitive extends SinglePrimitiveNbtPlatformAdapter<ItemStack> {
+
+    @Override
+    public int getTagType() {
+        return Tag.TAG_COMPOUND;
+    }
+
+    @Override
+    public ItemStack getType(Tag tag) {
+        return CraftItemStack.asCraftMirror(net.minecraft.world.item.ItemStack.of((CompoundTag) tag));
+    }
+
+    @Override
+    public Tag write(ItemStack type) {
+        return (type instanceof CraftItemStack ? ((CraftItemStack) type).handle : CraftItemStack.asNMSCopy(type)).save(new CompoundTag());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/KeyedRegistryPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/KeyedRegistryPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..6ba22dfca32d26a32838b3fa42c18b4e9d379204
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/KeyedRegistryPrimitive.java
@@ -0,0 +1,28 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import org.bukkit.NamespacedKey;
+
+import java.util.function.Function;
+
+public class KeyedRegistryPrimitive<T> extends NbtPrimitiveWrapper<T, NamespacedKey> {
+
+    private final Function<NamespacedKey, T> consumer;
+    private final Function<T, NamespacedKey> converter;
+
+    public KeyedRegistryPrimitive(Function<NamespacedKey, T> consumer, Function<T, NamespacedKey> converter) {
+        super(new NamespaceKeyNbtPrimitive());
+        this.consumer = consumer;
+        this.converter = converter;
+    }
+
+
+    @Override
+    public T fromPrimitive(NamespacedKey primitive) {
+        return this.consumer.apply(primitive);
+    }
+
+    @Override
+    public NamespacedKey toPrimitive(T type) {
+        return this.converter.apply(type);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/ListTagPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/ListTagPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..a090b21fd707f3941f89ffa2657685f268245c9e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/ListTagPrimitive.java
@@ -0,0 +1,23 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import net.minecraft.nbt.IntTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.Tag;
+
+public class ListTagPrimitive extends SinglePrimitiveNbtPlatformAdapter<ListTag> {
+
+    @Override
+    public int getTagType() {
+        return IntTag.TAG_LIST;
+    }
+
+    @Override
+    public ListTag getType(Tag tag) {
+        return (ListTag) tag;
+    }
+
+    @Override
+    public Tag write(ListTag type) {
+        return type;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/NamespaceKeyNbtPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/NamespaceKeyNbtPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..c1fe17fd099b09655c36ee1d42385764cfd38816
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/NamespaceKeyNbtPrimitive.java
@@ -0,0 +1,20 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import org.bukkit.NamespacedKey;
+
+public class NamespaceKeyNbtPrimitive extends NbtPrimitiveWrapper<NamespacedKey, String> {
+
+    public NamespaceKeyNbtPrimitive() {
+        super(new StringPrimitive());
+    }
+
+    @Override
+    public NamespacedKey fromPrimitive(String primitive) {
+        return NamespacedKey.fromString(primitive);
+    }
+
+    @Override
+    public String toPrimitive(NamespacedKey type) {
+        return type.toString();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/NbtPrimitiveWrapper.java b/src/main/java/io/papermc/paper/property/nbt/primitives/NbtPrimitiveWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..434601041bb94248902f82d9409e6ab1162f9e9f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/NbtPrimitiveWrapper.java
@@ -0,0 +1,41 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.Tag;
+
+public abstract class NbtPrimitiveWrapper<T, P> extends SinglePrimitiveNbtPlatformAdapter<T> {
+
+    private final SinglePrimitiveNbtPlatformAdapter<P> primitive;
+
+    public NbtPrimitiveWrapper(SinglePrimitiveNbtPlatformAdapter<P> primitive) {
+        this.primitive = primitive;
+    }
+
+    @Override
+    public int getTagType() {
+        return this.primitive.getTagType();
+    }
+
+    @Override
+    public T getType(Tag tag) {
+        return this.fromPrimitive(this.primitive.getType(tag));
+    }
+
+    @Override
+    public Tag write(T type) {
+        return this.primitive.write(this.toPrimitive(type));
+    }
+
+    @Override
+    public T getNewValue(NbtPropertyHolder holder, PropertyKey<T> propertyKey) {
+        holder.getCompoundTag().put(propertyKey.getKey(), new CompoundTag());
+        return this.getValue(holder, propertyKey);
+    }
+
+    public abstract T fromPrimitive(P primitive);
+
+    public abstract P toPrimitive(T type);
+
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/SinglePrimitiveNbtPlatformAdapter.java b/src/main/java/io/papermc/paper/property/nbt/primitives/SinglePrimitiveNbtPlatformAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..7d1e2484459d4ce2ef41df67f8b2ac0113d4e962
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/SinglePrimitiveNbtPlatformAdapter.java
@@ -0,0 +1,44 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.nbt.NbtPlatformAdapter;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import net.minecraft.nbt.Tag;
+
+public abstract class SinglePrimitiveNbtPlatformAdapter<T> implements NbtPlatformAdapter<T> {
+
+    @Override
+    public T getValue(NbtPropertyHolder holder, PropertyKey<T> propertyKey) {
+
+        // See get direct
+        Tag tag = holder.getCompoundTag().get(propertyKey.getKey());
+        if (tag != null && tag.getId() == SinglePrimitiveNbtPlatformAdapter.this.getTagType()) {
+            return SinglePrimitiveNbtPlatformAdapter.this.getType(tag);
+        }
+
+        return null;
+    }
+
+    @Override
+    public T getNewValue(NbtPropertyHolder holder, PropertyKey<T> propertyKey) {
+        return null;
+    }
+
+    public T getDirect(NbtPropertyHolder holder, PropertyKey<?> propertyKey) {
+        Tag tag = holder.getCompoundTag().get(propertyKey.getKey());
+        if (tag != null && tag.getId() == SinglePrimitiveNbtPlatformAdapter.this.getTagType()) {
+            return SinglePrimitiveNbtPlatformAdapter.this.getType(tag);
+        }
+
+        return null;
+    }
+
+    @Override
+    public void writeDirect(NbtPropertyHolder holder, PropertyKey<?> propertyKey, T direct) {
+        holder.getCompoundTag().put(propertyKey.getKey(), this.write(direct));
+    }
+
+    public abstract T getType(Tag tag);
+
+    public abstract Tag write(T type);
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/primitives/StringPrimitive.java b/src/main/java/io/papermc/paper/property/nbt/primitives/StringPrimitive.java
new file mode 100644
index 0000000000000000000000000000000000000000..9e4dfed6ac406391ac3205b0e9028ff1607a7f54
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/primitives/StringPrimitive.java
@@ -0,0 +1,24 @@
+package io.papermc.paper.property.nbt.primitives;
+
+import net.minecraft.nbt.IntTag;
+import net.minecraft.nbt.StringTag;
+import net.minecraft.nbt.Tag;
+
+public class StringPrimitive extends SinglePrimitiveNbtPlatformAdapter<String> {
+
+    @Override
+    public int getTagType() {
+        return IntTag.TAG_STRING;
+    }
+
+    @Override
+    public String getType(Tag tag) {
+        return ((StringTag) tag).getAsString();
+    }
+
+    @Override
+    public Tag write(String type) {
+        return StringTag.valueOf(type);
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/AttributeMap.java b/src/main/java/io/papermc/paper/property/nbt/types/AttributeMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..6021403c5a0e8b1f5dec5d503e92baf0597dc181
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/AttributeMap.java
@@ -0,0 +1,69 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.inventory.item.properties.AttributePair;
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.nbt.AdapterContext;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.nbt.primitives.AbstractListNbtPlatformAdapter;
+import io.papermc.paper.property.nbt.primitives.StringPrimitive;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.resources.ResourceLocation;
+import org.bukkit.Registry;
+import org.bukkit.attribute.Attribute;
+import org.bukkit.attribute.AttributeModifier;
+import org.bukkit.craftbukkit.CraftEquipmentSlot;
+import org.bukkit.craftbukkit.attribute.CraftAttributeInstance;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+
+import java.util.Optional;
+
+public class AttributeMap extends AbstractListNbtPlatformAdapter<AttributePair> {
+
+    private static final PropertyKey<String> ATTRIBUTE_SLOT = PropertyKey.of("Slot", String.class);
+    private static final PropertyKey<String> ATTRIBUTE_NAME = PropertyKey.of("AttributeName", String.class);
+    private static final StringPrimitive PRIMITIVE = new StringPrimitive();
+
+    @Override
+    public AttributePair deserialize(Tag tag) {
+        CompoundTag compoundTag = (CompoundTag) tag;
+        NbtPropertyHolder holder = NbtPropertyHolder.simpleBlob(compoundTag, AdapterContext.of((context) -> {
+            context.register(ATTRIBUTE_NAME, new StringPrimitive());
+        }));
+
+        ResourceLocation attributeName = ResourceLocation.tryParse(PRIMITIVE.getDirect(holder, ATTRIBUTE_NAME));
+
+        Optional<net.minecraft.world.entity.ai.attributes.Attribute> optional = BuiltInRegistries.ATTRIBUTE.getOptional(attributeName);
+        if (optional.isPresent()) {
+            net.minecraft.world.entity.ai.attributes.AttributeModifier modifier = net.minecraft.world.entity.ai.attributes.AttributeModifier.load(compoundTag);
+            return new AttributePairImpl(Registry.ATTRIBUTE.get(CraftNamespacedKey.fromMinecraft(attributeName)), CraftAttributeInstance.convert(modifier));
+        }
+
+        return null;
+    }
+
+    @Override
+    public Tag serialize(AttributePair value) {
+        AttributeModifier attributeModifier = value.modifier();
+        net.minecraft.world.entity.ai.attributes.AttributeModifier nmsModifier = CraftAttributeInstance.convert(attributeModifier);
+
+        NbtPropertyHolder attributeHolder = NbtPropertyHolder.simpleBlob(nmsModifier.save(), AdapterContext.of((context) -> {
+            context.register(ATTRIBUTE_NAME, new StringPrimitive());
+            context.register(ATTRIBUTE_SLOT, new StringPrimitive());
+        }));
+
+        attributeHolder.set(ATTRIBUTE_NAME, attributeModifier.getName());
+        if (attributeModifier.getSlot() != null) {
+            attributeHolder.set(ATTRIBUTE_SLOT, CraftEquipmentSlot.getNMS(attributeModifier.getSlot()).name());
+        }
+
+        return attributeHolder.getCompoundTag();
+    }
+
+    record AttributePairImpl(Attribute attribute,
+                             AttributeModifier modifier) implements io.papermc.paper.inventory.item.properties.AttributePair {
+
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/AxolotlVariantNbt.java b/src/main/java/io/papermc/paper/property/nbt/types/AxolotlVariantNbt.java
new file mode 100644
index 0000000000000000000000000000000000000000..97bedb86cfaeb5cd1f0ea655b04c91a8ec4c0656
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/AxolotlVariantNbt.java
@@ -0,0 +1,22 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.property.nbt.primitives.IntegerPrimitive;
+import io.papermc.paper.property.nbt.primitives.NbtPrimitiveWrapper;
+import org.bukkit.entity.Axolotl;
+
+public class AxolotlVariantNbt extends NbtPrimitiveWrapper<Axolotl.Variant, Integer> {
+
+    public AxolotlVariantNbt() {
+        super(new IntegerPrimitive());
+    }
+
+    @Override
+    public Axolotl.Variant fromPrimitive(Integer primitive) {
+        return Axolotl.Variant.values()[primitive];
+    }
+
+    @Override
+    public Integer toPrimitive(Axolotl.Variant type) {
+        return type.ordinal();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/BlockStateConditionNamespaceHackNbt.java b/src/main/java/io/papermc/paper/property/nbt/types/BlockStateConditionNamespaceHackNbt.java
new file mode 100644
index 0000000000000000000000000000000000000000..f60e06b4749ae724ecea7cc6ab021e76d8becc57
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/BlockStateConditionNamespaceHackNbt.java
@@ -0,0 +1,57 @@
+package io.papermc.paper.property.nbt.types;
+
+import com.destroystokyo.paper.Namespaced;
+import com.destroystokyo.paper.NamespacedTag;
+import io.papermc.paper.property.nbt.primitives.NbtPrimitiveWrapper;
+import io.papermc.paper.property.nbt.primitives.StringPrimitive;
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+
+public class BlockStateConditionNamespaceHackNbt extends NbtPrimitiveWrapper<Namespaced, String> {
+
+    public BlockStateConditionNamespaceHackNbt() {
+        super(new StringPrimitive());
+    }
+
+    @Override
+    public Namespaced fromPrimitive(String raw) {
+        boolean isTag = raw.length() > 0 && raw.codePointAt(0) == '#';
+        com.mojang.datafixers.util.Either<net.minecraft.commands.arguments.blocks.BlockStateParser.BlockResult, net.minecraft.commands.arguments.blocks.BlockStateParser.TagResult> result;
+        try {
+            result = net.minecraft.commands.arguments.blocks.BlockStateParser.parseForTesting(net.minecraft.core.registries.BuiltInRegistries.BLOCK.asLookup(), raw, false);
+        } catch (com.mojang.brigadier.exceptions.CommandSyntaxException e) {
+            return null;
+        }
+
+        net.minecraft.resources.ResourceLocation key = null;
+        if (isTag && result.right().isPresent() && result.right().get().tag() instanceof net.minecraft.core.HolderSet.Named<net.minecraft.world.level.block.Block> namedSet) {
+            key = namedSet.key().location();
+        } else if (result.left().isPresent()) {
+            key = net.minecraft.core.registries.BuiltInRegistries.BLOCK.getKey(result.left().get().blockState().getBlock());
+        }
+
+        if (key == null) {
+            return null;
+        }
+
+        // don't DC the player if something slips through somehow
+        NamespacedKey resource = null;
+        try {
+            if (isTag) {
+                resource = new NamespacedKey(key.getNamespace(), key.getPath());
+            } else {
+                resource = CraftNamespacedKey.fromMinecraft(key);
+            }
+        } catch (IllegalArgumentException ex) {
+            org.bukkit.Bukkit.getLogger().warning("Namespaced resource does not validate: " + key.toString());
+            ex.printStackTrace();
+        }
+
+        return resource;
+    }
+
+    @Override
+    public String toPrimitive(Namespaced type) {
+        return type.toString();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/CompoundTagNbt.java b/src/main/java/io/papermc/paper/property/nbt/types/CompoundTagNbt.java
new file mode 100644
index 0000000000000000000000000000000000000000..e28cc24a74ea783da94bc8d4d65355cab6880d2c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/CompoundTagNbt.java
@@ -0,0 +1,33 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.property.MutablePropertyView;
+import io.papermc.paper.property.nbt.AdapterContext;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.nbt.primitives.CompoundTagPrimitive;
+import io.papermc.paper.property.nbt.primitives.NbtPrimitiveWrapper;
+import net.minecraft.nbt.CompoundTag;
+
+public class CompoundTagNbt extends NbtPrimitiveWrapper<MutablePropertyView, CompoundTag> {
+
+    private final AdapterContext context;
+
+    public CompoundTagNbt(AdapterContext context) {
+        super(new CompoundTagPrimitive());
+        this.context = context;
+    }
+
+    @Override
+    public MutablePropertyView fromPrimitive(CompoundTag primitive) {
+        NbtPropertyHolder wrappedholder = NbtPropertyHolder.simpleBlob(primitive, this.context);
+        return wrappedholder;
+    }
+
+    @Override
+    public CompoundTag toPrimitive(MutablePropertyView type) {
+        if (type instanceof NbtPropertyHolder nbtPropertyHolder) {
+            return nbtPropertyHolder.getCompoundTag().copy();
+        } else {
+            throw new UnsupportedOperationException(); // TODO ?
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/CustomEffectNbt.java b/src/main/java/io/papermc/paper/property/nbt/types/CustomEffectNbt.java
new file mode 100644
index 0000000000000000000000000000000000000000..41dd6817cfc7060cd9aeb76abc3438950488887f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/CustomEffectNbt.java
@@ -0,0 +1,27 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.property.nbt.primitives.CompoundTagPrimitive;
+import io.papermc.paper.property.nbt.primitives.NbtPrimitiveWrapper;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.item.alchemy.PotionUtils;
+import org.bukkit.craftbukkit.potion.CraftPotionUtil;
+import org.bukkit.potion.PotionData;
+import org.bukkit.potion.PotionEffect;
+
+public class CustomEffectNbt extends NbtPrimitiveWrapper<PotionEffect, CompoundTag> {
+
+    public CustomEffectNbt() {
+        super(new CompoundTagPrimitive());
+    }
+
+    @Override
+    public PotionEffect fromPrimitive(CompoundTag primitive) {
+        return CraftPotionUtil.toBukkit(MobEffectInstance.load(primitive));
+    }
+
+    @Override
+    public CompoundTag toPrimitive(PotionEffect type) {
+        return CraftPotionUtil.fromBukkit(type).save(new CompoundTag());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/DyeColorNbt.java b/src/main/java/io/papermc/paper/property/nbt/types/DyeColorNbt.java
new file mode 100644
index 0000000000000000000000000000000000000000..a6eba8250dbfe31efddc1b6105007b7f192f084f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/DyeColorNbt.java
@@ -0,0 +1,23 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.property.nbt.primitives.IntegerPrimitive;
+import io.papermc.paper.property.nbt.primitives.NbtPrimitiveWrapper;
+import org.bukkit.DyeColor;
+import org.bukkit.entity.Axolotl;
+
+public class DyeColorNbt extends NbtPrimitiveWrapper<DyeColor, Integer> {
+
+    public DyeColorNbt() {
+        super(new IntegerPrimitive());
+    }
+
+    @Override
+    public DyeColor fromPrimitive(Integer primitive) {
+        return DyeColor.values()[primitive];
+    }
+
+    @Override
+    public Integer toPrimitive(DyeColor type) {
+        return type.ordinal();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/EnchantmentList.java b/src/main/java/io/papermc/paper/property/nbt/types/EnchantmentList.java
new file mode 100644
index 0000000000000000000000000000000000000000..deef80a97a326f4f13c15722f87deb186e8dc45e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/EnchantmentList.java
@@ -0,0 +1,29 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.inventory.item.properties.EnchantmentPair;
+import io.papermc.paper.property.nbt.primitives.AbstractListNbtPlatformAdapter;
+import io.papermc.paper.property.types.EnchantmentPairImpl;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.world.item.enchantment.EnchantmentHelper;
+import org.bukkit.craftbukkit.enchantments.CraftEnchantment;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.bukkit.enchantments.Enchantment;
+
+public class EnchantmentList extends AbstractListNbtPlatformAdapter<EnchantmentPair> {
+
+    @Override
+    public EnchantmentPair deserialize(Tag tag) {
+        CompoundTag compoundTag = (CompoundTag) tag;
+        Enchantment enchantment = Enchantment.getByKey(CraftNamespacedKey.fromMinecraft(EnchantmentHelper.getEnchantmentId(compoundTag)));
+        int level = EnchantmentHelper.getEnchantmentLevel(compoundTag);
+
+        return new EnchantmentPairImpl(enchantment, level);
+    }
+
+    @Override
+    public Tag serialize(EnchantmentPair pair) {
+        return EnchantmentHelper.storeEnchantment(EnchantmentHelper.getEnchantmentId(CraftEnchantment.getRaw(pair.enchantment())), pair.level());
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/FireworkEffectNbt.java b/src/main/java/io/papermc/paper/property/nbt/types/FireworkEffectNbt.java
new file mode 100644
index 0000000000000000000000000000000000000000..30608c1bb7dafd8643838c0ef03f73e3a613e661
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/FireworkEffectNbt.java
@@ -0,0 +1,117 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.nbt.AdapterContext;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.nbt.primitives.BooleanPrimitive;
+import io.papermc.paper.property.nbt.primitives.BytePrimitive;
+import io.papermc.paper.property.nbt.primitives.CompoundTagPrimitive;
+import io.papermc.paper.property.nbt.primitives.IntArrayPrimitive;
+import io.papermc.paper.property.nbt.primitives.NbtPrimitiveWrapper;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.Color;
+import org.bukkit.FireworkEffect;
+
+import java.util.List;
+
+public class FireworkEffectNbt extends NbtPrimitiveWrapper<FireworkEffect, CompoundTag> {
+
+    private static final PropertyKey<Boolean> TRIAL = PropertyKey.of("Trail", Boolean.class);
+    private static final PropertyKey<Boolean> FLICKER = PropertyKey.of("Flicker", Boolean.class);
+    private static final PropertyKey<Byte> TYPE = PropertyKey.of("Type", Byte.class);
+    private static final PropertyKey<int[]> COLORS = PropertyKey.of("Colors", int[].class);
+    private static final PropertyKey<int[]> FADE_COLORS = PropertyKey.of("FadeColors", int[].class);
+
+    private static final AdapterContext CONTEXT = AdapterContext.of((context) -> {
+        context.register(TRIAL, new BooleanPrimitive());
+        context.register(FLICKER, new BooleanPrimitive());
+        context.register(TYPE, new BytePrimitive());
+        context.register(COLORS, new IntArrayPrimitive());
+        context.register(FADE_COLORS, new IntArrayPrimitive());
+    });
+
+    public FireworkEffectNbt() {
+        super(new CompoundTagPrimitive());
+    }
+
+    @Override
+    public FireworkEffect fromPrimitive(CompoundTag primitive) {
+        NbtPropertyHolder holder = NbtPropertyHolder.simpleBlob((CompoundTag) primitive, CONTEXT);
+        FireworkEffect.Builder effect = FireworkEffect.builder()
+            .flicker(holder.get(FLICKER))
+            .trail(holder.get(TRIAL))
+            .with(getEffectType(0xff & holder.get(TYPE)));
+
+        int[] colors = holder.get(COLORS);
+        // People using buggy command generators specify a list rather than an int here, so recover with dummy data.
+        // Wrong: Colors: [1234]
+        // Right: Colors: [I;1234]
+        if (colors.length == 0) {
+            effect.withColor(Color.WHITE);
+        }
+
+        for (int color : colors) {
+            effect.withColor(Color.fromRGB(color));
+        }
+
+        for (int color : holder.get(FADE_COLORS)) {
+            effect.withFade(Color.fromRGB(color));
+        }
+
+        return effect.build();
+    }
+
+    @Override
+    public CompoundTag toPrimitive(FireworkEffect type) {
+        NbtPropertyHolder holder = NbtPropertyHolder.simpleBlob((CompoundTag) new CompoundTag(), CONTEXT);
+        if (type.hasFlicker()) {
+            holder.set(FLICKER, true);
+        }
+
+        if (type.hasTrail()) {
+            holder.set(TRIAL, true);
+        }
+
+        addColors(holder, COLORS, type.getColors());
+        addColors(holder, FADE_COLORS, type.getFadeColors());
+
+        holder.set(TYPE, (byte) getNBT(type.getType()));
+
+        return holder.getCompoundTag();
+    }
+
+    static void addColors(NbtPropertyHolder compound, PropertyKey<int[]> key, List<Color> colors) {
+        if (colors.isEmpty()) {
+            return;
+        }
+
+        final int[] colorArray = new int[colors.size()];
+        int i = 0;
+        for (Color color : colors) {
+            colorArray[i++] = color.asRGB();
+        }
+
+        compound.set(key, colorArray);
+    }
+
+    static FireworkEffect.Type getEffectType(int nbt) {
+        return switch (nbt) {
+            case 0 -> FireworkEffect.Type.BALL;
+            case 1 -> FireworkEffect.Type.BALL_LARGE;
+            case 2 -> FireworkEffect.Type.STAR;
+            case 3 -> FireworkEffect.Type.CREEPER;
+            case 4 -> FireworkEffect.Type.BURST;
+            default -> throw new IllegalArgumentException("Unknown effect type " + nbt);
+        };
+    }
+
+    public static int getNBT(FireworkEffect.Type type) {
+        return switch (type) {
+            case BALL -> 0;
+            case BALL_LARGE -> 1;
+            case STAR -> 2;
+            case CREEPER -> 3;
+            case BURST -> 4;
+        };
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/GameProfileNbt.java b/src/main/java/io/papermc/paper/property/nbt/types/GameProfileNbt.java
new file mode 100644
index 0000000000000000000000000000000000000000..f4b7b0dbfa13aabde5ba75cad31a70de793d3b7a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/GameProfileNbt.java
@@ -0,0 +1,27 @@
+package io.papermc.paper.property.nbt.types;
+
+import com.destroystokyo.paper.profile.CraftPlayerProfile;
+import com.destroystokyo.paper.profile.PlayerProfile;
+import io.papermc.paper.property.nbt.primitives.CompoundTagPrimitive;
+import io.papermc.paper.property.nbt.primitives.NbtPrimitiveWrapper;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.NbtUtils;
+
+public class GameProfileNbt extends NbtPrimitiveWrapper<PlayerProfile, CompoundTag> {
+
+    public GameProfileNbt() {
+        super(new CompoundTagPrimitive());
+    }
+
+    @Override
+    public PlayerProfile fromPrimitive(CompoundTag primitive) {
+        return new CraftPlayerProfile(NbtUtils.readGameProfile(primitive));
+    }
+
+    @Override
+    public CompoundTag toPrimitive(PlayerProfile type) {
+        CompoundTag profile = new CompoundTag();
+        NbtUtils.writeGameProfile(profile, ((CraftPlayerProfile) type).getGameProfile());
+        return profile;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/ItemFlagBitset.java b/src/main/java/io/papermc/paper/property/nbt/types/ItemFlagBitset.java
new file mode 100644
index 0000000000000000000000000000000000000000..e1cbd547995e543f6221c53d95d4fa1a6b7bfdec
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/ItemFlagBitset.java
@@ -0,0 +1,47 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.property.nbt.primitives.IntegerPrimitive;
+import io.papermc.paper.property.nbt.primitives.NbtPrimitiveWrapper;
+import org.bukkit.inventory.ItemFlag;
+
+import java.util.EnumSet;
+import java.util.Set;
+
+public class ItemFlagBitset extends NbtPrimitiveWrapper<Set<ItemFlag>, Integer> {
+
+    public ItemFlagBitset() {
+        super(new IntegerPrimitive());
+    }
+
+    @Override
+    public Set<ItemFlag> fromPrimitive(Integer primitive) {
+        Set<ItemFlag> currentFlags = EnumSet.noneOf(ItemFlag.class);
+
+        for (ItemFlag f : ItemFlag.values()) {
+            if (this.contains(f, primitive)) {
+                currentFlags.add(f);
+            }
+        }
+
+        return currentFlags;
+    }
+
+    @Override
+    public Integer toPrimitive(Set<ItemFlag> type) {
+        int flags = 0;
+        for (ItemFlag itemFlag : type) {
+            flags |= this.getBitModifier(itemFlag);
+        }
+        return flags;
+    }
+
+    private boolean contains(ItemFlag itemFlag, int flags) {
+        int bitModifier = ItemFlagBitset.this.getBitModifier(itemFlag);
+        return (flags & bitModifier) == bitModifier;
+    }
+
+    private byte getBitModifier(ItemFlag hideFlag) {
+        return (byte) (1 << hideFlag.ordinal());
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/PotionDataNbt.java b/src/main/java/io/papermc/paper/property/nbt/types/PotionDataNbt.java
new file mode 100644
index 0000000000000000000000000000000000000000..f408fef9d8494615af3385e468de81ca17247277
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/PotionDataNbt.java
@@ -0,0 +1,23 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.property.nbt.primitives.NbtPrimitiveWrapper;
+import io.papermc.paper.property.nbt.primitives.StringPrimitive;
+import org.bukkit.craftbukkit.potion.CraftPotionUtil;
+import org.bukkit.potion.PotionData;
+
+public class PotionDataNbt extends NbtPrimitiveWrapper<PotionData, String> {
+
+    public PotionDataNbt() {
+        super(new StringPrimitive());
+    }
+
+    @Override
+    public PotionData fromPrimitive(String primitive) {
+        return CraftPotionUtil.toBukkit(primitive);
+    }
+
+    @Override
+    public String toPrimitive(PotionData type) {
+        return CraftPotionUtil.fromBukkit(type);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/StewEffectsListNbt.java b/src/main/java/io/papermc/paper/property/nbt/types/StewEffectsListNbt.java
new file mode 100644
index 0000000000000000000000000000000000000000..456171ebbfc5cd829bb3658503fd2db2fa2f0017
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/StewEffectsListNbt.java
@@ -0,0 +1,54 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.inventory.item.properties.StewEffect;
+import io.papermc.paper.property.PropertyKey;
+import io.papermc.paper.property.nbt.AdapterContext;
+import io.papermc.paper.property.nbt.NbtPropertyHolder;
+import io.papermc.paper.property.nbt.primitives.AbstractListNbtPlatformAdapter;
+import io.papermc.paper.property.nbt.primitives.IntegerPrimitive;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.world.effect.MobEffect;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.bukkit.potion.PotionEffectType;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+public class StewEffectsListNbt extends AbstractListNbtPlatformAdapter<StewEffect> {
+
+    private static final PropertyKey<Integer> EFFECT = PropertyKey.of("EffectId", Integer.class);
+    private static final PropertyKey<Integer> EFFECT_DURATION = PropertyKey.of("EffectDuration", Integer.class);
+
+    private static final AdapterContext CONTEXT = AdapterContext.of((context) -> {
+        context.register(EFFECT, new IntegerPrimitive());
+        context.register(EFFECT_DURATION, new IntegerPrimitive());
+    });
+
+    private static final IntegerPrimitive PRIMITIVE = new IntegerPrimitive();
+
+    @Override
+    public StewEffect deserialize(Tag tag) {
+        NbtPropertyHolder attributeHolder = NbtPropertyHolder.simpleBlob((CompoundTag) tag, CONTEXT);
+
+        int duration = attributeHolder.get(EFFECT_DURATION);
+        MobEffect mobEffect = MobEffect.byId(attributeHolder.get(EFFECT));
+        PotionEffectType type = PotionEffectType.getByKey(CraftNamespacedKey.fromMinecraft(BuiltInRegistries.MOB_EFFECT.getKey(mobEffect)));
+
+        return new StewEffectImpl(type, duration);
+    }
+
+    @Override
+    public Tag serialize(StewEffect type) {
+        NbtPropertyHolder attributeHolder = NbtPropertyHolder.simpleBlob(new CompoundTag(), CONTEXT);
+
+        PRIMITIVE.writeDirect(attributeHolder, EFFECT, BuiltInRegistries.MOB_EFFECT.getId(BuiltInRegistries.MOB_EFFECT.get(CraftNamespacedKey.toMinecraft(type.effect().getKey()))));
+        PRIMITIVE.writeDirect(attributeHolder, EFFECT_DURATION, type.duration());
+
+        return attributeHolder.getCompoundTag();
+    }
+
+    @ApiStatus.Experimental
+    public static record StewEffectImpl(@NotNull PotionEffectType effect, int duration) implements StewEffect {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/TropicalFishVariantNbt.java b/src/main/java/io/papermc/paper/property/nbt/types/TropicalFishVariantNbt.java
new file mode 100644
index 0000000000000000000000000000000000000000..6259ae3521780e9436b32e63b008d2dd4536e5cb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/TropicalFishVariantNbt.java
@@ -0,0 +1,32 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.inventory.item.properties.TropicalFishVariant;
+import io.papermc.paper.property.nbt.primitives.IntegerPrimitive;
+import io.papermc.paper.property.nbt.primitives.NbtPrimitiveWrapper;
+import org.bukkit.DyeColor;
+import org.bukkit.craftbukkit.entity.CraftTropicalFish;
+import org.bukkit.entity.TropicalFish;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+public class TropicalFishVariantNbt extends NbtPrimitiveWrapper<TropicalFishVariant, Integer> {
+
+    public TropicalFishVariantNbt() {
+        super(new IntegerPrimitive());
+    }
+
+    @Override
+    public TropicalFishVariant fromPrimitive(Integer primitive) {
+        return new TropicalFishVariantImpl(CraftTropicalFish.getPatternColor(primitive), CraftTropicalFish.getBodyColor(primitive), CraftTropicalFish.getPattern(primitive));
+    }
+
+    @Override
+    public Integer toPrimitive(TropicalFishVariant type) {
+        return CraftTropicalFish.getData(type.patternColor(), type.bodyColor(), type.type());
+    }
+
+    @ApiStatus.Experimental
+    public static record TropicalFishVariantImpl(@NotNull DyeColor patternColor, @NotNull DyeColor bodyColor,
+                                                 @NotNull TropicalFish.Pattern type) implements io.papermc.paper.inventory.item.properties.TropicalFishVariant {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/nbt/types/WrappedListNbt.java b/src/main/java/io/papermc/paper/property/nbt/types/WrappedListNbt.java
new file mode 100644
index 0000000000000000000000000000000000000000..040db9232b2e61ded96b6112a64ed84340ad7281
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/nbt/types/WrappedListNbt.java
@@ -0,0 +1,29 @@
+package io.papermc.paper.property.nbt.types;
+
+import io.papermc.paper.property.nbt.primitives.AbstractListNbtPlatformAdapter;
+import io.papermc.paper.property.nbt.primitives.SinglePrimitiveNbtPlatformAdapter;
+import net.minecraft.nbt.Tag;
+
+public class WrappedListNbt<T> extends AbstractListNbtPlatformAdapter<T> {
+
+    private final SinglePrimitiveNbtPlatformAdapter<T> wrapper;
+
+    public WrappedListNbt(SinglePrimitiveNbtPlatformAdapter<T> wrapper) {
+        this.wrapper = wrapper;
+    }
+
+    @Override
+    public T deserialize(Tag tag) {
+        return this.wrapper.getType(tag);
+    }
+
+    @Override
+    public Tag serialize(T value) {
+        return this.wrapper.write(value);
+    }
+
+    @Override
+    public int getTagType() {
+        return Tag.TAG_LIST;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/property/types/EnchantmentPairImpl.java b/src/main/java/io/papermc/paper/property/types/EnchantmentPairImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..7810eb42379ca0baeb42f617c06a4e2002635a59
--- /dev/null
+++ b/src/main/java/io/papermc/paper/property/types/EnchantmentPairImpl.java
@@ -0,0 +1,7 @@
+package io.papermc.paper.property.types;
+
+import org.bukkit.enchantments.Enchantment;
+import org.jetbrains.annotations.NotNull;
+
+public record EnchantmentPairImpl(@NotNull Enchantment enchantment, int level) implements io.papermc.paper.inventory.item.properties.EnchantmentPair {
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockStates.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockStates.java
index 9215297d5f7856ef3f03ebcbf866c5b59048ba30..850c7d42e18e440617c726bb11160fb1f2f4c816 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockStates.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockStates.java
@@ -109,7 +109,7 @@ public final class CraftBlockStates {
         }
     }
 
-    private static final Map<Material, BlockStateFactory<?>> FACTORIES = new HashMap<>();
+    public static final Map<Material, BlockStateFactory<?>> FACTORIES = new HashMap<>(); // Paper
     private static final BlockStateFactory<?> DEFAULT_FACTORY = new BlockStateFactory<CraftBlockState>(CraftBlockState.class) {
         @Override
         public CraftBlockState createBlockState(World world, BlockPos blockPosition, net.minecraft.world.level.block.state.BlockState blockData, BlockEntity tileEntity) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemFactory.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemFactory.java
index 83bbfe1ffd0dc8e168064225a02abcaa49df60ed..aa10abfd1d424863db8a8aac6debb34539325fcb 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemFactory.java
@@ -3,7 +3,6 @@ package org.bukkit.craftbukkit.inventory;
 import com.mojang.brigadier.StringReader;
 import com.mojang.brigadier.exceptions.CommandSyntaxException;
 import net.minecraft.commands.arguments.item.ItemParser;
-import net.minecraft.core.HolderLookup;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.world.item.Item;
@@ -12,6 +11,7 @@ import org.bukkit.Color;
 import org.bukkit.Material;
 import org.bukkit.configuration.serialization.ConfigurationSerialization;
 import org.bukkit.craftbukkit.util.CraftLegacy;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 import org.bukkit.inventory.ItemFactory;
 import org.bukkit.inventory.ItemStack;
 import org.bukkit.inventory.meta.ItemMeta;
@@ -42,11 +42,11 @@ public final class CraftItemFactory implements ItemFactory {
         if (type == null || meta == null) {
             return false;
         }
-        if (!(meta instanceof CraftMetaItem)) {
+        if (!(meta instanceof io.papermc.paper.item.meta.PaperMeta paperMeta)) { // Paper
             throw new IllegalArgumentException("Meta of " + meta.getClass().toString() + " not created by " + CraftItemFactory.class.getName());
         }
 
-        return ((CraftMetaItem) meta).applicableTo(type);
+        return meta.getClass().isAssignableFrom(CraftItemStack.getItemMeta(paperMeta.getPropertyHolder(), type).getClass()); // Paper
     }
 
     @Override
@@ -57,6 +57,16 @@ public final class CraftItemFactory implements ItemFactory {
 
     private ItemMeta getItemMeta(Material material, CraftMetaItem meta) {
         material = CraftLegacy.fromLegacy(material); // This may be called from legacy item stacks, try to get the right material
+        // Paper start
+        net.minecraft.world.item.ItemStack itemStack = new net.minecraft.world.item.ItemStack(CraftMagicNumbers.getItem(material));
+        if (meta != null) {
+            meta.applyToItem(itemStack.getOrCreateTag());
+        }
+        return CraftItemStack.getItemMeta(itemStack, material);
+    }
+    public ItemMeta getOldItemMeta(Material material, CraftMetaItem meta) {
+    // Paper end
+
         switch (material) {
         case AIR:
             return null;
@@ -341,23 +351,22 @@ public final class CraftItemFactory implements ItemFactory {
         if (meta1 == meta2) {
             return true;
         }
-        if (meta1 != null && !(meta1 instanceof CraftMetaItem)) {
+        if (meta1 != null && !(meta1 instanceof io.papermc.paper.item.meta.PaperMeta)) { // Paper
             throw new IllegalArgumentException("First meta of " + meta1.getClass().getName() + " does not belong to " + CraftItemFactory.class.getName());
         }
-        if (meta2 != null && !(meta2 instanceof CraftMetaItem)) {
+        if (meta2 != null && !(meta2 instanceof io.papermc.paper.item.meta.PaperMeta)) { // Paper
             throw new IllegalArgumentException("Second meta " + meta2.getClass().getName() + " does not belong to " + CraftItemFactory.class.getName());
         }
         if (meta1 == null) {
-            return ((CraftMetaItem) meta2).isEmpty();
+            return ((io.papermc.paper.item.meta.PaperMeta) meta2).isEmpty(); // Paper
         }
         if (meta2 == null) {
-            return ((CraftMetaItem) meta1).isEmpty();
+            return ((io.papermc.paper.item.meta.PaperMeta) meta1).isEmpty(); // Paper
         }
-
-        return this.equals((CraftMetaItem) meta1, (CraftMetaItem) meta2);
+        return this.equals((io.papermc.paper.item.meta.PaperMeta) meta1, (io.papermc.paper.item.meta.PaperMeta) meta2); // Paper
     }
 
-    boolean equals(CraftMetaItem meta1, CraftMetaItem meta2) {
+    boolean equals(io.papermc.paper.item.meta.PaperMeta meta1, io.papermc.paper.item.meta.PaperMeta meta2) { // Paper
         /*
          * This couldn't be done inside of the objects themselves, else force recursion.
          * This is a fairly clean way of implementing it, by dividing the methods into purposes and letting each method perform its own function.
@@ -383,10 +392,14 @@ public final class CraftItemFactory implements ItemFactory {
     @Override
     public ItemMeta asMetaFor(ItemMeta meta, Material material) {
         Validate.notNull(material, "Material cannot be null");
-        if (!(meta instanceof CraftMetaItem)) {
+        if (!(meta instanceof io.papermc.paper.item.meta.PaperMeta paperMeta)) { // Paper
             throw new IllegalArgumentException("Meta of " + (meta != null ? meta.getClass().toString() : "null") + " not created by " + CraftItemFactory.class.getName());
         }
-        return this.getItemMeta(material, (CraftMetaItem) meta);
+        // Paper start
+        io.papermc.paper.property.MutablePropertyView holder = paperMeta.getPropertyHolder().clone();
+        paperMeta.migrateFrom(holder);
+        return CraftItemStack.getItemMeta(holder, material);
+        // Paper end
     }
 
     @Override
@@ -415,7 +428,7 @@ public final class CraftItemFactory implements ItemFactory {
 
     @Override
     public Material updateMaterial(ItemMeta meta, Material material) throws IllegalArgumentException {
-        return ((CraftMetaItem) meta).updateMaterial(material);
+        return material; // Paper - not needed on modern
     }
 
     // Paper start
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
index f45e4acee69bd95ff2e41feaf44f5414d2e40df0..881d79b9d4f7749d89a3af2b4fd5c47fac11853f 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
@@ -287,6 +287,13 @@ public final class CraftItemStack extends ItemStack {
         return getItemMeta(item, CraftItemStack.getType(item));
     }
     public static ItemMeta getItemMeta(net.minecraft.world.item.ItemStack item, Material material) {
+        return getItemMeta(io.papermc.paper.property.nbt.NbtPropertyHolder.itemHolder(item.getOrCreateTag()), material);
+    }
+    public static ItemMeta getItemMeta(io.papermc.paper.property.MutablePropertyView propertyHolder, Material material) {
+        return io.papermc.paper.item.PaperMetaRegistry.getItemMeta(propertyHolder, material);
+    }
+    public static ItemMeta getItemMetaOld(net.minecraft.world.item.ItemStack item) {
+        Material material = CraftItemStack.getType(item);
         // Paper end
         if (!CraftItemStack.hasItemMeta(item)) {
             return CraftItemFactory.instance().getItemMeta(material); // Paper
@@ -598,11 +605,7 @@ public final class CraftItemStack extends ItemStack {
             item.setItem(newItem);
         }
 
-        CompoundTag tag = new CompoundTag();
-        item.setTag(tag);
-
-        ((CraftMetaItem) itemMeta).applyToItem(tag);
-        item.convertStack(((CraftMetaItem) itemMeta).getVersion());
+        item.setTag(((io.papermc.paper.property.nbt.NbtPropertyHolder) ((io.papermc.paper.item.meta.PaperMeta) itemMeta).getPropertyHolder()).getCompoundTag()); // Paper
         // SpigotCraft#463 this is required now by the Vanilla client, so mimic ItemStack constructor in ensuring it
         if (item.getItem() != null && item.getItem().canBeDepleted()) {
             item.setDamageValue(item.getDamageValue());
@@ -639,7 +642,7 @@ public final class CraftItemStack extends ItemStack {
 
     @Override
     public boolean hasItemMeta() {
-        return CraftItemStack.hasItemMeta(this.handle) && (this.handle.getDamageValue() != 0 || (this.handle.getTag() != null && this.handle.getTag().tags.size() >= (this.handle.getTag().contains(CraftMetaItem.DAMAGE.NBT) ? 2 : 1))); // Paper - keep 1.12 CraftBukkit behavior without calling getItemMeta
+        return !CraftItemFactory.instance().equals(getItemMeta(), null); // Paper - ignore the item stack tag state
     }
 
     static boolean hasItemMeta(net.minecraft.world.item.ItemStack item) {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
index 58c1d07f41fc382b23df17739090f5031fd41aad..e29f3c978ecf9b00aee694bb7c08e289c70c7246 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
@@ -40,6 +40,8 @@ import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.item.PaperMetaSerialization;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.ListTag;
 import net.minecraft.nbt.NbtIo;
@@ -112,7 +114,7 @@ import java.util.Collections;
  * <li> SerializableMeta.Deserializers deserializer()
  */
 @DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
-class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
+public class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta { // Paper
 
     static class ItemMetaKey {
 
@@ -193,7 +195,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
 
             String type = SerializableMeta.getString(map, SerializableMeta.TYPE_FIELD, false);
             Constructor<? extends CraftMetaItem> constructor = SerializableMeta.constructorMap.get(type);
-
+            if (true) return io.papermc.paper.item.PaperMetaSerialization.deserialize(type, constructor, map); // Paper
             if (constructor == null) {
                 throw new IllegalArgumentException(type + " is not a valid " + SerializableMeta.TYPE_FIELD);
             }
@@ -684,6 +686,11 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         }
         return result;
     }
+    // Paper
+    public void apply(CompoundTag compoundTag) {
+        applyToItem(compoundTag);
+    }
+    // Paper end
 
     @Overridden
     void applyToItem(CompoundTag itemTag) {
@@ -1407,6 +1414,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
 
     @Override
     public final Map<String, Object> serialize() {
+        if (true) return PaperMetaSerialization.serialize(this); // Paper
         ImmutableMap.Builder<String, Object> map = ImmutableMap.builder();
         map.put(SerializableMeta.TYPE_FIELD, SerializableMeta.classMap.get(getClass()));
         this.serialize(map);
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index 64c50c52c11214740de7903e5592b8b6b2c170b3..4a682f62c9f6083f8520decbfc98db121d90ee4b 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -54,7 +54,6 @@ import org.bukkit.block.data.BlockData;
 import org.bukkit.craftbukkit.CraftEquipmentSlot;
 import org.bukkit.craftbukkit.attribute.CraftAttributeInstance;
 import org.bukkit.craftbukkit.attribute.CraftAttributeMap;
-import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.legacy.CraftLegacy;
@@ -616,6 +615,21 @@ public final class CraftMagicNumbers implements UnsafeValues {
         net.minecraft.core.Holder<net.minecraft.world.level.biome.Biome> biomeBase = cra.getHandle().registryAccess().registryOrThrow(net.minecraft.core.registries.Registries.BIOME).getHolderOrThrow(net.minecraft.resources.ResourceKey.create(net.minecraft.core.registries.Registries.BIOME, org.bukkit.craftbukkit.util.CraftNamespacedKey.toMinecraft(biomeKey)));
         cra.setBiome(x, y, z, biomeBase);
     }
+
+    @Override
+    public io.papermc.paper.property.MutablePropertyView getPropertyHolder(ItemStack itemStack) {
+        if (itemStack instanceof org.bukkit.craftbukkit.inventory.CraftItemStack craftItemStack) {
+            return io.papermc.paper.property.nbt.NbtPropertyHolder.itemHolder(craftItemStack.handle.getOrCreateTag());
+        }
+
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ItemStack newItem(Material material, int count) {
+        return CraftItemStack.asCraftCopy(new ItemStack(material, count));
+    }
+
     // Paper end
 
     /**
diff --git a/src/test/java/io/papermc/paper/inventory/CraftMetaTropicalFishBucketTest.java b/src/test/java/io/papermc/paper/inventory/CraftMetaTropicalFishBucketTest.java
index 2e7f8ef88ae74c7cbfdb7f397951cbc8479a995f..7cb9014eb7049c900c56b0f77a4b9fc55ae08265 100644
--- a/src/test/java/io/papermc/paper/inventory/CraftMetaTropicalFishBucketTest.java
+++ b/src/test/java/io/papermc/paper/inventory/CraftMetaTropicalFishBucketTest.java
@@ -7,6 +7,7 @@ import org.bukkit.inventory.ItemStack;
 import org.bukkit.inventory.meta.TropicalFishBucketMeta;
 import org.bukkit.support.AbstractTestingBase;
 import org.junit.Assert;
+import org.junit.Before;
 import org.junit.Test;
 
 public class CraftMetaTropicalFishBucketTest extends AbstractTestingBase {
diff --git a/src/test/java/io/papermc/paper/item/MetaComparisonTest.java b/src/test/java/io/papermc/paper/item/MetaComparisonTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..74e4c8651dabb339e32785691220a4ad30b53a6f
--- /dev/null
+++ b/src/test/java/io/papermc/paper/item/MetaComparisonTest.java
@@ -0,0 +1,67 @@
+package io.papermc.paper.item;
+
+import com.destroystokyo.paper.profile.PlayerProfile;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.enchantments.Enchantment;
+import org.bukkit.inventory.meta.ItemMeta;
+import org.bukkit.inventory.meta.PotionMeta;
+import org.bukkit.inventory.meta.SkullMeta;
+import org.bukkit.potion.PotionEffect;
+import org.bukkit.potion.PotionEffectType;
+import org.bukkit.util.Consumer;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class MetaComparisonTest {
+
+    @Test
+    public void testPotionMeta() {
+        PotionEffect potionEffect = new PotionEffect(PotionEffectType.SPEED, 10, 10, false);
+        ItemStack nmsItemStack = new ItemStack(Items.POTION, 1);
+
+        testSetAndGet(nmsItemStack,
+            (meta) -> ((PotionMeta) meta).addCustomEffect(potionEffect, true),
+            (meta) -> Assert.assertEquals(potionEffect, ((PotionMeta) meta).getCustomEffects().get(0))
+        );
+    }
+
+    @Test
+    public void testEnchantment() {
+        ItemStack nmsItemStack = new ItemStack(Items.STICK, 1);
+
+        testSetAndGet(nmsItemStack,
+            (meta) -> Assert.assertTrue(meta.addEnchant(Enchantment.DAMAGE_ALL, 1, true)),
+            (meta) -> Assert.assertEquals(1, meta.getEnchantLevel(Enchantment.DAMAGE_ALL))
+        );
+    }
+
+
+    @Test
+    public void testPlayerHead() {
+        PlayerProfile profile = Bukkit.createProfile("Owen1212055");
+        ItemStack nmsItemStack = new ItemStack(Items.PLAYER_HEAD, 1);
+
+        testSetAndGet(nmsItemStack,
+            (meta) -> ((SkullMeta) meta).setPlayerProfile(profile),
+            (meta) -> Assert.assertEquals(profile, ((SkullMeta) meta).getPlayerProfile())
+        );
+    }
+
+    private void testSetAndGet(ItemStack nmsItemStack,
+                               Consumer<ItemMeta> set,
+                               Consumer<ItemMeta> get) {
+        ItemMeta craftMeta = CraftItemStack.getItemMetaOld(nmsItemStack);
+        ItemMeta paperMeta = CraftItemStack.getItemMeta(nmsItemStack);
+        // Test craft meta
+        set.accept(craftMeta);
+        get.accept(craftMeta);
+
+        // Test paper meta
+        set.accept(paperMeta);
+        get.accept(paperMeta);
+    }
+
+}
diff --git a/src/test/java/io/papermc/paper/item/MetaSerializationTest.java b/src/test/java/io/papermc/paper/item/MetaSerializationTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..5a5acb6979b269e0d4560a6fffa216aafa52ac83
--- /dev/null
+++ b/src/test/java/io/papermc/paper/item/MetaSerializationTest.java
@@ -0,0 +1,23 @@
+package io.papermc.paper.item;
+
+import org.bukkit.Color;
+import org.bukkit.Material;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.inventory.meta.LeatherArmorMeta;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class MetaSerializationTest {
+
+    @Test
+    public void testModernPaperSerialization() {
+        ItemStack itemStack = new ItemStack(Material.LEATHER_CHESTPLATE);
+        itemStack.editMeta(LeatherArmorMeta.class, (meta) -> {
+            meta.setColor(Color.BLUE);
+        });
+
+        ItemStack deserialized = ItemStack.deserialize(itemStack.serialize());
+        LeatherArmorMeta armorMeta = (LeatherArmorMeta) deserialized.getItemMeta();
+        Assert.assertEquals(armorMeta.getColor(), Color.BLUE);
+    }
+}
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/DeprecatedItemMetaCustomValueTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/DeprecatedItemMetaCustomValueTest.java
index 13025119b32388f3e50503a355ef7d03837fd232..6f4cf8a326f8b5e1cedcf4a55fdbf3dfe009a45a 100644
--- a/src/test/java/org/bukkit/craftbukkit/inventory/DeprecatedItemMetaCustomValueTest.java
+++ b/src/test/java/org/bukkit/craftbukkit/inventory/DeprecatedItemMetaCustomValueTest.java
@@ -90,19 +90,20 @@ public class DeprecatedItemMetaCustomValueTest extends AbstractTestingBase {
     /*
         Removing a tag
      */
-    @Test
-    public void testNBTTagStoring() {
-        CraftMetaItem itemMeta = this.createComplexItemMeta();
-
-        CompoundTag compound = new CompoundTag();
-        itemMeta.applyToItem(compound);
-
-        assertEquals(itemMeta, new CraftMetaItem(compound));
-    }
+    // Paper - Remove test
+//    @Test
+//    public void testNBTTagStoring() {
+//        CraftMetaItem itemMeta = this.createComplexItemMeta();
+//
+//        CompoundTag compound = new CompoundTag();
+//        itemMeta.applyToItem(compound);
+//
+//        assertEquals(itemMeta, new CraftMetaItem(compound));
+//    }
 
     @Test
     public void testMapStoring() {
-        CraftMetaItem itemMeta = this.createComplexItemMeta();
+        ItemMeta itemMeta = this.createComplexItemMeta(); // Paper
 
         Map<String, Object> serialize = itemMeta.serialize();
         assertEquals(itemMeta, new CraftMetaItem(serialize));
@@ -111,7 +112,7 @@ public class DeprecatedItemMetaCustomValueTest extends AbstractTestingBase {
     @Test
     public void testYAMLStoring() {
         ItemStack stack = new ItemStack(Material.DIAMOND);
-        CraftMetaItem meta = this.createComplexItemMeta();
+        ItemMeta meta = this.createComplexItemMeta(); // Paper
         stack.setItemMeta(meta);
 
         YamlConfiguration configuration = new YamlConfiguration();
@@ -127,7 +128,7 @@ public class DeprecatedItemMetaCustomValueTest extends AbstractTestingBase {
     @Test
     public void testCorrectType() {
         ItemStack stack = new ItemStack(Material.DIAMOND);
-        CraftMetaItem meta = this.createComplexItemMeta();
+        ItemMeta meta = this.createComplexItemMeta(); // Paper
 
         meta.getCustomTagContainer().setCustomTag(this.requestKey("int"), ItemTagType.STRING, "1");
         meta.getCustomTagContainer().setCustomTag(this.requestKey("double"), ItemTagType.STRING, "1.33");
@@ -147,9 +148,10 @@ public class DeprecatedItemMetaCustomValueTest extends AbstractTestingBase {
         assertEquals(newStack.getItemMeta().getCustomTagContainer().getCustomTag(this.requestKey("double"), ItemTagType.STRING), "1.33");
     }
 
-    private CraftMetaItem createComplexItemMeta() {
-        CraftMetaItem itemMeta = (CraftMetaItem) this.createNewItemMeta();
-        itemMeta.unhandledTags.put("unhandled-test", StringTag.valueOf("test"));
+    // Paper start
+    private ItemMeta createComplexItemMeta() {
+        ItemMeta itemMeta = (ItemMeta) this.createNewItemMeta();
+    // Paper end
         itemMeta.setDisplayName("Item Display Name");
 
         itemMeta.getCustomTagContainer().setCustomTag(this.requestKey("custom-long"), ItemTagType.LONG, 4L); //Add random primitive values
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/FactoryItemMaterialTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/FactoryItemMaterialTest.java
index e706d547c03f3e07d56fdc7327fadd98f98ccc20..27f95b289538f05c55eb35ce725b467b3682bfb7 100644
--- a/src/test/java/org/bukkit/craftbukkit/inventory/FactoryItemMaterialTest.java
+++ b/src/test/java/org/bukkit/craftbukkit/inventory/FactoryItemMaterialTest.java
@@ -4,6 +4,8 @@ import static org.hamcrest.Matchers.*;
 import static org.junit.Assert.*;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.logging.Logger;
+
 import org.bukkit.Material;
 import org.bukkit.inventory.ItemFactory;
 import org.bukkit.inventory.ItemStack;
@@ -67,22 +69,20 @@ public class FactoryItemMaterialTest extends AbstractTestingBase {
 
     @Test
     public void generalCase() {
-        CraftMetaItem meta = (CraftMetaItem) FactoryItemMaterialTest.factory.getItemMeta(material);
+        ItemMeta meta = FactoryItemMaterialTest.factory.getItemMeta(material); // Paper
         if (meta == null) {
             assertThat(this.material, is(Material.AIR));
         } else {
             assertTrue(FactoryItemMaterialTest.factory.isApplicable(meta, material));
-            assertTrue(meta.applicableTo(material));
 
             meta = meta.clone();
             assertTrue(FactoryItemMaterialTest.factory.isApplicable(meta, material));
-            assertTrue(meta.applicableTo(material));
         }
     }
 
     @Test
     public void asMetaFor() {
-        final CraftMetaItem baseMeta = (CraftMetaItem) FactoryItemMaterialTest.factory.getItemMeta(material);
+        final ItemMeta baseMeta = FactoryItemMaterialTest.factory.getItemMeta(material);
         if (baseMeta == null) {
             assertThat(this.material, is(Material.AIR));
             return;
@@ -91,7 +91,7 @@ public class FactoryItemMaterialTest extends AbstractTestingBase {
         for (Material other : FactoryItemMaterialTest.materials) {
             final ItemStack bukkitStack = new ItemStack(other);
             final CraftItemStack craftStack = CraftItemStack.asCraftCopy(bukkitStack);
-            final CraftMetaItem otherMeta = (CraftMetaItem) FactoryItemMaterialTest.factory.asMetaFor(baseMeta, other);
+            final ItemMeta otherMeta = FactoryItemMaterialTest.factory.asMetaFor(baseMeta, other);
 
             final String testName = FactoryItemMaterialTest.name(this.material, other);
 
@@ -103,7 +103,6 @@ public class FactoryItemMaterialTest extends AbstractTestingBase {
             assertTrue(testName, FactoryItemMaterialTest.factory.isApplicable(otherMeta, craftStack));
             assertTrue(testName, FactoryItemMaterialTest.factory.isApplicable(otherMeta, bukkitStack));
             assertTrue(testName, FactoryItemMaterialTest.factory.isApplicable(otherMeta, other));
-            assertTrue(testName, otherMeta.applicableTo(other));
         }
     }
 
@@ -112,8 +111,8 @@ public class FactoryItemMaterialTest extends AbstractTestingBase {
         if (this.material == Material.AIR) {
             return;
         }
-        final CraftMetaItem baseMeta = (CraftMetaItem) FactoryItemMaterialTest.factory.getItemMeta(material);
-        final CraftMetaItem baseMetaClone = baseMeta.clone();
+        final ItemMeta baseMeta = FactoryItemMaterialTest.factory.getItemMeta(material); // Paper
+        final ItemMeta baseMetaClone = baseMeta.clone(); // Paper
 
         final ItemStack baseMetaStack = new ItemStack(this.material);
         baseMetaStack.setItemMeta(baseMeta);
@@ -134,7 +133,7 @@ public class FactoryItemMaterialTest extends AbstractTestingBase {
         for (Material other : FactoryItemMaterialTest.materials) {
             final String testName = FactoryItemMaterialTest.name(this.material, other);
 
-            final CraftMetaItem otherMeta = (CraftMetaItem) FactoryItemMaterialTest.factory.asMetaFor(baseMetaClone, other);
+            final ItemMeta otherMeta = FactoryItemMaterialTest.factory.asMetaFor(baseMetaClone, other); // Paper
 
             if (otherMeta == null) {
                 assertThat(testName, other, is(Material.AIR));
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaImplementationOverrideTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaImplementationOverrideTest.java
index 2cab00db9881b69714f1c250348b622c8092ab8f..ed68f6d4f415a0b26f56c8e29dd0cba5b0c60b69 100644
--- a/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaImplementationOverrideTest.java
+++ b/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaImplementationOverrideTest.java
@@ -17,15 +17,15 @@ import org.junit.runners.Parameterized.Parameters;
 
 @RunWith(Parameterized.class)
 public class ItemMetaImplementationOverrideTest {
-    static final Class<CraftMetaItem> parent = CraftMetaItem.class;
+    static final Class<io.papermc.paper.item.meta.PaperMeta> parent = io.papermc.paper.item.meta.PaperMeta.class; // Paper
 
     @Parameters(name = "[{index}]:{1}")
     public static List<Object[]> data() {
         final List<Object[]> testData = new ArrayList<Object[]>();
-        List<Class<? extends CraftMetaItem>> classes = new ArrayList<Class<? extends CraftMetaItem>>();
+        List<Class<? extends io.papermc.paper.item.meta.PaperMeta>> classes = new ArrayList<Class<? extends io.papermc.paper.item.meta.PaperMeta>>(); // Paper
 
         for (Material material : ItemStackTest.COMPOUND_MATERIALS) {
-            Class<? extends CraftMetaItem> clazz = CraftItemFactory.instance().getItemMeta(material).getClass().asSubclass(parent);
+            Class<? extends io.papermc.paper.item.meta.PaperMeta> clazz = CraftItemFactory.instance().getItemMeta(material).getClass().asSubclass(parent); // Paper
             if (clazz != ItemMetaImplementationOverrideTest.parent) {
                 classes.add(clazz);
             }
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaTest.java
index bc5427e6e7221245330723c290dd15abf45ffdda..14aeadd27ef12d920beaf15fcf2f0b91a0015da6 100644
--- a/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaTest.java
+++ b/src/test/java/org/bukkit/craftbukkit/inventory/ItemMetaTest.java
@@ -220,11 +220,11 @@ public class ItemMetaTest extends AbstractTestingBase {
         for (Item item : BuiltInRegistries.ITEM) {
             if (item instanceof net.minecraft.world.item.SpawnEggItem) {
                 Material material = CraftMagicNumbers.getMaterial(item);
-                CraftMetaItem baseMeta = (CraftMetaItem) Bukkit.getItemFactory().getItemMeta(material);
+                // Paper - remove API item builder
                 ItemMeta baseMetaItem = CraftItemStack.getItemMeta(item.getDefaultInstance());
 
-                assertTrue(material + " is not handled in CraftItemFactory", baseMeta instanceof CraftMetaSpawnEgg);
-                assertTrue(material + " is not applicable to CraftMetaSpawnEgg", baseMeta.applicableTo(material));
+                // Paper - remove craft meta spawn egg check
+                // Paper - remove isApplicable check
                 assertTrue(material + " is not handled in CraftItemStack", baseMetaItem instanceof SpawnEggMeta);
             }
         }
diff --git a/src/test/java/org/bukkit/craftbukkit/inventory/PersistentDataContainerTest.java b/src/test/java/org/bukkit/craftbukkit/inventory/PersistentDataContainerTest.java
index 9e84a0bddd7dc168d62be05675e73bfd49000125..83f54c822d0cbbb94deea659bed9795722edddd8 100644
--- a/src/test/java/org/bukkit/craftbukkit/inventory/PersistentDataContainerTest.java
+++ b/src/test/java/org/bukkit/craftbukkit/inventory/PersistentDataContainerTest.java
@@ -89,19 +89,20 @@ public class PersistentDataContainerTest extends AbstractTestingBase {
     /*
         Removing a tag
      */
-    @Test
-    public void testNBTTagStoring() {
-        CraftMetaItem itemMeta = this.createComplexItemMeta();
-
-        CompoundTag compound = new CompoundTag();
-        itemMeta.applyToItem(compound);
-
-        assertEquals(itemMeta, new CraftMetaItem(compound));
-    }
+    // Paper - Remove test
+//    @Test
+//    public void testNBTTagStoring() {
+//        ItemMeta itemMeta = this.createComplexItemMeta(); /// Paper
+//
+//        CompoundTag compound = new CompoundTag();
+//        itemMeta.applyToItem(compound);
+//
+//        assertEquals(itemMeta, new CraftMetaItem(compound));
+//    }
 
     @Test
     public void testMapStoring() {
-        CraftMetaItem itemMeta = this.createComplexItemMeta();
+        ItemMeta itemMeta = this.createComplexItemMeta(); // Paper
 
         Map<String, Object> serialize = itemMeta.serialize();
         assertEquals(itemMeta, new CraftMetaItem(serialize));
@@ -110,7 +111,7 @@ public class PersistentDataContainerTest extends AbstractTestingBase {
     @Test
     public void testYAMLStoring() {
         ItemStack stack = new ItemStack(Material.DIAMOND);
-        CraftMetaItem meta = this.createComplexItemMeta();
+        ItemMeta meta = this.createComplexItemMeta(); // Paper
         stack.setItemMeta(meta);
 
         YamlConfiguration configuration = new YamlConfiguration();
@@ -126,7 +127,7 @@ public class PersistentDataContainerTest extends AbstractTestingBase {
     @Test
     public void testCorrectType() {
         ItemStack stack = new ItemStack(Material.DIAMOND);
-        CraftMetaItem meta = this.createComplexItemMeta();
+        ItemMeta meta = this.createComplexItemMeta(); // Paper
 
         meta.getPersistentDataContainer().set(this.requestKey("int"), PersistentDataType.STRING, "1");
         meta.getPersistentDataContainer().set(this.requestKey("double"), PersistentDataType.STRING, "1.33");
@@ -146,8 +147,10 @@ public class PersistentDataContainerTest extends AbstractTestingBase {
         assertEquals(newStack.getItemMeta().getPersistentDataContainer().get(this.requestKey("double"), PersistentDataType.STRING), "1.33");
     }
 
-    private CraftMetaItem createComplexItemMeta() {
-        CraftMetaItem itemMeta = (CraftMetaItem) this.createNewItemMeta();
+    // Paper start
+    private ItemMeta createComplexItemMeta() {
+        ItemMeta itemMeta = (ItemMeta) this.createNewItemMeta();
+    // Paper end
         itemMeta.setDisplayName("Item Display Name");
 
         itemMeta.getPersistentDataContainer().set(this.requestKey("custom-long"), PersistentDataType.LONG, 4L); //Add random primitive values
