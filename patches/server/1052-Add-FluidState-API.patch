From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: vicisacat <victor.branchu@gmail.com>
Date: Fri, 17 Nov 2023 20:22:43 +0100
Subject: [PATCH] Add FluidState API


diff --git a/src/main/java/io/papermc/paper/block/fluid/PaperFluidData.java b/src/main/java/io/papermc/paper/block/fluid/PaperFluidData.java
new file mode 100644
index 0000000000000000000000000000000000000000..daab396d0cbb12d23a1db126551027301a319a22
--- /dev/null
+++ b/src/main/java/io/papermc/paper/block/fluid/PaperFluidData.java
@@ -0,0 +1,112 @@
+package io.papermc.paper.block.fluid;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.block.fluid.type.PaperFlowing;
+import io.papermc.paper.block.fluid.type.PaperFallingFluid;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Function;
+import io.papermc.paper.util.MCUtil;
+import net.minecraft.world.level.block.state.properties.Property;
+import net.minecraft.world.level.material.FluidState;
+import net.minecraft.world.level.material.LavaFluid;
+import net.minecraft.world.level.material.WaterFluid;
+import org.bukkit.Fluid;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.CraftFluid;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.util.CraftVector;
+import org.bukkit.util.Vector;
+
+public class PaperFluidData implements FluidData {
+
+    private static final Map<Class<? extends net.minecraft.world.level.material.Fluid>, Function<FluidState, PaperFluidData>> MAP = new HashMap<>();
+
+    private final FluidState state;
+
+    protected PaperFluidData(final FluidState state) {
+        this.state = state;
+    }
+
+    /* Registry */
+
+    static {
+        //<editor-fold desc="PaperFluidData Registration" defaultstate="collapsed">
+        register(LavaFluid.Source.class, PaperFallingFluid::new);
+        register(WaterFluid.Source.class, PaperFallingFluid::new);
+        register(LavaFluid.Flowing.class, PaperFlowing::new);
+        register(WaterFluid.Flowing.class, PaperFlowing::new);
+        //</editor-fold>
+    }
+
+    static void register(final Class<? extends net.minecraft.world.level.material.Fluid> fluid, final Function<FluidState, PaperFluidData> creator) {
+        Preconditions.checkState(MAP.put(fluid, creator) == null, "Duplicate mapping %s->%s", fluid, creator);
+        MAP.put(fluid, creator);
+    }
+
+    public static PaperFluidData createData(final FluidState state) {
+        return MAP.getOrDefault(state.getType().getClass(), PaperFluidData::new).apply(state);
+    }
+
+    /* Impl */
+
+    public FluidState getState() {
+        return this.state;
+    }
+
+    protected <T extends Comparable<T>> T get(final Property<T> property) {
+        return this.state.getValue(property);
+    }
+    /* API */
+
+    @Override
+    public final Fluid getFluidType() {
+        return CraftFluid.minecraftToBukkit(this.state.getType());
+    }
+
+    @Override
+    public PaperFluidData clone() {
+        try {
+            return (PaperFluidData) super.clone();
+        } catch (CloneNotSupportedException ex) {
+            throw new AssertionError("Clone not supported", ex);
+        }
+    }
+
+    @Override
+    public Vector getFlowDirection(Location location) {
+        Preconditions.checkArgument(location.getWorld() != null, "The location must contain a World!");
+        return CraftVector.toBukkit(this.state.getFlow(
+            ((CraftWorld) location.getWorld()).getHandle(), MCUtil.toBlockPosition(location)));
+    }
+
+    @Override
+    public int getAmount() {
+        return this.state.getAmount();
+    }
+
+    @Override
+    public float getHeight() {
+        return this.state.getOwnHeight();
+    }
+
+    @Override
+    public boolean isSource() {
+        return this.state.isSource();
+    }
+
+    @Override
+    public int hashCode() {
+        return this.state.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        return obj instanceof PaperFluidData paperFluidData && this.state.equals(paperFluidData.state);
+    }
+
+    @Override
+    public String toString() {
+        return "PaperFluidData{" + this.state + "}";
+    }
+}
diff --git a/src/main/java/io/papermc/paper/block/fluid/package-info.java b/src/main/java/io/papermc/paper/block/fluid/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..cfabb814ebd281aab299c6c655266ff357e08806
--- /dev/null
+++ b/src/main/java/io/papermc/paper/block/fluid/package-info.java
@@ -0,0 +1,5 @@
+@DefaultQualifier(NonNull.class)
+package io.papermc.paper.block.fluid;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
diff --git a/src/main/java/io/papermc/paper/block/fluid/type/PaperFallingFluid.java b/src/main/java/io/papermc/paper/block/fluid/type/PaperFallingFluid.java
new file mode 100644
index 0000000000000000000000000000000000000000..bf4b5e1b1c1cd13ed65c3b3fe1af13b8101e8d97
--- /dev/null
+++ b/src/main/java/io/papermc/paper/block/fluid/type/PaperFallingFluid.java
@@ -0,0 +1,18 @@
+
+package io.papermc.paper.block.fluid.type;
+
+import io.papermc.paper.block.fluid.PaperFluidData;
+import net.minecraft.world.level.material.FlowingFluid;
+import net.minecraft.world.level.material.FluidState;
+
+public class PaperFallingFluid extends PaperFluidData implements FallingFluid {
+
+    public PaperFallingFluid(final FluidState state) {
+        super(state);
+    }
+
+    @Override
+    public boolean isFalling() {
+        return this.get(FlowingFluid.FALLING);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/block/fluid/type/PaperFlowing.java b/src/main/java/io/papermc/paper/block/fluid/type/PaperFlowing.java
new file mode 100644
index 0000000000000000000000000000000000000000..d4ffc3bd801fdcd889fd85f3448dd25a732c209e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/block/fluid/type/PaperFlowing.java
@@ -0,0 +1,21 @@
+package io.papermc.paper.block.fluid.type;
+
+import net.minecraft.world.level.material.FlowingFluid;
+import net.minecraft.world.level.material.FluidState;
+
+public class PaperFlowing extends PaperFallingFluid implements Flowing {
+
+    public PaperFlowing(final FluidState state) {
+        super(state);
+    }
+
+    @Override
+    public int getMinimumLevel() {
+        return FlowingFluid.LEVEL.min;
+    }
+
+    @Override
+    public int getMaximumLevel() {
+        return FlowingFluid.LEVEL.max;
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftRegionAccessor.java b/src/main/java/org/bukkit/craftbukkit/CraftRegionAccessor.java
index 87698a123ce027b4f7b0dcc9eaf034a5b8de6de3..3091aec84959cd859266c88b7e623f62c1ae2759 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftRegionAccessor.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftRegionAccessor.java
@@ -255,6 +255,13 @@ public abstract class CraftRegionAccessor implements RegionAccessor {
         return CraftBlock.at(this.getHandle(), new BlockPos(x, y, z)).getState();
     }
 
+    // Paper start - FluidState API
+    @Override
+    public io.papermc.paper.block.fluid.FluidData getFluidData(final int x, final int y, final int z) {
+        return io.papermc.paper.block.fluid.PaperFluidData.createData(getHandle().getFluidState(new BlockPos(x, y, z)));
+    }
+    // Paper end
+
     @Override
     public BlockData getBlockData(Location location) {
         return this.getBlockData(location.getBlockX(), location.getBlockY(), location.getBlockZ());
