From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Sun, 21 Mar 2021 17:32:47 -0700
Subject: [PATCH] Correctly handle recursion for chunkholder updates

If a chunk ticket level is brought up while unloading it would
cause a recursive call which would handle the increase but then
the caller would think the chunk would be unloaded.

diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 292a26a2e13d97e4796bfe00c4d5789f94e67cc1..be8e63fb3e5c65157ea4ed9c0e3910aaba8c3d45 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -400,7 +400,9 @@ public class ChunkHolder {
         playerchunkmap.onFullChunkStatusChange(this.pos, playerchunk_state);
     }
 
+    protected long updateCount; // Paper - correctly handle recursion
     protected void updateFutures(ChunkMap chunkStorage, Executor executor) {
+        long updateCount = ++this.updateCount; // Paper - correctly handle recursion
         ChunkStatus chunkstatus = ChunkHolder.getStatus(this.oldTicketLevel);
         ChunkStatus chunkstatus1 = ChunkHolder.getStatus(this.ticketLevel);
         boolean flag = this.oldTicketLevel <= ChunkMap.MAX_CHUNK_DISTANCE;
@@ -429,6 +431,12 @@ public class ChunkHolder {
 
             // Run callback right away if the future was already done
             chunkStorage.callbackExecutor.run();
+            // Paper start - correctly handle recursion
+            if (this.updateCount != updateCount) {
+                // something else updated ticket level for us.
+                return;
+            }
+            // Paper end - correctly handle recursion
         }
         // CraftBukkit end
 
